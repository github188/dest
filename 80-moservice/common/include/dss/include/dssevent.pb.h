// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: dssevent.proto

#ifndef PROTOBUF_dssevent_2eproto__INCLUDED
#define PROTOBUF_dssevent_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
#include "dssevstruct.pb.h"
// @@protoc_insertion_point(includes)

namespace Dss {
namespace Event {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_dssevent_2eproto();
void protobuf_AssignDesc_dssevent_2eproto();
void protobuf_ShutdownFile_dssevent_2eproto();

class DssCltCreatClientReq;
class DssCltCreatClientAck;
class DssCltPing;
class CltDssPong;
class DssCltCreatClientNack;
class CltDssDestroyClientCmd;
class CltDssSyncApplyLanPortReq;
class DssCltSyncApplyLanPortReply;
class CltDssSyncApplyConsLanPortReq;
class DssCltSyncApplyConsLanPortReply;
class CltDssASyncApplyConsLanPortReq;
class DssCltASyncApplyConsLanPortReply;
class CltDssSyncApplyWanPortReq;
class DssCltSyncApplyWanPortReply;
class CltDssASyncApplyLanPortReq;
class DssCltASyncApplyLanPortReply;
class CltDssASyncApplyWanPortReq;
class DssCltASyncApplyWanPortReply;
class CltDssReleasePortCmd;
class CltDssAddBridgeReq;
class DssCltAddBridgeAck;
class DssCltAddBridgeNack;
class CltDssRemoveBridgeCmd;
class CltDssSendToBridgeReq;
class DssCltSendToBridgeAck;
class DssCltSendToBridgeNack;
class CltDssStopSendToBridgeCmd;
class CltDssReceiveFromBridgeReq;
class DssCltReceiveFromBridgeAck;
class DssCltReceiveFromBridgeNack;
class CltDssStopReceiveFromBridgeCmd;
class CltDssAddSwitchReq;
class DssCltAddSwitchAck;
class DssCltAddSwitchNack;
class CltDssAddM2OneSwitchReq;
class DssCltAddM2OneSwitchAck;
class DssCltAddM2OneSwitchNack;
class CltDssAddSrcSwitchReq;
class DssCltAddSrcSwitchAck;
class DssCltAddSrcSwitchNack;
class CltDssRemoveSwitchCmd;
class CltDssAddDumpReq;
class DssCltAddDumpAck;
class DssCltAddDumpNack;
class CltDssRemoveDumpCmd;
class DssCltSrvLostNtf;
class DssCltSrvRegisterNtf;
class CltDssAliveDetectReq;
class DssCltAliveDetectRsp;
class CltDssAttachLanIpOfPortReq;
class DssCltAttachLanIpOfPortAck;
class DssCltAttachLanIpOfPortNack;
class CltDssAttachWanIpOfPortReq;
class DssCltAttachWanIpOfPortAck;
class DssCltAttachWanIpOfPortNack;

// ===================================================================

class DssCltCreatClientReq : public ::google::protobuf::Message {
 public:
  DssCltCreatClientReq();
  virtual ~DssCltCreatClientReq();

  DssCltCreatClientReq(const DssCltCreatClientReq& from);

  inline DssCltCreatClientReq& operator=(const DssCltCreatClientReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DssCltCreatClientReq& default_instance();

  void Swap(DssCltCreatClientReq* other);

  // implements Message ----------------------------------------------

  DssCltCreatClientReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string Alias = 1;
  inline bool has_alias() const;
  inline void clear_alias();
  static const int kAliasFieldNumber = 1;
  inline const ::std::string& alias() const;
  inline void set_alias(const ::std::string& value);
  inline void set_alias(const char* value);
  inline void set_alias(const char* value, size_t size);
  inline ::std::string* mutable_alias();
  inline ::std::string* release_alias();
  inline void set_allocated_alias(::std::string* alias);

  // optional .Dss.Event.DssObj Type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::Dss::Event::DssObj type() const;
  inline void set_type(::Dss::Event::DssObj value);

  // optional string QName = 3;
  inline bool has_qname() const;
  inline void clear_qname();
  static const int kQNameFieldNumber = 3;
  inline const ::std::string& qname() const;
  inline void set_qname(const ::std::string& value);
  inline void set_qname(const char* value);
  inline void set_qname(const char* value, size_t size);
  inline ::std::string* mutable_qname();
  inline ::std::string* release_qname();
  inline void set_allocated_qname(::std::string* qname);

  // @@protoc_insertion_point(class_scope:Dss.Event.DssCltCreatClientReq)
 private:
  inline void set_has_alias();
  inline void clear_has_alias();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_qname();
  inline void clear_has_qname();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* alias_;
  ::std::string* qname_;
  int type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_dssevent_2eproto();
  friend void protobuf_AssignDesc_dssevent_2eproto();
  friend void protobuf_ShutdownFile_dssevent_2eproto();

  void InitAsDefaultInstance();
  static DssCltCreatClientReq* default_instance_;
};
// -------------------------------------------------------------------

class DssCltCreatClientAck : public ::google::protobuf::Message {
 public:
  DssCltCreatClientAck();
  virtual ~DssCltCreatClientAck();

  DssCltCreatClientAck(const DssCltCreatClientAck& from);

  inline DssCltCreatClientAck& operator=(const DssCltCreatClientAck& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DssCltCreatClientAck& default_instance();

  void Swap(DssCltCreatClientAck* other);

  // implements Message ----------------------------------------------

  DssCltCreatClientAck* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string Alias = 1;
  inline bool has_alias() const;
  inline void clear_alias();
  static const int kAliasFieldNumber = 1;
  inline const ::std::string& alias() const;
  inline void set_alias(const ::std::string& value);
  inline void set_alias(const char* value);
  inline void set_alias(const char* value, size_t size);
  inline ::std::string* mutable_alias();
  inline ::std::string* release_alias();
  inline void set_allocated_alias(::std::string* alias);

  // optional .Dss.Event.DssObj Type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::Dss::Event::DssObj type() const;
  inline void set_type(::Dss::Event::DssObj value);

  // optional uint32 ClientId = 3;
  inline bool has_clientid() const;
  inline void clear_clientid();
  static const int kClientIdFieldNumber = 3;
  inline ::google::protobuf::uint32 clientid() const;
  inline void set_clientid(::google::protobuf::uint32 value);

  // optional uint32 keepalivetime = 4;
  inline bool has_keepalivetime() const;
  inline void clear_keepalivetime();
  static const int kKeepalivetimeFieldNumber = 4;
  inline ::google::protobuf::uint32 keepalivetime() const;
  inline void set_keepalivetime(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Dss.Event.DssCltCreatClientAck)
 private:
  inline void set_has_alias();
  inline void clear_has_alias();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_clientid();
  inline void clear_has_clientid();
  inline void set_has_keepalivetime();
  inline void clear_has_keepalivetime();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* alias_;
  int type_;
  ::google::protobuf::uint32 clientid_;
  ::google::protobuf::uint32 keepalivetime_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_dssevent_2eproto();
  friend void protobuf_AssignDesc_dssevent_2eproto();
  friend void protobuf_ShutdownFile_dssevent_2eproto();

  void InitAsDefaultInstance();
  static DssCltCreatClientAck* default_instance_;
};
// -------------------------------------------------------------------

class DssCltPing : public ::google::protobuf::Message {
 public:
  DssCltPing();
  virtual ~DssCltPing();

  DssCltPing(const DssCltPing& from);

  inline DssCltPing& operator=(const DssCltPing& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DssCltPing& default_instance();

  void Swap(DssCltPing* other);

  // implements Message ----------------------------------------------

  DssCltPing* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 ClientId = 1;
  inline bool has_clientid() const;
  inline void clear_clientid();
  static const int kClientIdFieldNumber = 1;
  inline ::google::protobuf::uint32 clientid() const;
  inline void set_clientid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Dss.Event.DssCltPing)
 private:
  inline void set_has_clientid();
  inline void clear_has_clientid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 clientid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_dssevent_2eproto();
  friend void protobuf_AssignDesc_dssevent_2eproto();
  friend void protobuf_ShutdownFile_dssevent_2eproto();

  void InitAsDefaultInstance();
  static DssCltPing* default_instance_;
};
// -------------------------------------------------------------------

class CltDssPong : public ::google::protobuf::Message {
 public:
  CltDssPong();
  virtual ~CltDssPong();

  CltDssPong(const CltDssPong& from);

  inline CltDssPong& operator=(const CltDssPong& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CltDssPong& default_instance();

  void Swap(CltDssPong* other);

  // implements Message ----------------------------------------------

  CltDssPong* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 ClientId = 1;
  inline bool has_clientid() const;
  inline void clear_clientid();
  static const int kClientIdFieldNumber = 1;
  inline ::google::protobuf::uint32 clientid() const;
  inline void set_clientid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Dss.Event.CltDssPong)
 private:
  inline void set_has_clientid();
  inline void clear_has_clientid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 clientid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_dssevent_2eproto();
  friend void protobuf_AssignDesc_dssevent_2eproto();
  friend void protobuf_ShutdownFile_dssevent_2eproto();

  void InitAsDefaultInstance();
  static CltDssPong* default_instance_;
};
// -------------------------------------------------------------------

class DssCltCreatClientNack : public ::google::protobuf::Message {
 public:
  DssCltCreatClientNack();
  virtual ~DssCltCreatClientNack();

  DssCltCreatClientNack(const DssCltCreatClientNack& from);

  inline DssCltCreatClientNack& operator=(const DssCltCreatClientNack& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DssCltCreatClientNack& default_instance();

  void Swap(DssCltCreatClientNack* other);

  // implements Message ----------------------------------------------

  DssCltCreatClientNack* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string Alias = 1;
  inline bool has_alias() const;
  inline void clear_alias();
  static const int kAliasFieldNumber = 1;
  inline const ::std::string& alias() const;
  inline void set_alias(const ::std::string& value);
  inline void set_alias(const char* value);
  inline void set_alias(const char* value, size_t size);
  inline ::std::string* mutable_alias();
  inline ::std::string* release_alias();
  inline void set_allocated_alias(::std::string* alias);

  // optional .Dss.Event.DssObj Type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::Dss::Event::DssObj type() const;
  inline void set_type(::Dss::Event::DssObj value);

  // @@protoc_insertion_point(class_scope:Dss.Event.DssCltCreatClientNack)
 private:
  inline void set_has_alias();
  inline void clear_has_alias();
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* alias_;
  int type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_dssevent_2eproto();
  friend void protobuf_AssignDesc_dssevent_2eproto();
  friend void protobuf_ShutdownFile_dssevent_2eproto();

  void InitAsDefaultInstance();
  static DssCltCreatClientNack* default_instance_;
};
// -------------------------------------------------------------------

class CltDssDestroyClientCmd : public ::google::protobuf::Message {
 public:
  CltDssDestroyClientCmd();
  virtual ~CltDssDestroyClientCmd();

  CltDssDestroyClientCmd(const CltDssDestroyClientCmd& from);

  inline CltDssDestroyClientCmd& operator=(const CltDssDestroyClientCmd& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CltDssDestroyClientCmd& default_instance();

  void Swap(CltDssDestroyClientCmd* other);

  // implements Message ----------------------------------------------

  CltDssDestroyClientCmd* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 ClientId = 1;
  inline bool has_clientid() const;
  inline void clear_clientid();
  static const int kClientIdFieldNumber = 1;
  inline ::google::protobuf::uint32 clientid() const;
  inline void set_clientid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Dss.Event.CltDssDestroyClientCmd)
 private:
  inline void set_has_clientid();
  inline void clear_has_clientid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 clientid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_dssevent_2eproto();
  friend void protobuf_AssignDesc_dssevent_2eproto();
  friend void protobuf_ShutdownFile_dssevent_2eproto();

  void InitAsDefaultInstance();
  static CltDssDestroyClientCmd* default_instance_;
};
// -------------------------------------------------------------------

class CltDssSyncApplyLanPortReq : public ::google::protobuf::Message {
 public:
  CltDssSyncApplyLanPortReq();
  virtual ~CltDssSyncApplyLanPortReq();

  CltDssSyncApplyLanPortReq(const CltDssSyncApplyLanPortReq& from);

  inline CltDssSyncApplyLanPortReq& operator=(const CltDssSyncApplyLanPortReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CltDssSyncApplyLanPortReq& default_instance();

  void Swap(CltDssSyncApplyLanPortReq* other);

  // implements Message ----------------------------------------------

  CltDssSyncApplyLanPortReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 ClientId = 1;
  inline bool has_clientid() const;
  inline void clear_clientid();
  static const int kClientIdFieldNumber = 1;
  inline ::google::protobuf::uint32 clientid() const;
  inline void set_clientid(::google::protobuf::uint32 value);

  // optional string MeetingHandle = 2;
  inline bool has_meetinghandle() const;
  inline void clear_meetinghandle();
  static const int kMeetingHandleFieldNumber = 2;
  inline const ::std::string& meetinghandle() const;
  inline void set_meetinghandle(const ::std::string& value);
  inline void set_meetinghandle(const char* value);
  inline void set_meetinghandle(const char* value, size_t size);
  inline ::std::string* mutable_meetinghandle();
  inline ::std::string* release_meetinghandle();
  inline void set_allocated_meetinghandle(::std::string* meetinghandle);

  // optional uint32 BandWidth = 3;
  inline bool has_bandwidth() const;
  inline void clear_bandwidth();
  static const int kBandWidthFieldNumber = 3;
  inline ::google::protobuf::uint32 bandwidth() const;
  inline void set_bandwidth(::google::protobuf::uint32 value);

  // repeated .Dss.Event.ApplyLanPort portdesc = 4;
  inline int portdesc_size() const;
  inline void clear_portdesc();
  static const int kPortdescFieldNumber = 4;
  inline const ::Dss::Event::ApplyLanPort& portdesc(int index) const;
  inline ::Dss::Event::ApplyLanPort* mutable_portdesc(int index);
  inline ::Dss::Event::ApplyLanPort* add_portdesc();
  inline const ::google::protobuf::RepeatedPtrField< ::Dss::Event::ApplyLanPort >&
      portdesc() const;
  inline ::google::protobuf::RepeatedPtrField< ::Dss::Event::ApplyLanPort >*
      mutable_portdesc();

  // @@protoc_insertion_point(class_scope:Dss.Event.CltDssSyncApplyLanPortReq)
 private:
  inline void set_has_clientid();
  inline void clear_has_clientid();
  inline void set_has_meetinghandle();
  inline void clear_has_meetinghandle();
  inline void set_has_bandwidth();
  inline void clear_has_bandwidth();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* meetinghandle_;
  ::google::protobuf::uint32 clientid_;
  ::google::protobuf::uint32 bandwidth_;
  ::google::protobuf::RepeatedPtrField< ::Dss::Event::ApplyLanPort > portdesc_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_dssevent_2eproto();
  friend void protobuf_AssignDesc_dssevent_2eproto();
  friend void protobuf_ShutdownFile_dssevent_2eproto();

  void InitAsDefaultInstance();
  static CltDssSyncApplyLanPortReq* default_instance_;
};
// -------------------------------------------------------------------

class DssCltSyncApplyLanPortReply : public ::google::protobuf::Message {
 public:
  DssCltSyncApplyLanPortReply();
  virtual ~DssCltSyncApplyLanPortReply();

  DssCltSyncApplyLanPortReply(const DssCltSyncApplyLanPortReply& from);

  inline DssCltSyncApplyLanPortReply& operator=(const DssCltSyncApplyLanPortReply& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DssCltSyncApplyLanPortReply& default_instance();

  void Swap(DssCltSyncApplyLanPortReply* other);

  // implements Message ----------------------------------------------

  DssCltSyncApplyLanPortReply* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 ClientId = 1;
  inline bool has_clientid() const;
  inline void clear_clientid();
  static const int kClientIdFieldNumber = 1;
  inline ::google::protobuf::uint32 clientid() const;
  inline void set_clientid(::google::protobuf::uint32 value);

  // optional string MeetingHandle = 2;
  inline bool has_meetinghandle() const;
  inline void clear_meetinghandle();
  static const int kMeetingHandleFieldNumber = 2;
  inline const ::std::string& meetinghandle() const;
  inline void set_meetinghandle(const ::std::string& value);
  inline void set_meetinghandle(const char* value);
  inline void set_meetinghandle(const char* value, size_t size);
  inline ::std::string* mutable_meetinghandle();
  inline ::std::string* release_meetinghandle();
  inline void set_allocated_meetinghandle(::std::string* meetinghandle);

  // optional uint32 BandWidth = 3;
  inline bool has_bandwidth() const;
  inline void clear_bandwidth();
  static const int kBandWidthFieldNumber = 3;
  inline ::google::protobuf::uint32 bandwidth() const;
  inline void set_bandwidth(::google::protobuf::uint32 value);

  // repeated .Dss.Event.ApplyLanPortReply reply = 4;
  inline int reply_size() const;
  inline void clear_reply();
  static const int kReplyFieldNumber = 4;
  inline const ::Dss::Event::ApplyLanPortReply& reply(int index) const;
  inline ::Dss::Event::ApplyLanPortReply* mutable_reply(int index);
  inline ::Dss::Event::ApplyLanPortReply* add_reply();
  inline const ::google::protobuf::RepeatedPtrField< ::Dss::Event::ApplyLanPortReply >&
      reply() const;
  inline ::google::protobuf::RepeatedPtrField< ::Dss::Event::ApplyLanPortReply >*
      mutable_reply();

  // @@protoc_insertion_point(class_scope:Dss.Event.DssCltSyncApplyLanPortReply)
 private:
  inline void set_has_clientid();
  inline void clear_has_clientid();
  inline void set_has_meetinghandle();
  inline void clear_has_meetinghandle();
  inline void set_has_bandwidth();
  inline void clear_has_bandwidth();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* meetinghandle_;
  ::google::protobuf::uint32 clientid_;
  ::google::protobuf::uint32 bandwidth_;
  ::google::protobuf::RepeatedPtrField< ::Dss::Event::ApplyLanPortReply > reply_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_dssevent_2eproto();
  friend void protobuf_AssignDesc_dssevent_2eproto();
  friend void protobuf_ShutdownFile_dssevent_2eproto();

  void InitAsDefaultInstance();
  static DssCltSyncApplyLanPortReply* default_instance_;
};
// -------------------------------------------------------------------

class CltDssSyncApplyConsLanPortReq : public ::google::protobuf::Message {
 public:
  CltDssSyncApplyConsLanPortReq();
  virtual ~CltDssSyncApplyConsLanPortReq();

  CltDssSyncApplyConsLanPortReq(const CltDssSyncApplyConsLanPortReq& from);

  inline CltDssSyncApplyConsLanPortReq& operator=(const CltDssSyncApplyConsLanPortReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CltDssSyncApplyConsLanPortReq& default_instance();

  void Swap(CltDssSyncApplyConsLanPortReq* other);

  // implements Message ----------------------------------------------

  CltDssSyncApplyConsLanPortReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 ClientId = 1;
  inline bool has_clientid() const;
  inline void clear_clientid();
  static const int kClientIdFieldNumber = 1;
  inline ::google::protobuf::uint32 clientid() const;
  inline void set_clientid(::google::protobuf::uint32 value);

  // optional string MeetingHandle = 2;
  inline bool has_meetinghandle() const;
  inline void clear_meetinghandle();
  static const int kMeetingHandleFieldNumber = 2;
  inline const ::std::string& meetinghandle() const;
  inline void set_meetinghandle(const ::std::string& value);
  inline void set_meetinghandle(const char* value);
  inline void set_meetinghandle(const char* value, size_t size);
  inline ::std::string* mutable_meetinghandle();
  inline ::std::string* release_meetinghandle();
  inline void set_allocated_meetinghandle(::std::string* meetinghandle);

  // optional uint32 BandWidth = 3;
  inline bool has_bandwidth() const;
  inline void clear_bandwidth();
  static const int kBandWidthFieldNumber = 3;
  inline ::google::protobuf::uint32 bandwidth() const;
  inline void set_bandwidth(::google::protobuf::uint32 value);

  // optional .Dss.Event.ApplyLanPort portdesc = 4;
  inline bool has_portdesc() const;
  inline void clear_portdesc();
  static const int kPortdescFieldNumber = 4;
  inline const ::Dss::Event::ApplyLanPort& portdesc() const;
  inline ::Dss::Event::ApplyLanPort* mutable_portdesc();
  inline ::Dss::Event::ApplyLanPort* release_portdesc();
  inline void set_allocated_portdesc(::Dss::Event::ApplyLanPort* portdesc);

  // optional bool ForceIp = 5;
  inline bool has_forceip() const;
  inline void clear_forceip();
  static const int kForceIpFieldNumber = 5;
  inline bool forceip() const;
  inline void set_forceip(bool value);

  // optional bool Adaptive = 6;
  inline bool has_adaptive() const;
  inline void clear_adaptive();
  static const int kAdaptiveFieldNumber = 6;
  inline bool adaptive() const;
  inline void set_adaptive(bool value);

  // optional uint32 ConsPortNum = 7;
  inline bool has_consportnum() const;
  inline void clear_consportnum();
  static const int kConsPortNumFieldNumber = 7;
  inline ::google::protobuf::uint32 consportnum() const;
  inline void set_consportnum(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Dss.Event.CltDssSyncApplyConsLanPortReq)
 private:
  inline void set_has_clientid();
  inline void clear_has_clientid();
  inline void set_has_meetinghandle();
  inline void clear_has_meetinghandle();
  inline void set_has_bandwidth();
  inline void clear_has_bandwidth();
  inline void set_has_portdesc();
  inline void clear_has_portdesc();
  inline void set_has_forceip();
  inline void clear_has_forceip();
  inline void set_has_adaptive();
  inline void clear_has_adaptive();
  inline void set_has_consportnum();
  inline void clear_has_consportnum();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* meetinghandle_;
  ::google::protobuf::uint32 clientid_;
  ::google::protobuf::uint32 bandwidth_;
  ::Dss::Event::ApplyLanPort* portdesc_;
  bool forceip_;
  bool adaptive_;
  ::google::protobuf::uint32 consportnum_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_dssevent_2eproto();
  friend void protobuf_AssignDesc_dssevent_2eproto();
  friend void protobuf_ShutdownFile_dssevent_2eproto();

  void InitAsDefaultInstance();
  static CltDssSyncApplyConsLanPortReq* default_instance_;
};
// -------------------------------------------------------------------

class DssCltSyncApplyConsLanPortReply : public ::google::protobuf::Message {
 public:
  DssCltSyncApplyConsLanPortReply();
  virtual ~DssCltSyncApplyConsLanPortReply();

  DssCltSyncApplyConsLanPortReply(const DssCltSyncApplyConsLanPortReply& from);

  inline DssCltSyncApplyConsLanPortReply& operator=(const DssCltSyncApplyConsLanPortReply& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DssCltSyncApplyConsLanPortReply& default_instance();

  void Swap(DssCltSyncApplyConsLanPortReply* other);

  // implements Message ----------------------------------------------

  DssCltSyncApplyConsLanPortReply* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 ClientId = 1;
  inline bool has_clientid() const;
  inline void clear_clientid();
  static const int kClientIdFieldNumber = 1;
  inline ::google::protobuf::uint32 clientid() const;
  inline void set_clientid(::google::protobuf::uint32 value);

  // optional string MeetingHandle = 2;
  inline bool has_meetinghandle() const;
  inline void clear_meetinghandle();
  static const int kMeetingHandleFieldNumber = 2;
  inline const ::std::string& meetinghandle() const;
  inline void set_meetinghandle(const ::std::string& value);
  inline void set_meetinghandle(const char* value);
  inline void set_meetinghandle(const char* value, size_t size);
  inline ::std::string* mutable_meetinghandle();
  inline ::std::string* release_meetinghandle();
  inline void set_allocated_meetinghandle(::std::string* meetinghandle);

  // optional uint32 BandWidth = 3;
  inline bool has_bandwidth() const;
  inline void clear_bandwidth();
  static const int kBandWidthFieldNumber = 3;
  inline ::google::protobuf::uint32 bandwidth() const;
  inline void set_bandwidth(::google::protobuf::uint32 value);

  // optional .Dss.Event.ApplyLanPortReply reply = 4;
  inline bool has_reply() const;
  inline void clear_reply();
  static const int kReplyFieldNumber = 4;
  inline const ::Dss::Event::ApplyLanPortReply& reply() const;
  inline ::Dss::Event::ApplyLanPortReply* mutable_reply();
  inline ::Dss::Event::ApplyLanPortReply* release_reply();
  inline void set_allocated_reply(::Dss::Event::ApplyLanPortReply* reply);

  // optional bool ForceIp = 5;
  inline bool has_forceip() const;
  inline void clear_forceip();
  static const int kForceIpFieldNumber = 5;
  inline bool forceip() const;
  inline void set_forceip(bool value);

  // optional bool Adaptive = 6;
  inline bool has_adaptive() const;
  inline void clear_adaptive();
  static const int kAdaptiveFieldNumber = 6;
  inline bool adaptive() const;
  inline void set_adaptive(bool value);

  // optional uint32 ConsPortNum = 7;
  inline bool has_consportnum() const;
  inline void clear_consportnum();
  static const int kConsPortNumFieldNumber = 7;
  inline ::google::protobuf::uint32 consportnum() const;
  inline void set_consportnum(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Dss.Event.DssCltSyncApplyConsLanPortReply)
 private:
  inline void set_has_clientid();
  inline void clear_has_clientid();
  inline void set_has_meetinghandle();
  inline void clear_has_meetinghandle();
  inline void set_has_bandwidth();
  inline void clear_has_bandwidth();
  inline void set_has_reply();
  inline void clear_has_reply();
  inline void set_has_forceip();
  inline void clear_has_forceip();
  inline void set_has_adaptive();
  inline void clear_has_adaptive();
  inline void set_has_consportnum();
  inline void clear_has_consportnum();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* meetinghandle_;
  ::google::protobuf::uint32 clientid_;
  ::google::protobuf::uint32 bandwidth_;
  ::Dss::Event::ApplyLanPortReply* reply_;
  bool forceip_;
  bool adaptive_;
  ::google::protobuf::uint32 consportnum_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_dssevent_2eproto();
  friend void protobuf_AssignDesc_dssevent_2eproto();
  friend void protobuf_ShutdownFile_dssevent_2eproto();

  void InitAsDefaultInstance();
  static DssCltSyncApplyConsLanPortReply* default_instance_;
};
// -------------------------------------------------------------------

class CltDssASyncApplyConsLanPortReq : public ::google::protobuf::Message {
 public:
  CltDssASyncApplyConsLanPortReq();
  virtual ~CltDssASyncApplyConsLanPortReq();

  CltDssASyncApplyConsLanPortReq(const CltDssASyncApplyConsLanPortReq& from);

  inline CltDssASyncApplyConsLanPortReq& operator=(const CltDssASyncApplyConsLanPortReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CltDssASyncApplyConsLanPortReq& default_instance();

  void Swap(CltDssASyncApplyConsLanPortReq* other);

  // implements Message ----------------------------------------------

  CltDssASyncApplyConsLanPortReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 ClientId = 1;
  inline bool has_clientid() const;
  inline void clear_clientid();
  static const int kClientIdFieldNumber = 1;
  inline ::google::protobuf::uint32 clientid() const;
  inline void set_clientid(::google::protobuf::uint32 value);

  // optional string MeetingHandle = 2;
  inline bool has_meetinghandle() const;
  inline void clear_meetinghandle();
  static const int kMeetingHandleFieldNumber = 2;
  inline const ::std::string& meetinghandle() const;
  inline void set_meetinghandle(const ::std::string& value);
  inline void set_meetinghandle(const char* value);
  inline void set_meetinghandle(const char* value, size_t size);
  inline ::std::string* mutable_meetinghandle();
  inline ::std::string* release_meetinghandle();
  inline void set_allocated_meetinghandle(::std::string* meetinghandle);

  // optional uint32 BandWidth = 3;
  inline bool has_bandwidth() const;
  inline void clear_bandwidth();
  static const int kBandWidthFieldNumber = 3;
  inline ::google::protobuf::uint32 bandwidth() const;
  inline void set_bandwidth(::google::protobuf::uint32 value);

  // optional .Dss.Event.ApplyLanPort portdesc = 4;
  inline bool has_portdesc() const;
  inline void clear_portdesc();
  static const int kPortdescFieldNumber = 4;
  inline const ::Dss::Event::ApplyLanPort& portdesc() const;
  inline ::Dss::Event::ApplyLanPort* mutable_portdesc();
  inline ::Dss::Event::ApplyLanPort* release_portdesc();
  inline void set_allocated_portdesc(::Dss::Event::ApplyLanPort* portdesc);

  // optional bool ForceIp = 5;
  inline bool has_forceip() const;
  inline void clear_forceip();
  static const int kForceIpFieldNumber = 5;
  inline bool forceip() const;
  inline void set_forceip(bool value);

  // optional bool Adaptive = 6;
  inline bool has_adaptive() const;
  inline void clear_adaptive();
  static const int kAdaptiveFieldNumber = 6;
  inline bool adaptive() const;
  inline void set_adaptive(bool value);

  // optional uint32 ConsPortNum = 7;
  inline bool has_consportnum() const;
  inline void clear_consportnum();
  static const int kConsPortNumFieldNumber = 7;
  inline ::google::protobuf::uint32 consportnum() const;
  inline void set_consportnum(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Dss.Event.CltDssASyncApplyConsLanPortReq)
 private:
  inline void set_has_clientid();
  inline void clear_has_clientid();
  inline void set_has_meetinghandle();
  inline void clear_has_meetinghandle();
  inline void set_has_bandwidth();
  inline void clear_has_bandwidth();
  inline void set_has_portdesc();
  inline void clear_has_portdesc();
  inline void set_has_forceip();
  inline void clear_has_forceip();
  inline void set_has_adaptive();
  inline void clear_has_adaptive();
  inline void set_has_consportnum();
  inline void clear_has_consportnum();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* meetinghandle_;
  ::google::protobuf::uint32 clientid_;
  ::google::protobuf::uint32 bandwidth_;
  ::Dss::Event::ApplyLanPort* portdesc_;
  bool forceip_;
  bool adaptive_;
  ::google::protobuf::uint32 consportnum_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_dssevent_2eproto();
  friend void protobuf_AssignDesc_dssevent_2eproto();
  friend void protobuf_ShutdownFile_dssevent_2eproto();

  void InitAsDefaultInstance();
  static CltDssASyncApplyConsLanPortReq* default_instance_;
};
// -------------------------------------------------------------------

class DssCltASyncApplyConsLanPortReply : public ::google::protobuf::Message {
 public:
  DssCltASyncApplyConsLanPortReply();
  virtual ~DssCltASyncApplyConsLanPortReply();

  DssCltASyncApplyConsLanPortReply(const DssCltASyncApplyConsLanPortReply& from);

  inline DssCltASyncApplyConsLanPortReply& operator=(const DssCltASyncApplyConsLanPortReply& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DssCltASyncApplyConsLanPortReply& default_instance();

  void Swap(DssCltASyncApplyConsLanPortReply* other);

  // implements Message ----------------------------------------------

  DssCltASyncApplyConsLanPortReply* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 ClientId = 1;
  inline bool has_clientid() const;
  inline void clear_clientid();
  static const int kClientIdFieldNumber = 1;
  inline ::google::protobuf::uint32 clientid() const;
  inline void set_clientid(::google::protobuf::uint32 value);

  // optional string MeetingHandle = 2;
  inline bool has_meetinghandle() const;
  inline void clear_meetinghandle();
  static const int kMeetingHandleFieldNumber = 2;
  inline const ::std::string& meetinghandle() const;
  inline void set_meetinghandle(const ::std::string& value);
  inline void set_meetinghandle(const char* value);
  inline void set_meetinghandle(const char* value, size_t size);
  inline ::std::string* mutable_meetinghandle();
  inline ::std::string* release_meetinghandle();
  inline void set_allocated_meetinghandle(::std::string* meetinghandle);

  // optional uint32 BandWidth = 3;
  inline bool has_bandwidth() const;
  inline void clear_bandwidth();
  static const int kBandWidthFieldNumber = 3;
  inline ::google::protobuf::uint32 bandwidth() const;
  inline void set_bandwidth(::google::protobuf::uint32 value);

  // optional .Dss.Event.ApplyLanPortReply reply = 4;
  inline bool has_reply() const;
  inline void clear_reply();
  static const int kReplyFieldNumber = 4;
  inline const ::Dss::Event::ApplyLanPortReply& reply() const;
  inline ::Dss::Event::ApplyLanPortReply* mutable_reply();
  inline ::Dss::Event::ApplyLanPortReply* release_reply();
  inline void set_allocated_reply(::Dss::Event::ApplyLanPortReply* reply);

  // optional bool ForceIp = 5;
  inline bool has_forceip() const;
  inline void clear_forceip();
  static const int kForceIpFieldNumber = 5;
  inline bool forceip() const;
  inline void set_forceip(bool value);

  // optional bool Adaptive = 6;
  inline bool has_adaptive() const;
  inline void clear_adaptive();
  static const int kAdaptiveFieldNumber = 6;
  inline bool adaptive() const;
  inline void set_adaptive(bool value);

  // optional uint32 ConsPortNum = 7;
  inline bool has_consportnum() const;
  inline void clear_consportnum();
  static const int kConsPortNumFieldNumber = 7;
  inline ::google::protobuf::uint32 consportnum() const;
  inline void set_consportnum(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Dss.Event.DssCltASyncApplyConsLanPortReply)
 private:
  inline void set_has_clientid();
  inline void clear_has_clientid();
  inline void set_has_meetinghandle();
  inline void clear_has_meetinghandle();
  inline void set_has_bandwidth();
  inline void clear_has_bandwidth();
  inline void set_has_reply();
  inline void clear_has_reply();
  inline void set_has_forceip();
  inline void clear_has_forceip();
  inline void set_has_adaptive();
  inline void clear_has_adaptive();
  inline void set_has_consportnum();
  inline void clear_has_consportnum();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* meetinghandle_;
  ::google::protobuf::uint32 clientid_;
  ::google::protobuf::uint32 bandwidth_;
  ::Dss::Event::ApplyLanPortReply* reply_;
  bool forceip_;
  bool adaptive_;
  ::google::protobuf::uint32 consportnum_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_dssevent_2eproto();
  friend void protobuf_AssignDesc_dssevent_2eproto();
  friend void protobuf_ShutdownFile_dssevent_2eproto();

  void InitAsDefaultInstance();
  static DssCltASyncApplyConsLanPortReply* default_instance_;
};
// -------------------------------------------------------------------

class CltDssSyncApplyWanPortReq : public ::google::protobuf::Message {
 public:
  CltDssSyncApplyWanPortReq();
  virtual ~CltDssSyncApplyWanPortReq();

  CltDssSyncApplyWanPortReq(const CltDssSyncApplyWanPortReq& from);

  inline CltDssSyncApplyWanPortReq& operator=(const CltDssSyncApplyWanPortReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CltDssSyncApplyWanPortReq& default_instance();

  void Swap(CltDssSyncApplyWanPortReq* other);

  // implements Message ----------------------------------------------

  CltDssSyncApplyWanPortReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 ClientId = 1;
  inline bool has_clientid() const;
  inline void clear_clientid();
  static const int kClientIdFieldNumber = 1;
  inline ::google::protobuf::uint32 clientid() const;
  inline void set_clientid(::google::protobuf::uint32 value);

  // optional string MeetingHandle = 2;
  inline bool has_meetinghandle() const;
  inline void clear_meetinghandle();
  static const int kMeetingHandleFieldNumber = 2;
  inline const ::std::string& meetinghandle() const;
  inline void set_meetinghandle(const ::std::string& value);
  inline void set_meetinghandle(const char* value);
  inline void set_meetinghandle(const char* value, size_t size);
  inline ::std::string* mutable_meetinghandle();
  inline ::std::string* release_meetinghandle();
  inline void set_allocated_meetinghandle(::std::string* meetinghandle);

  // optional uint32 BandWidth = 3;
  inline bool has_bandwidth() const;
  inline void clear_bandwidth();
  static const int kBandWidthFieldNumber = 3;
  inline ::google::protobuf::uint32 bandwidth() const;
  inline void set_bandwidth(::google::protobuf::uint32 value);

  // repeated .Dss.Event.ApplyWanPort portdesc = 4;
  inline int portdesc_size() const;
  inline void clear_portdesc();
  static const int kPortdescFieldNumber = 4;
  inline const ::Dss::Event::ApplyWanPort& portdesc(int index) const;
  inline ::Dss::Event::ApplyWanPort* mutable_portdesc(int index);
  inline ::Dss::Event::ApplyWanPort* add_portdesc();
  inline const ::google::protobuf::RepeatedPtrField< ::Dss::Event::ApplyWanPort >&
      portdesc() const;
  inline ::google::protobuf::RepeatedPtrField< ::Dss::Event::ApplyWanPort >*
      mutable_portdesc();

  // @@protoc_insertion_point(class_scope:Dss.Event.CltDssSyncApplyWanPortReq)
 private:
  inline void set_has_clientid();
  inline void clear_has_clientid();
  inline void set_has_meetinghandle();
  inline void clear_has_meetinghandle();
  inline void set_has_bandwidth();
  inline void clear_has_bandwidth();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* meetinghandle_;
  ::google::protobuf::uint32 clientid_;
  ::google::protobuf::uint32 bandwidth_;
  ::google::protobuf::RepeatedPtrField< ::Dss::Event::ApplyWanPort > portdesc_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_dssevent_2eproto();
  friend void protobuf_AssignDesc_dssevent_2eproto();
  friend void protobuf_ShutdownFile_dssevent_2eproto();

  void InitAsDefaultInstance();
  static CltDssSyncApplyWanPortReq* default_instance_;
};
// -------------------------------------------------------------------

class DssCltSyncApplyWanPortReply : public ::google::protobuf::Message {
 public:
  DssCltSyncApplyWanPortReply();
  virtual ~DssCltSyncApplyWanPortReply();

  DssCltSyncApplyWanPortReply(const DssCltSyncApplyWanPortReply& from);

  inline DssCltSyncApplyWanPortReply& operator=(const DssCltSyncApplyWanPortReply& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DssCltSyncApplyWanPortReply& default_instance();

  void Swap(DssCltSyncApplyWanPortReply* other);

  // implements Message ----------------------------------------------

  DssCltSyncApplyWanPortReply* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 ClientId = 1;
  inline bool has_clientid() const;
  inline void clear_clientid();
  static const int kClientIdFieldNumber = 1;
  inline ::google::protobuf::uint32 clientid() const;
  inline void set_clientid(::google::protobuf::uint32 value);

  // optional string MeetingHandle = 2;
  inline bool has_meetinghandle() const;
  inline void clear_meetinghandle();
  static const int kMeetingHandleFieldNumber = 2;
  inline const ::std::string& meetinghandle() const;
  inline void set_meetinghandle(const ::std::string& value);
  inline void set_meetinghandle(const char* value);
  inline void set_meetinghandle(const char* value, size_t size);
  inline ::std::string* mutable_meetinghandle();
  inline ::std::string* release_meetinghandle();
  inline void set_allocated_meetinghandle(::std::string* meetinghandle);

  // optional uint32 BandWidth = 3;
  inline bool has_bandwidth() const;
  inline void clear_bandwidth();
  static const int kBandWidthFieldNumber = 3;
  inline ::google::protobuf::uint32 bandwidth() const;
  inline void set_bandwidth(::google::protobuf::uint32 value);

  // repeated .Dss.Event.ApplyWanPortReply reply = 4;
  inline int reply_size() const;
  inline void clear_reply();
  static const int kReplyFieldNumber = 4;
  inline const ::Dss::Event::ApplyWanPortReply& reply(int index) const;
  inline ::Dss::Event::ApplyWanPortReply* mutable_reply(int index);
  inline ::Dss::Event::ApplyWanPortReply* add_reply();
  inline const ::google::protobuf::RepeatedPtrField< ::Dss::Event::ApplyWanPortReply >&
      reply() const;
  inline ::google::protobuf::RepeatedPtrField< ::Dss::Event::ApplyWanPortReply >*
      mutable_reply();

  // @@protoc_insertion_point(class_scope:Dss.Event.DssCltSyncApplyWanPortReply)
 private:
  inline void set_has_clientid();
  inline void clear_has_clientid();
  inline void set_has_meetinghandle();
  inline void clear_has_meetinghandle();
  inline void set_has_bandwidth();
  inline void clear_has_bandwidth();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* meetinghandle_;
  ::google::protobuf::uint32 clientid_;
  ::google::protobuf::uint32 bandwidth_;
  ::google::protobuf::RepeatedPtrField< ::Dss::Event::ApplyWanPortReply > reply_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_dssevent_2eproto();
  friend void protobuf_AssignDesc_dssevent_2eproto();
  friend void protobuf_ShutdownFile_dssevent_2eproto();

  void InitAsDefaultInstance();
  static DssCltSyncApplyWanPortReply* default_instance_;
};
// -------------------------------------------------------------------

class CltDssASyncApplyLanPortReq : public ::google::protobuf::Message {
 public:
  CltDssASyncApplyLanPortReq();
  virtual ~CltDssASyncApplyLanPortReq();

  CltDssASyncApplyLanPortReq(const CltDssASyncApplyLanPortReq& from);

  inline CltDssASyncApplyLanPortReq& operator=(const CltDssASyncApplyLanPortReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CltDssASyncApplyLanPortReq& default_instance();

  void Swap(CltDssASyncApplyLanPortReq* other);

  // implements Message ----------------------------------------------

  CltDssASyncApplyLanPortReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 ClientId = 1;
  inline bool has_clientid() const;
  inline void clear_clientid();
  static const int kClientIdFieldNumber = 1;
  inline ::google::protobuf::uint32 clientid() const;
  inline void set_clientid(::google::protobuf::uint32 value);

  // optional string MeetingHandle = 2;
  inline bool has_meetinghandle() const;
  inline void clear_meetinghandle();
  static const int kMeetingHandleFieldNumber = 2;
  inline const ::std::string& meetinghandle() const;
  inline void set_meetinghandle(const ::std::string& value);
  inline void set_meetinghandle(const char* value);
  inline void set_meetinghandle(const char* value, size_t size);
  inline ::std::string* mutable_meetinghandle();
  inline ::std::string* release_meetinghandle();
  inline void set_allocated_meetinghandle(::std::string* meetinghandle);

  // optional uint32 BandWidth = 3;
  inline bool has_bandwidth() const;
  inline void clear_bandwidth();
  static const int kBandWidthFieldNumber = 3;
  inline ::google::protobuf::uint32 bandwidth() const;
  inline void set_bandwidth(::google::protobuf::uint32 value);

  // repeated .Dss.Event.ApplyLanPort portdesc = 4;
  inline int portdesc_size() const;
  inline void clear_portdesc();
  static const int kPortdescFieldNumber = 4;
  inline const ::Dss::Event::ApplyLanPort& portdesc(int index) const;
  inline ::Dss::Event::ApplyLanPort* mutable_portdesc(int index);
  inline ::Dss::Event::ApplyLanPort* add_portdesc();
  inline const ::google::protobuf::RepeatedPtrField< ::Dss::Event::ApplyLanPort >&
      portdesc() const;
  inline ::google::protobuf::RepeatedPtrField< ::Dss::Event::ApplyLanPort >*
      mutable_portdesc();

  // @@protoc_insertion_point(class_scope:Dss.Event.CltDssASyncApplyLanPortReq)
 private:
  inline void set_has_clientid();
  inline void clear_has_clientid();
  inline void set_has_meetinghandle();
  inline void clear_has_meetinghandle();
  inline void set_has_bandwidth();
  inline void clear_has_bandwidth();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* meetinghandle_;
  ::google::protobuf::uint32 clientid_;
  ::google::protobuf::uint32 bandwidth_;
  ::google::protobuf::RepeatedPtrField< ::Dss::Event::ApplyLanPort > portdesc_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_dssevent_2eproto();
  friend void protobuf_AssignDesc_dssevent_2eproto();
  friend void protobuf_ShutdownFile_dssevent_2eproto();

  void InitAsDefaultInstance();
  static CltDssASyncApplyLanPortReq* default_instance_;
};
// -------------------------------------------------------------------

class DssCltASyncApplyLanPortReply : public ::google::protobuf::Message {
 public:
  DssCltASyncApplyLanPortReply();
  virtual ~DssCltASyncApplyLanPortReply();

  DssCltASyncApplyLanPortReply(const DssCltASyncApplyLanPortReply& from);

  inline DssCltASyncApplyLanPortReply& operator=(const DssCltASyncApplyLanPortReply& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DssCltASyncApplyLanPortReply& default_instance();

  void Swap(DssCltASyncApplyLanPortReply* other);

  // implements Message ----------------------------------------------

  DssCltASyncApplyLanPortReply* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 ClientId = 1;
  inline bool has_clientid() const;
  inline void clear_clientid();
  static const int kClientIdFieldNumber = 1;
  inline ::google::protobuf::uint32 clientid() const;
  inline void set_clientid(::google::protobuf::uint32 value);

  // optional string MeetingHandle = 2;
  inline bool has_meetinghandle() const;
  inline void clear_meetinghandle();
  static const int kMeetingHandleFieldNumber = 2;
  inline const ::std::string& meetinghandle() const;
  inline void set_meetinghandle(const ::std::string& value);
  inline void set_meetinghandle(const char* value);
  inline void set_meetinghandle(const char* value, size_t size);
  inline ::std::string* mutable_meetinghandle();
  inline ::std::string* release_meetinghandle();
  inline void set_allocated_meetinghandle(::std::string* meetinghandle);

  // optional uint32 BandWidth = 3;
  inline bool has_bandwidth() const;
  inline void clear_bandwidth();
  static const int kBandWidthFieldNumber = 3;
  inline ::google::protobuf::uint32 bandwidth() const;
  inline void set_bandwidth(::google::protobuf::uint32 value);

  // repeated .Dss.Event.ApplyLanPortReply reply = 4;
  inline int reply_size() const;
  inline void clear_reply();
  static const int kReplyFieldNumber = 4;
  inline const ::Dss::Event::ApplyLanPortReply& reply(int index) const;
  inline ::Dss::Event::ApplyLanPortReply* mutable_reply(int index);
  inline ::Dss::Event::ApplyLanPortReply* add_reply();
  inline const ::google::protobuf::RepeatedPtrField< ::Dss::Event::ApplyLanPortReply >&
      reply() const;
  inline ::google::protobuf::RepeatedPtrField< ::Dss::Event::ApplyLanPortReply >*
      mutable_reply();

  // @@protoc_insertion_point(class_scope:Dss.Event.DssCltASyncApplyLanPortReply)
 private:
  inline void set_has_clientid();
  inline void clear_has_clientid();
  inline void set_has_meetinghandle();
  inline void clear_has_meetinghandle();
  inline void set_has_bandwidth();
  inline void clear_has_bandwidth();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* meetinghandle_;
  ::google::protobuf::uint32 clientid_;
  ::google::protobuf::uint32 bandwidth_;
  ::google::protobuf::RepeatedPtrField< ::Dss::Event::ApplyLanPortReply > reply_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_dssevent_2eproto();
  friend void protobuf_AssignDesc_dssevent_2eproto();
  friend void protobuf_ShutdownFile_dssevent_2eproto();

  void InitAsDefaultInstance();
  static DssCltASyncApplyLanPortReply* default_instance_;
};
// -------------------------------------------------------------------

class CltDssASyncApplyWanPortReq : public ::google::protobuf::Message {
 public:
  CltDssASyncApplyWanPortReq();
  virtual ~CltDssASyncApplyWanPortReq();

  CltDssASyncApplyWanPortReq(const CltDssASyncApplyWanPortReq& from);

  inline CltDssASyncApplyWanPortReq& operator=(const CltDssASyncApplyWanPortReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CltDssASyncApplyWanPortReq& default_instance();

  void Swap(CltDssASyncApplyWanPortReq* other);

  // implements Message ----------------------------------------------

  CltDssASyncApplyWanPortReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 ClientId = 1;
  inline bool has_clientid() const;
  inline void clear_clientid();
  static const int kClientIdFieldNumber = 1;
  inline ::google::protobuf::uint32 clientid() const;
  inline void set_clientid(::google::protobuf::uint32 value);

  // optional string MeetingHandle = 2;
  inline bool has_meetinghandle() const;
  inline void clear_meetinghandle();
  static const int kMeetingHandleFieldNumber = 2;
  inline const ::std::string& meetinghandle() const;
  inline void set_meetinghandle(const ::std::string& value);
  inline void set_meetinghandle(const char* value);
  inline void set_meetinghandle(const char* value, size_t size);
  inline ::std::string* mutable_meetinghandle();
  inline ::std::string* release_meetinghandle();
  inline void set_allocated_meetinghandle(::std::string* meetinghandle);

  // optional uint32 BandWidth = 3;
  inline bool has_bandwidth() const;
  inline void clear_bandwidth();
  static const int kBandWidthFieldNumber = 3;
  inline ::google::protobuf::uint32 bandwidth() const;
  inline void set_bandwidth(::google::protobuf::uint32 value);

  // repeated .Dss.Event.ApplyWanPort portdesc = 4;
  inline int portdesc_size() const;
  inline void clear_portdesc();
  static const int kPortdescFieldNumber = 4;
  inline const ::Dss::Event::ApplyWanPort& portdesc(int index) const;
  inline ::Dss::Event::ApplyWanPort* mutable_portdesc(int index);
  inline ::Dss::Event::ApplyWanPort* add_portdesc();
  inline const ::google::protobuf::RepeatedPtrField< ::Dss::Event::ApplyWanPort >&
      portdesc() const;
  inline ::google::protobuf::RepeatedPtrField< ::Dss::Event::ApplyWanPort >*
      mutable_portdesc();

  // @@protoc_insertion_point(class_scope:Dss.Event.CltDssASyncApplyWanPortReq)
 private:
  inline void set_has_clientid();
  inline void clear_has_clientid();
  inline void set_has_meetinghandle();
  inline void clear_has_meetinghandle();
  inline void set_has_bandwidth();
  inline void clear_has_bandwidth();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* meetinghandle_;
  ::google::protobuf::uint32 clientid_;
  ::google::protobuf::uint32 bandwidth_;
  ::google::protobuf::RepeatedPtrField< ::Dss::Event::ApplyWanPort > portdesc_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_dssevent_2eproto();
  friend void protobuf_AssignDesc_dssevent_2eproto();
  friend void protobuf_ShutdownFile_dssevent_2eproto();

  void InitAsDefaultInstance();
  static CltDssASyncApplyWanPortReq* default_instance_;
};
// -------------------------------------------------------------------

class DssCltASyncApplyWanPortReply : public ::google::protobuf::Message {
 public:
  DssCltASyncApplyWanPortReply();
  virtual ~DssCltASyncApplyWanPortReply();

  DssCltASyncApplyWanPortReply(const DssCltASyncApplyWanPortReply& from);

  inline DssCltASyncApplyWanPortReply& operator=(const DssCltASyncApplyWanPortReply& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DssCltASyncApplyWanPortReply& default_instance();

  void Swap(DssCltASyncApplyWanPortReply* other);

  // implements Message ----------------------------------------------

  DssCltASyncApplyWanPortReply* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 ClientId = 1;
  inline bool has_clientid() const;
  inline void clear_clientid();
  static const int kClientIdFieldNumber = 1;
  inline ::google::protobuf::uint32 clientid() const;
  inline void set_clientid(::google::protobuf::uint32 value);

  // optional string MeetingHandle = 2;
  inline bool has_meetinghandle() const;
  inline void clear_meetinghandle();
  static const int kMeetingHandleFieldNumber = 2;
  inline const ::std::string& meetinghandle() const;
  inline void set_meetinghandle(const ::std::string& value);
  inline void set_meetinghandle(const char* value);
  inline void set_meetinghandle(const char* value, size_t size);
  inline ::std::string* mutable_meetinghandle();
  inline ::std::string* release_meetinghandle();
  inline void set_allocated_meetinghandle(::std::string* meetinghandle);

  // optional uint32 BandWidth = 3;
  inline bool has_bandwidth() const;
  inline void clear_bandwidth();
  static const int kBandWidthFieldNumber = 3;
  inline ::google::protobuf::uint32 bandwidth() const;
  inline void set_bandwidth(::google::protobuf::uint32 value);

  // repeated .Dss.Event.ApplyWanPortReply reply = 4;
  inline int reply_size() const;
  inline void clear_reply();
  static const int kReplyFieldNumber = 4;
  inline const ::Dss::Event::ApplyWanPortReply& reply(int index) const;
  inline ::Dss::Event::ApplyWanPortReply* mutable_reply(int index);
  inline ::Dss::Event::ApplyWanPortReply* add_reply();
  inline const ::google::protobuf::RepeatedPtrField< ::Dss::Event::ApplyWanPortReply >&
      reply() const;
  inline ::google::protobuf::RepeatedPtrField< ::Dss::Event::ApplyWanPortReply >*
      mutable_reply();

  // @@protoc_insertion_point(class_scope:Dss.Event.DssCltASyncApplyWanPortReply)
 private:
  inline void set_has_clientid();
  inline void clear_has_clientid();
  inline void set_has_meetinghandle();
  inline void clear_has_meetinghandle();
  inline void set_has_bandwidth();
  inline void clear_has_bandwidth();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* meetinghandle_;
  ::google::protobuf::uint32 clientid_;
  ::google::protobuf::uint32 bandwidth_;
  ::google::protobuf::RepeatedPtrField< ::Dss::Event::ApplyWanPortReply > reply_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_dssevent_2eproto();
  friend void protobuf_AssignDesc_dssevent_2eproto();
  friend void protobuf_ShutdownFile_dssevent_2eproto();

  void InitAsDefaultInstance();
  static DssCltASyncApplyWanPortReply* default_instance_;
};
// -------------------------------------------------------------------

class CltDssReleasePortCmd : public ::google::protobuf::Message {
 public:
  CltDssReleasePortCmd();
  virtual ~CltDssReleasePortCmd();

  CltDssReleasePortCmd(const CltDssReleasePortCmd& from);

  inline CltDssReleasePortCmd& operator=(const CltDssReleasePortCmd& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CltDssReleasePortCmd& default_instance();

  void Swap(CltDssReleasePortCmd* other);

  // implements Message ----------------------------------------------

  CltDssReleasePortCmd* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 ClientId = 1;
  inline bool has_clientid() const;
  inline void clear_clientid();
  static const int kClientIdFieldNumber = 1;
  inline ::google::protobuf::uint32 clientid() const;
  inline void set_clientid(::google::protobuf::uint32 value);

  // optional .Dss.Event.DssNetAddr Address = 2;
  inline bool has_address() const;
  inline void clear_address();
  static const int kAddressFieldNumber = 2;
  inline const ::Dss::Event::DssNetAddr& address() const;
  inline ::Dss::Event::DssNetAddr* mutable_address();
  inline ::Dss::Event::DssNetAddr* release_address();
  inline void set_allocated_address(::Dss::Event::DssNetAddr* address);

  // @@protoc_insertion_point(class_scope:Dss.Event.CltDssReleasePortCmd)
 private:
  inline void set_has_clientid();
  inline void clear_has_clientid();
  inline void set_has_address();
  inline void clear_has_address();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Dss::Event::DssNetAddr* address_;
  ::google::protobuf::uint32 clientid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_dssevent_2eproto();
  friend void protobuf_AssignDesc_dssevent_2eproto();
  friend void protobuf_ShutdownFile_dssevent_2eproto();

  void InitAsDefaultInstance();
  static CltDssReleasePortCmd* default_instance_;
};
// -------------------------------------------------------------------

class CltDssAddBridgeReq : public ::google::protobuf::Message {
 public:
  CltDssAddBridgeReq();
  virtual ~CltDssAddBridgeReq();

  CltDssAddBridgeReq(const CltDssAddBridgeReq& from);

  inline CltDssAddBridgeReq& operator=(const CltDssAddBridgeReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CltDssAddBridgeReq& default_instance();

  void Swap(CltDssAddBridgeReq* other);

  // implements Message ----------------------------------------------

  CltDssAddBridgeReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 ClientId = 1;
  inline bool has_clientid() const;
  inline void clear_clientid();
  static const int kClientIdFieldNumber = 1;
  inline ::google::protobuf::uint32 clientid() const;
  inline void set_clientid(::google::protobuf::uint32 value);

  // optional .Dss.Event.DssNetAddr RcvAddr = 2;
  inline bool has_rcvaddr() const;
  inline void clear_rcvaddr();
  static const int kRcvAddrFieldNumber = 2;
  inline const ::Dss::Event::DssNetAddr& rcvaddr() const;
  inline ::Dss::Event::DssNetAddr* mutable_rcvaddr();
  inline ::Dss::Event::DssNetAddr* release_rcvaddr();
  inline void set_allocated_rcvaddr(::Dss::Event::DssNetAddr* rcvaddr);

  // optional uint32 StartServerHandle = 3;
  inline bool has_startserverhandle() const;
  inline void clear_startserverhandle();
  static const int kStartServerHandleFieldNumber = 3;
  inline ::google::protobuf::uint32 startserverhandle() const;
  inline void set_startserverhandle(::google::protobuf::uint32 value);

  // optional bool forceip = 4;
  inline bool has_forceip() const;
  inline void clear_forceip();
  static const int kForceipFieldNumber = 4;
  inline bool forceip() const;
  inline void set_forceip(bool value);

  // @@protoc_insertion_point(class_scope:Dss.Event.CltDssAddBridgeReq)
 private:
  inline void set_has_clientid();
  inline void clear_has_clientid();
  inline void set_has_rcvaddr();
  inline void clear_has_rcvaddr();
  inline void set_has_startserverhandle();
  inline void clear_has_startserverhandle();
  inline void set_has_forceip();
  inline void clear_has_forceip();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Dss::Event::DssNetAddr* rcvaddr_;
  ::google::protobuf::uint32 clientid_;
  ::google::protobuf::uint32 startserverhandle_;
  bool forceip_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_dssevent_2eproto();
  friend void protobuf_AssignDesc_dssevent_2eproto();
  friend void protobuf_ShutdownFile_dssevent_2eproto();

  void InitAsDefaultInstance();
  static CltDssAddBridgeReq* default_instance_;
};
// -------------------------------------------------------------------

class DssCltAddBridgeAck : public ::google::protobuf::Message {
 public:
  DssCltAddBridgeAck();
  virtual ~DssCltAddBridgeAck();

  DssCltAddBridgeAck(const DssCltAddBridgeAck& from);

  inline DssCltAddBridgeAck& operator=(const DssCltAddBridgeAck& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DssCltAddBridgeAck& default_instance();

  void Swap(DssCltAddBridgeAck* other);

  // implements Message ----------------------------------------------

  DssCltAddBridgeAck* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 ClientId = 1;
  inline bool has_clientid() const;
  inline void clear_clientid();
  static const int kClientIdFieldNumber = 1;
  inline ::google::protobuf::uint32 clientid() const;
  inline void set_clientid(::google::protobuf::uint32 value);

  // optional .Dss.Event.DssNetAddr RcvAddr = 2;
  inline bool has_rcvaddr() const;
  inline void clear_rcvaddr();
  static const int kRcvAddrFieldNumber = 2;
  inline const ::Dss::Event::DssNetAddr& rcvaddr() const;
  inline ::Dss::Event::DssNetAddr* mutable_rcvaddr();
  inline ::Dss::Event::DssNetAddr* release_rcvaddr();
  inline void set_allocated_rcvaddr(::Dss::Event::DssNetAddr* rcvaddr);

  // optional uint32 StartServerHandle = 3;
  inline bool has_startserverhandle() const;
  inline void clear_startserverhandle();
  static const int kStartServerHandleFieldNumber = 3;
  inline ::google::protobuf::uint32 startserverhandle() const;
  inline void set_startserverhandle(::google::protobuf::uint32 value);

  // optional uint32 BridgeHandle = 4;
  inline bool has_bridgehandle() const;
  inline void clear_bridgehandle();
  static const int kBridgeHandleFieldNumber = 4;
  inline ::google::protobuf::uint32 bridgehandle() const;
  inline void set_bridgehandle(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Dss.Event.DssCltAddBridgeAck)
 private:
  inline void set_has_clientid();
  inline void clear_has_clientid();
  inline void set_has_rcvaddr();
  inline void clear_has_rcvaddr();
  inline void set_has_startserverhandle();
  inline void clear_has_startserverhandle();
  inline void set_has_bridgehandle();
  inline void clear_has_bridgehandle();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Dss::Event::DssNetAddr* rcvaddr_;
  ::google::protobuf::uint32 clientid_;
  ::google::protobuf::uint32 startserverhandle_;
  ::google::protobuf::uint32 bridgehandle_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_dssevent_2eproto();
  friend void protobuf_AssignDesc_dssevent_2eproto();
  friend void protobuf_ShutdownFile_dssevent_2eproto();

  void InitAsDefaultInstance();
  static DssCltAddBridgeAck* default_instance_;
};
// -------------------------------------------------------------------

class DssCltAddBridgeNack : public ::google::protobuf::Message {
 public:
  DssCltAddBridgeNack();
  virtual ~DssCltAddBridgeNack();

  DssCltAddBridgeNack(const DssCltAddBridgeNack& from);

  inline DssCltAddBridgeNack& operator=(const DssCltAddBridgeNack& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DssCltAddBridgeNack& default_instance();

  void Swap(DssCltAddBridgeNack* other);

  // implements Message ----------------------------------------------

  DssCltAddBridgeNack* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 ClientId = 1;
  inline bool has_clientid() const;
  inline void clear_clientid();
  static const int kClientIdFieldNumber = 1;
  inline ::google::protobuf::uint32 clientid() const;
  inline void set_clientid(::google::protobuf::uint32 value);

  // optional .Dss.Event.DssNetAddr RcvAddr = 2;
  inline bool has_rcvaddr() const;
  inline void clear_rcvaddr();
  static const int kRcvAddrFieldNumber = 2;
  inline const ::Dss::Event::DssNetAddr& rcvaddr() const;
  inline ::Dss::Event::DssNetAddr* mutable_rcvaddr();
  inline ::Dss::Event::DssNetAddr* release_rcvaddr();
  inline void set_allocated_rcvaddr(::Dss::Event::DssNetAddr* rcvaddr);

  // optional uint32 StartServerHandle = 3;
  inline bool has_startserverhandle() const;
  inline void clear_startserverhandle();
  static const int kStartServerHandleFieldNumber = 3;
  inline ::google::protobuf::uint32 startserverhandle() const;
  inline void set_startserverhandle(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Dss.Event.DssCltAddBridgeNack)
 private:
  inline void set_has_clientid();
  inline void clear_has_clientid();
  inline void set_has_rcvaddr();
  inline void clear_has_rcvaddr();
  inline void set_has_startserverhandle();
  inline void clear_has_startserverhandle();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Dss::Event::DssNetAddr* rcvaddr_;
  ::google::protobuf::uint32 clientid_;
  ::google::protobuf::uint32 startserverhandle_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_dssevent_2eproto();
  friend void protobuf_AssignDesc_dssevent_2eproto();
  friend void protobuf_ShutdownFile_dssevent_2eproto();

  void InitAsDefaultInstance();
  static DssCltAddBridgeNack* default_instance_;
};
// -------------------------------------------------------------------

class CltDssRemoveBridgeCmd : public ::google::protobuf::Message {
 public:
  CltDssRemoveBridgeCmd();
  virtual ~CltDssRemoveBridgeCmd();

  CltDssRemoveBridgeCmd(const CltDssRemoveBridgeCmd& from);

  inline CltDssRemoveBridgeCmd& operator=(const CltDssRemoveBridgeCmd& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CltDssRemoveBridgeCmd& default_instance();

  void Swap(CltDssRemoveBridgeCmd* other);

  // implements Message ----------------------------------------------

  CltDssRemoveBridgeCmd* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 ClientId = 1;
  inline bool has_clientid() const;
  inline void clear_clientid();
  static const int kClientIdFieldNumber = 1;
  inline ::google::protobuf::uint32 clientid() const;
  inline void set_clientid(::google::protobuf::uint32 value);

  // optional uint32 BridgeHandle = 2;
  inline bool has_bridgehandle() const;
  inline void clear_bridgehandle();
  static const int kBridgeHandleFieldNumber = 2;
  inline ::google::protobuf::uint32 bridgehandle() const;
  inline void set_bridgehandle(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Dss.Event.CltDssRemoveBridgeCmd)
 private:
  inline void set_has_clientid();
  inline void clear_has_clientid();
  inline void set_has_bridgehandle();
  inline void clear_has_bridgehandle();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 clientid_;
  ::google::protobuf::uint32 bridgehandle_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_dssevent_2eproto();
  friend void protobuf_AssignDesc_dssevent_2eproto();
  friend void protobuf_ShutdownFile_dssevent_2eproto();

  void InitAsDefaultInstance();
  static CltDssRemoveBridgeCmd* default_instance_;
};
// -------------------------------------------------------------------

class CltDssSendToBridgeReq : public ::google::protobuf::Message {
 public:
  CltDssSendToBridgeReq();
  virtual ~CltDssSendToBridgeReq();

  CltDssSendToBridgeReq(const CltDssSendToBridgeReq& from);

  inline CltDssSendToBridgeReq& operator=(const CltDssSendToBridgeReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CltDssSendToBridgeReq& default_instance();

  void Swap(CltDssSendToBridgeReq* other);

  // implements Message ----------------------------------------------

  CltDssSendToBridgeReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 ClientId = 1;
  inline bool has_clientid() const;
  inline void clear_clientid();
  static const int kClientIdFieldNumber = 1;
  inline ::google::protobuf::uint32 clientid() const;
  inline void set_clientid(::google::protobuf::uint32 value);

  // optional uint32 BridgeHandle = 2;
  inline bool has_bridgehandle() const;
  inline void clear_bridgehandle();
  static const int kBridgeHandleFieldNumber = 2;
  inline ::google::protobuf::uint32 bridgehandle() const;
  inline void set_bridgehandle(::google::protobuf::uint32 value);

  // optional .Dss.Event.DssNetAddr RcvAddr = 3;
  inline bool has_rcvaddr() const;
  inline void clear_rcvaddr();
  static const int kRcvAddrFieldNumber = 3;
  inline const ::Dss::Event::DssNetAddr& rcvaddr() const;
  inline ::Dss::Event::DssNetAddr* mutable_rcvaddr();
  inline ::Dss::Event::DssNetAddr* release_rcvaddr();
  inline void set_allocated_rcvaddr(::Dss::Event::DssNetAddr* rcvaddr);

  // @@protoc_insertion_point(class_scope:Dss.Event.CltDssSendToBridgeReq)
 private:
  inline void set_has_clientid();
  inline void clear_has_clientid();
  inline void set_has_bridgehandle();
  inline void clear_has_bridgehandle();
  inline void set_has_rcvaddr();
  inline void clear_has_rcvaddr();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 clientid_;
  ::google::protobuf::uint32 bridgehandle_;
  ::Dss::Event::DssNetAddr* rcvaddr_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_dssevent_2eproto();
  friend void protobuf_AssignDesc_dssevent_2eproto();
  friend void protobuf_ShutdownFile_dssevent_2eproto();

  void InitAsDefaultInstance();
  static CltDssSendToBridgeReq* default_instance_;
};
// -------------------------------------------------------------------

class DssCltSendToBridgeAck : public ::google::protobuf::Message {
 public:
  DssCltSendToBridgeAck();
  virtual ~DssCltSendToBridgeAck();

  DssCltSendToBridgeAck(const DssCltSendToBridgeAck& from);

  inline DssCltSendToBridgeAck& operator=(const DssCltSendToBridgeAck& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DssCltSendToBridgeAck& default_instance();

  void Swap(DssCltSendToBridgeAck* other);

  // implements Message ----------------------------------------------

  DssCltSendToBridgeAck* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 ClientId = 1;
  inline bool has_clientid() const;
  inline void clear_clientid();
  static const int kClientIdFieldNumber = 1;
  inline ::google::protobuf::uint32 clientid() const;
  inline void set_clientid(::google::protobuf::uint32 value);

  // optional uint32 BridgeHandle = 2;
  inline bool has_bridgehandle() const;
  inline void clear_bridgehandle();
  static const int kBridgeHandleFieldNumber = 2;
  inline ::google::protobuf::uint32 bridgehandle() const;
  inline void set_bridgehandle(::google::protobuf::uint32 value);

  // optional .Dss.Event.DssNetAddr RcvAddr = 3;
  inline bool has_rcvaddr() const;
  inline void clear_rcvaddr();
  static const int kRcvAddrFieldNumber = 3;
  inline const ::Dss::Event::DssNetAddr& rcvaddr() const;
  inline ::Dss::Event::DssNetAddr* mutable_rcvaddr();
  inline ::Dss::Event::DssNetAddr* release_rcvaddr();
  inline void set_allocated_rcvaddr(::Dss::Event::DssNetAddr* rcvaddr);

  // @@protoc_insertion_point(class_scope:Dss.Event.DssCltSendToBridgeAck)
 private:
  inline void set_has_clientid();
  inline void clear_has_clientid();
  inline void set_has_bridgehandle();
  inline void clear_has_bridgehandle();
  inline void set_has_rcvaddr();
  inline void clear_has_rcvaddr();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 clientid_;
  ::google::protobuf::uint32 bridgehandle_;
  ::Dss::Event::DssNetAddr* rcvaddr_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_dssevent_2eproto();
  friend void protobuf_AssignDesc_dssevent_2eproto();
  friend void protobuf_ShutdownFile_dssevent_2eproto();

  void InitAsDefaultInstance();
  static DssCltSendToBridgeAck* default_instance_;
};
// -------------------------------------------------------------------

class DssCltSendToBridgeNack : public ::google::protobuf::Message {
 public:
  DssCltSendToBridgeNack();
  virtual ~DssCltSendToBridgeNack();

  DssCltSendToBridgeNack(const DssCltSendToBridgeNack& from);

  inline DssCltSendToBridgeNack& operator=(const DssCltSendToBridgeNack& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DssCltSendToBridgeNack& default_instance();

  void Swap(DssCltSendToBridgeNack* other);

  // implements Message ----------------------------------------------

  DssCltSendToBridgeNack* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 ClientId = 1;
  inline bool has_clientid() const;
  inline void clear_clientid();
  static const int kClientIdFieldNumber = 1;
  inline ::google::protobuf::uint32 clientid() const;
  inline void set_clientid(::google::protobuf::uint32 value);

  // optional uint32 BridgeHandle = 2;
  inline bool has_bridgehandle() const;
  inline void clear_bridgehandle();
  static const int kBridgeHandleFieldNumber = 2;
  inline ::google::protobuf::uint32 bridgehandle() const;
  inline void set_bridgehandle(::google::protobuf::uint32 value);

  // optional .Dss.Event.DssNetAddr RcvAddr = 3;
  inline bool has_rcvaddr() const;
  inline void clear_rcvaddr();
  static const int kRcvAddrFieldNumber = 3;
  inline const ::Dss::Event::DssNetAddr& rcvaddr() const;
  inline ::Dss::Event::DssNetAddr* mutable_rcvaddr();
  inline ::Dss::Event::DssNetAddr* release_rcvaddr();
  inline void set_allocated_rcvaddr(::Dss::Event::DssNetAddr* rcvaddr);

  // @@protoc_insertion_point(class_scope:Dss.Event.DssCltSendToBridgeNack)
 private:
  inline void set_has_clientid();
  inline void clear_has_clientid();
  inline void set_has_bridgehandle();
  inline void clear_has_bridgehandle();
  inline void set_has_rcvaddr();
  inline void clear_has_rcvaddr();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 clientid_;
  ::google::protobuf::uint32 bridgehandle_;
  ::Dss::Event::DssNetAddr* rcvaddr_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_dssevent_2eproto();
  friend void protobuf_AssignDesc_dssevent_2eproto();
  friend void protobuf_ShutdownFile_dssevent_2eproto();

  void InitAsDefaultInstance();
  static DssCltSendToBridgeNack* default_instance_;
};
// -------------------------------------------------------------------

class CltDssStopSendToBridgeCmd : public ::google::protobuf::Message {
 public:
  CltDssStopSendToBridgeCmd();
  virtual ~CltDssStopSendToBridgeCmd();

  CltDssStopSendToBridgeCmd(const CltDssStopSendToBridgeCmd& from);

  inline CltDssStopSendToBridgeCmd& operator=(const CltDssStopSendToBridgeCmd& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CltDssStopSendToBridgeCmd& default_instance();

  void Swap(CltDssStopSendToBridgeCmd* other);

  // implements Message ----------------------------------------------

  CltDssStopSendToBridgeCmd* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 ClientId = 1;
  inline bool has_clientid() const;
  inline void clear_clientid();
  static const int kClientIdFieldNumber = 1;
  inline ::google::protobuf::uint32 clientid() const;
  inline void set_clientid(::google::protobuf::uint32 value);

  // optional uint32 BridgeHandle = 2;
  inline bool has_bridgehandle() const;
  inline void clear_bridgehandle();
  static const int kBridgeHandleFieldNumber = 2;
  inline ::google::protobuf::uint32 bridgehandle() const;
  inline void set_bridgehandle(::google::protobuf::uint32 value);

  // optional .Dss.Event.DssNetAddr RcvAddr = 3;
  inline bool has_rcvaddr() const;
  inline void clear_rcvaddr();
  static const int kRcvAddrFieldNumber = 3;
  inline const ::Dss::Event::DssNetAddr& rcvaddr() const;
  inline ::Dss::Event::DssNetAddr* mutable_rcvaddr();
  inline ::Dss::Event::DssNetAddr* release_rcvaddr();
  inline void set_allocated_rcvaddr(::Dss::Event::DssNetAddr* rcvaddr);

  // @@protoc_insertion_point(class_scope:Dss.Event.CltDssStopSendToBridgeCmd)
 private:
  inline void set_has_clientid();
  inline void clear_has_clientid();
  inline void set_has_bridgehandle();
  inline void clear_has_bridgehandle();
  inline void set_has_rcvaddr();
  inline void clear_has_rcvaddr();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 clientid_;
  ::google::protobuf::uint32 bridgehandle_;
  ::Dss::Event::DssNetAddr* rcvaddr_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_dssevent_2eproto();
  friend void protobuf_AssignDesc_dssevent_2eproto();
  friend void protobuf_ShutdownFile_dssevent_2eproto();

  void InitAsDefaultInstance();
  static CltDssStopSendToBridgeCmd* default_instance_;
};
// -------------------------------------------------------------------

class CltDssReceiveFromBridgeReq : public ::google::protobuf::Message {
 public:
  CltDssReceiveFromBridgeReq();
  virtual ~CltDssReceiveFromBridgeReq();

  CltDssReceiveFromBridgeReq(const CltDssReceiveFromBridgeReq& from);

  inline CltDssReceiveFromBridgeReq& operator=(const CltDssReceiveFromBridgeReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CltDssReceiveFromBridgeReq& default_instance();

  void Swap(CltDssReceiveFromBridgeReq* other);

  // implements Message ----------------------------------------------

  CltDssReceiveFromBridgeReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 ClientId = 1;
  inline bool has_clientid() const;
  inline void clear_clientid();
  static const int kClientIdFieldNumber = 1;
  inline ::google::protobuf::uint32 clientid() const;
  inline void set_clientid(::google::protobuf::uint32 value);

  // optional uint32 BridgeHandle = 2;
  inline bool has_bridgehandle() const;
  inline void clear_bridgehandle();
  static const int kBridgeHandleFieldNumber = 2;
  inline ::google::protobuf::uint32 bridgehandle() const;
  inline void set_bridgehandle(::google::protobuf::uint32 value);

  // optional uint64 DstEpId = 3;
  inline bool has_dstepid() const;
  inline void clear_dstepid();
  static const int kDstEpIdFieldNumber = 3;
  inline ::google::protobuf::uint64 dstepid() const;
  inline void set_dstepid(::google::protobuf::uint64 value);

  // optional .Dss.Event.DssNetAddr DstAddr = 4;
  inline bool has_dstaddr() const;
  inline void clear_dstaddr();
  static const int kDstAddrFieldNumber = 4;
  inline const ::Dss::Event::DssNetAddr& dstaddr() const;
  inline ::Dss::Event::DssNetAddr* mutable_dstaddr();
  inline ::Dss::Event::DssNetAddr* release_dstaddr();
  inline void set_allocated_dstaddr(::Dss::Event::DssNetAddr* dstaddr);

  // @@protoc_insertion_point(class_scope:Dss.Event.CltDssReceiveFromBridgeReq)
 private:
  inline void set_has_clientid();
  inline void clear_has_clientid();
  inline void set_has_bridgehandle();
  inline void clear_has_bridgehandle();
  inline void set_has_dstepid();
  inline void clear_has_dstepid();
  inline void set_has_dstaddr();
  inline void clear_has_dstaddr();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 clientid_;
  ::google::protobuf::uint32 bridgehandle_;
  ::google::protobuf::uint64 dstepid_;
  ::Dss::Event::DssNetAddr* dstaddr_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_dssevent_2eproto();
  friend void protobuf_AssignDesc_dssevent_2eproto();
  friend void protobuf_ShutdownFile_dssevent_2eproto();

  void InitAsDefaultInstance();
  static CltDssReceiveFromBridgeReq* default_instance_;
};
// -------------------------------------------------------------------

class DssCltReceiveFromBridgeAck : public ::google::protobuf::Message {
 public:
  DssCltReceiveFromBridgeAck();
  virtual ~DssCltReceiveFromBridgeAck();

  DssCltReceiveFromBridgeAck(const DssCltReceiveFromBridgeAck& from);

  inline DssCltReceiveFromBridgeAck& operator=(const DssCltReceiveFromBridgeAck& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DssCltReceiveFromBridgeAck& default_instance();

  void Swap(DssCltReceiveFromBridgeAck* other);

  // implements Message ----------------------------------------------

  DssCltReceiveFromBridgeAck* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 ClientId = 1;
  inline bool has_clientid() const;
  inline void clear_clientid();
  static const int kClientIdFieldNumber = 1;
  inline ::google::protobuf::uint32 clientid() const;
  inline void set_clientid(::google::protobuf::uint32 value);

  // optional uint32 BridgeHandle = 2;
  inline bool has_bridgehandle() const;
  inline void clear_bridgehandle();
  static const int kBridgeHandleFieldNumber = 2;
  inline ::google::protobuf::uint32 bridgehandle() const;
  inline void set_bridgehandle(::google::protobuf::uint32 value);

  // optional uint64 DstEpId = 3;
  inline bool has_dstepid() const;
  inline void clear_dstepid();
  static const int kDstEpIdFieldNumber = 3;
  inline ::google::protobuf::uint64 dstepid() const;
  inline void set_dstepid(::google::protobuf::uint64 value);

  // optional .Dss.Event.DssNetAddr DstAddr = 4;
  inline bool has_dstaddr() const;
  inline void clear_dstaddr();
  static const int kDstAddrFieldNumber = 4;
  inline const ::Dss::Event::DssNetAddr& dstaddr() const;
  inline ::Dss::Event::DssNetAddr* mutable_dstaddr();
  inline ::Dss::Event::DssNetAddr* release_dstaddr();
  inline void set_allocated_dstaddr(::Dss::Event::DssNetAddr* dstaddr);

  // @@protoc_insertion_point(class_scope:Dss.Event.DssCltReceiveFromBridgeAck)
 private:
  inline void set_has_clientid();
  inline void clear_has_clientid();
  inline void set_has_bridgehandle();
  inline void clear_has_bridgehandle();
  inline void set_has_dstepid();
  inline void clear_has_dstepid();
  inline void set_has_dstaddr();
  inline void clear_has_dstaddr();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 clientid_;
  ::google::protobuf::uint32 bridgehandle_;
  ::google::protobuf::uint64 dstepid_;
  ::Dss::Event::DssNetAddr* dstaddr_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_dssevent_2eproto();
  friend void protobuf_AssignDesc_dssevent_2eproto();
  friend void protobuf_ShutdownFile_dssevent_2eproto();

  void InitAsDefaultInstance();
  static DssCltReceiveFromBridgeAck* default_instance_;
};
// -------------------------------------------------------------------

class DssCltReceiveFromBridgeNack : public ::google::protobuf::Message {
 public:
  DssCltReceiveFromBridgeNack();
  virtual ~DssCltReceiveFromBridgeNack();

  DssCltReceiveFromBridgeNack(const DssCltReceiveFromBridgeNack& from);

  inline DssCltReceiveFromBridgeNack& operator=(const DssCltReceiveFromBridgeNack& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DssCltReceiveFromBridgeNack& default_instance();

  void Swap(DssCltReceiveFromBridgeNack* other);

  // implements Message ----------------------------------------------

  DssCltReceiveFromBridgeNack* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 ClientId = 1;
  inline bool has_clientid() const;
  inline void clear_clientid();
  static const int kClientIdFieldNumber = 1;
  inline ::google::protobuf::uint32 clientid() const;
  inline void set_clientid(::google::protobuf::uint32 value);

  // optional uint32 BridgeHandle = 2;
  inline bool has_bridgehandle() const;
  inline void clear_bridgehandle();
  static const int kBridgeHandleFieldNumber = 2;
  inline ::google::protobuf::uint32 bridgehandle() const;
  inline void set_bridgehandle(::google::protobuf::uint32 value);

  // optional uint64 DstEpId = 3;
  inline bool has_dstepid() const;
  inline void clear_dstepid();
  static const int kDstEpIdFieldNumber = 3;
  inline ::google::protobuf::uint64 dstepid() const;
  inline void set_dstepid(::google::protobuf::uint64 value);

  // optional .Dss.Event.DssNetAddr DstAddr = 4;
  inline bool has_dstaddr() const;
  inline void clear_dstaddr();
  static const int kDstAddrFieldNumber = 4;
  inline const ::Dss::Event::DssNetAddr& dstaddr() const;
  inline ::Dss::Event::DssNetAddr* mutable_dstaddr();
  inline ::Dss::Event::DssNetAddr* release_dstaddr();
  inline void set_allocated_dstaddr(::Dss::Event::DssNetAddr* dstaddr);

  // @@protoc_insertion_point(class_scope:Dss.Event.DssCltReceiveFromBridgeNack)
 private:
  inline void set_has_clientid();
  inline void clear_has_clientid();
  inline void set_has_bridgehandle();
  inline void clear_has_bridgehandle();
  inline void set_has_dstepid();
  inline void clear_has_dstepid();
  inline void set_has_dstaddr();
  inline void clear_has_dstaddr();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 clientid_;
  ::google::protobuf::uint32 bridgehandle_;
  ::google::protobuf::uint64 dstepid_;
  ::Dss::Event::DssNetAddr* dstaddr_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_dssevent_2eproto();
  friend void protobuf_AssignDesc_dssevent_2eproto();
  friend void protobuf_ShutdownFile_dssevent_2eproto();

  void InitAsDefaultInstance();
  static DssCltReceiveFromBridgeNack* default_instance_;
};
// -------------------------------------------------------------------

class CltDssStopReceiveFromBridgeCmd : public ::google::protobuf::Message {
 public:
  CltDssStopReceiveFromBridgeCmd();
  virtual ~CltDssStopReceiveFromBridgeCmd();

  CltDssStopReceiveFromBridgeCmd(const CltDssStopReceiveFromBridgeCmd& from);

  inline CltDssStopReceiveFromBridgeCmd& operator=(const CltDssStopReceiveFromBridgeCmd& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CltDssStopReceiveFromBridgeCmd& default_instance();

  void Swap(CltDssStopReceiveFromBridgeCmd* other);

  // implements Message ----------------------------------------------

  CltDssStopReceiveFromBridgeCmd* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 ClientId = 1;
  inline bool has_clientid() const;
  inline void clear_clientid();
  static const int kClientIdFieldNumber = 1;
  inline ::google::protobuf::uint32 clientid() const;
  inline void set_clientid(::google::protobuf::uint32 value);

  // optional uint32 BridgeHandle = 2;
  inline bool has_bridgehandle() const;
  inline void clear_bridgehandle();
  static const int kBridgeHandleFieldNumber = 2;
  inline ::google::protobuf::uint32 bridgehandle() const;
  inline void set_bridgehandle(::google::protobuf::uint32 value);

  // optional .Dss.Event.DssNetAddr MapAddr = 3;
  inline bool has_mapaddr() const;
  inline void clear_mapaddr();
  static const int kMapAddrFieldNumber = 3;
  inline const ::Dss::Event::DssNetAddr& mapaddr() const;
  inline ::Dss::Event::DssNetAddr* mutable_mapaddr();
  inline ::Dss::Event::DssNetAddr* release_mapaddr();
  inline void set_allocated_mapaddr(::Dss::Event::DssNetAddr* mapaddr);

  // optional uint64 DstEpId = 4;
  inline bool has_dstepid() const;
  inline void clear_dstepid();
  static const int kDstEpIdFieldNumber = 4;
  inline ::google::protobuf::uint64 dstepid() const;
  inline void set_dstepid(::google::protobuf::uint64 value);

  // optional .Dss.Event.DssNetAddr DstAddr = 5;
  inline bool has_dstaddr() const;
  inline void clear_dstaddr();
  static const int kDstAddrFieldNumber = 5;
  inline const ::Dss::Event::DssNetAddr& dstaddr() const;
  inline ::Dss::Event::DssNetAddr* mutable_dstaddr();
  inline ::Dss::Event::DssNetAddr* release_dstaddr();
  inline void set_allocated_dstaddr(::Dss::Event::DssNetAddr* dstaddr);

  // @@protoc_insertion_point(class_scope:Dss.Event.CltDssStopReceiveFromBridgeCmd)
 private:
  inline void set_has_clientid();
  inline void clear_has_clientid();
  inline void set_has_bridgehandle();
  inline void clear_has_bridgehandle();
  inline void set_has_mapaddr();
  inline void clear_has_mapaddr();
  inline void set_has_dstepid();
  inline void clear_has_dstepid();
  inline void set_has_dstaddr();
  inline void clear_has_dstaddr();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 clientid_;
  ::google::protobuf::uint32 bridgehandle_;
  ::Dss::Event::DssNetAddr* mapaddr_;
  ::google::protobuf::uint64 dstepid_;
  ::Dss::Event::DssNetAddr* dstaddr_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_dssevent_2eproto();
  friend void protobuf_AssignDesc_dssevent_2eproto();
  friend void protobuf_ShutdownFile_dssevent_2eproto();

  void InitAsDefaultInstance();
  static CltDssStopReceiveFromBridgeCmd* default_instance_;
};
// -------------------------------------------------------------------

class CltDssAddSwitchReq : public ::google::protobuf::Message {
 public:
  CltDssAddSwitchReq();
  virtual ~CltDssAddSwitchReq();

  CltDssAddSwitchReq(const CltDssAddSwitchReq& from);

  inline CltDssAddSwitchReq& operator=(const CltDssAddSwitchReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CltDssAddSwitchReq& default_instance();

  void Swap(CltDssAddSwitchReq* other);

  // implements Message ----------------------------------------------

  CltDssAddSwitchReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 ClientId = 1;
  inline bool has_clientid() const;
  inline void clear_clientid();
  static const int kClientIdFieldNumber = 1;
  inline ::google::protobuf::uint32 clientid() const;
  inline void set_clientid(::google::protobuf::uint32 value);

  // optional uint64 DstEpId = 2;
  inline bool has_dstepid() const;
  inline void clear_dstepid();
  static const int kDstEpIdFieldNumber = 2;
  inline ::google::protobuf::uint64 dstepid() const;
  inline void set_dstepid(::google::protobuf::uint64 value);

  // optional .Dss.Event.DssNetAddr DstAddr = 3;
  inline bool has_dstaddr() const;
  inline void clear_dstaddr();
  static const int kDstAddrFieldNumber = 3;
  inline const ::Dss::Event::DssNetAddr& dstaddr() const;
  inline ::Dss::Event::DssNetAddr* mutable_dstaddr();
  inline ::Dss::Event::DssNetAddr* release_dstaddr();
  inline void set_allocated_dstaddr(::Dss::Event::DssNetAddr* dstaddr);

  // optional .Dss.Event.DssNetAddr RcvAddr = 4;
  inline bool has_rcvaddr() const;
  inline void clear_rcvaddr();
  static const int kRcvAddrFieldNumber = 4;
  inline const ::Dss::Event::DssNetAddr& rcvaddr() const;
  inline ::Dss::Event::DssNetAddr* mutable_rcvaddr();
  inline ::Dss::Event::DssNetAddr* release_rcvaddr();
  inline void set_allocated_rcvaddr(::Dss::Event::DssNetAddr* rcvaddr);

  // optional .Dss.Event.DssNetAddr MapAddr = 5;
  inline bool has_mapaddr() const;
  inline void clear_mapaddr();
  static const int kMapAddrFieldNumber = 5;
  inline const ::Dss::Event::DssNetAddr& mapaddr() const;
  inline ::Dss::Event::DssNetAddr* mutable_mapaddr();
  inline ::Dss::Event::DssNetAddr* release_mapaddr();
  inline void set_allocated_mapaddr(::Dss::Event::DssNetAddr* mapaddr);

  // optional .Dss.Event.SecretKey DecKey = 6;
  inline bool has_deckey() const;
  inline void clear_deckey();
  static const int kDecKeyFieldNumber = 6;
  inline const ::Dss::Event::SecretKey& deckey() const;
  inline ::Dss::Event::SecretKey* mutable_deckey();
  inline ::Dss::Event::SecretKey* release_deckey();
  inline void set_allocated_deckey(::Dss::Event::SecretKey* deckey);

  // optional .Dss.Event.SecretKey EncKey = 7;
  inline bool has_enckey() const;
  inline void clear_enckey();
  static const int kEncKeyFieldNumber = 7;
  inline const ::Dss::Event::SecretKey& enckey() const;
  inline ::Dss::Event::SecretKey* mutable_enckey();
  inline ::Dss::Event::SecretKey* release_enckey();
  inline void set_allocated_enckey(::Dss::Event::SecretKey* enckey);

  // optional bool Uniform = 8;
  inline bool has_uniform() const;
  inline void clear_uniform();
  static const int kUniformFieldNumber = 8;
  inline bool uniform() const;
  inline void set_uniform(bool value);

  // optional .Dss.Event.DsType dstype = 9;
  inline bool has_dstype() const;
  inline void clear_dstype();
  static const int kDstypeFieldNumber = 9;
  inline ::Dss::Event::DsType dstype() const;
  inline void set_dstype(::Dss::Event::DsType value);

  // @@protoc_insertion_point(class_scope:Dss.Event.CltDssAddSwitchReq)
 private:
  inline void set_has_clientid();
  inline void clear_has_clientid();
  inline void set_has_dstepid();
  inline void clear_has_dstepid();
  inline void set_has_dstaddr();
  inline void clear_has_dstaddr();
  inline void set_has_rcvaddr();
  inline void clear_has_rcvaddr();
  inline void set_has_mapaddr();
  inline void clear_has_mapaddr();
  inline void set_has_deckey();
  inline void clear_has_deckey();
  inline void set_has_enckey();
  inline void clear_has_enckey();
  inline void set_has_uniform();
  inline void clear_has_uniform();
  inline void set_has_dstype();
  inline void clear_has_dstype();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 dstepid_;
  ::Dss::Event::DssNetAddr* dstaddr_;
  ::Dss::Event::DssNetAddr* rcvaddr_;
  ::google::protobuf::uint32 clientid_;
  bool uniform_;
  ::Dss::Event::DssNetAddr* mapaddr_;
  ::Dss::Event::SecretKey* deckey_;
  ::Dss::Event::SecretKey* enckey_;
  int dstype_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  friend void  protobuf_AddDesc_dssevent_2eproto();
  friend void protobuf_AssignDesc_dssevent_2eproto();
  friend void protobuf_ShutdownFile_dssevent_2eproto();

  void InitAsDefaultInstance();
  static CltDssAddSwitchReq* default_instance_;
};
// -------------------------------------------------------------------

class DssCltAddSwitchAck : public ::google::protobuf::Message {
 public:
  DssCltAddSwitchAck();
  virtual ~DssCltAddSwitchAck();

  DssCltAddSwitchAck(const DssCltAddSwitchAck& from);

  inline DssCltAddSwitchAck& operator=(const DssCltAddSwitchAck& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DssCltAddSwitchAck& default_instance();

  void Swap(DssCltAddSwitchAck* other);

  // implements Message ----------------------------------------------

  DssCltAddSwitchAck* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 ClientId = 1;
  inline bool has_clientid() const;
  inline void clear_clientid();
  static const int kClientIdFieldNumber = 1;
  inline ::google::protobuf::uint32 clientid() const;
  inline void set_clientid(::google::protobuf::uint32 value);

  // optional uint64 DstEpId = 2;
  inline bool has_dstepid() const;
  inline void clear_dstepid();
  static const int kDstEpIdFieldNumber = 2;
  inline ::google::protobuf::uint64 dstepid() const;
  inline void set_dstepid(::google::protobuf::uint64 value);

  // optional .Dss.Event.DssNetAddr DstAddr = 3;
  inline bool has_dstaddr() const;
  inline void clear_dstaddr();
  static const int kDstAddrFieldNumber = 3;
  inline const ::Dss::Event::DssNetAddr& dstaddr() const;
  inline ::Dss::Event::DssNetAddr* mutable_dstaddr();
  inline ::Dss::Event::DssNetAddr* release_dstaddr();
  inline void set_allocated_dstaddr(::Dss::Event::DssNetAddr* dstaddr);

  // optional .Dss.Event.DssNetAddr RcvAddr = 4;
  inline bool has_rcvaddr() const;
  inline void clear_rcvaddr();
  static const int kRcvAddrFieldNumber = 4;
  inline const ::Dss::Event::DssNetAddr& rcvaddr() const;
  inline ::Dss::Event::DssNetAddr* mutable_rcvaddr();
  inline ::Dss::Event::DssNetAddr* release_rcvaddr();
  inline void set_allocated_rcvaddr(::Dss::Event::DssNetAddr* rcvaddr);

  // optional .Dss.Event.DsType dstype = 5;
  inline bool has_dstype() const;
  inline void clear_dstype();
  static const int kDstypeFieldNumber = 5;
  inline ::Dss::Event::DsType dstype() const;
  inline void set_dstype(::Dss::Event::DsType value);

  // @@protoc_insertion_point(class_scope:Dss.Event.DssCltAddSwitchAck)
 private:
  inline void set_has_clientid();
  inline void clear_has_clientid();
  inline void set_has_dstepid();
  inline void clear_has_dstepid();
  inline void set_has_dstaddr();
  inline void clear_has_dstaddr();
  inline void set_has_rcvaddr();
  inline void clear_has_rcvaddr();
  inline void set_has_dstype();
  inline void clear_has_dstype();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 dstepid_;
  ::Dss::Event::DssNetAddr* dstaddr_;
  ::google::protobuf::uint32 clientid_;
  int dstype_;
  ::Dss::Event::DssNetAddr* rcvaddr_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_dssevent_2eproto();
  friend void protobuf_AssignDesc_dssevent_2eproto();
  friend void protobuf_ShutdownFile_dssevent_2eproto();

  void InitAsDefaultInstance();
  static DssCltAddSwitchAck* default_instance_;
};
// -------------------------------------------------------------------

class DssCltAddSwitchNack : public ::google::protobuf::Message {
 public:
  DssCltAddSwitchNack();
  virtual ~DssCltAddSwitchNack();

  DssCltAddSwitchNack(const DssCltAddSwitchNack& from);

  inline DssCltAddSwitchNack& operator=(const DssCltAddSwitchNack& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DssCltAddSwitchNack& default_instance();

  void Swap(DssCltAddSwitchNack* other);

  // implements Message ----------------------------------------------

  DssCltAddSwitchNack* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 ClientId = 1;
  inline bool has_clientid() const;
  inline void clear_clientid();
  static const int kClientIdFieldNumber = 1;
  inline ::google::protobuf::uint32 clientid() const;
  inline void set_clientid(::google::protobuf::uint32 value);

  // optional uint64 DstEpId = 2;
  inline bool has_dstepid() const;
  inline void clear_dstepid();
  static const int kDstEpIdFieldNumber = 2;
  inline ::google::protobuf::uint64 dstepid() const;
  inline void set_dstepid(::google::protobuf::uint64 value);

  // optional .Dss.Event.DssNetAddr DstAddr = 3;
  inline bool has_dstaddr() const;
  inline void clear_dstaddr();
  static const int kDstAddrFieldNumber = 3;
  inline const ::Dss::Event::DssNetAddr& dstaddr() const;
  inline ::Dss::Event::DssNetAddr* mutable_dstaddr();
  inline ::Dss::Event::DssNetAddr* release_dstaddr();
  inline void set_allocated_dstaddr(::Dss::Event::DssNetAddr* dstaddr);

  // optional .Dss.Event.DssNetAddr RcvAddr = 4;
  inline bool has_rcvaddr() const;
  inline void clear_rcvaddr();
  static const int kRcvAddrFieldNumber = 4;
  inline const ::Dss::Event::DssNetAddr& rcvaddr() const;
  inline ::Dss::Event::DssNetAddr* mutable_rcvaddr();
  inline ::Dss::Event::DssNetAddr* release_rcvaddr();
  inline void set_allocated_rcvaddr(::Dss::Event::DssNetAddr* rcvaddr);

  // optional .Dss.Event.DsType dstype = 5;
  inline bool has_dstype() const;
  inline void clear_dstype();
  static const int kDstypeFieldNumber = 5;
  inline ::Dss::Event::DsType dstype() const;
  inline void set_dstype(::Dss::Event::DsType value);

  // @@protoc_insertion_point(class_scope:Dss.Event.DssCltAddSwitchNack)
 private:
  inline void set_has_clientid();
  inline void clear_has_clientid();
  inline void set_has_dstepid();
  inline void clear_has_dstepid();
  inline void set_has_dstaddr();
  inline void clear_has_dstaddr();
  inline void set_has_rcvaddr();
  inline void clear_has_rcvaddr();
  inline void set_has_dstype();
  inline void clear_has_dstype();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 dstepid_;
  ::Dss::Event::DssNetAddr* dstaddr_;
  ::google::protobuf::uint32 clientid_;
  int dstype_;
  ::Dss::Event::DssNetAddr* rcvaddr_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_dssevent_2eproto();
  friend void protobuf_AssignDesc_dssevent_2eproto();
  friend void protobuf_ShutdownFile_dssevent_2eproto();

  void InitAsDefaultInstance();
  static DssCltAddSwitchNack* default_instance_;
};
// -------------------------------------------------------------------

class CltDssAddM2OneSwitchReq : public ::google::protobuf::Message {
 public:
  CltDssAddM2OneSwitchReq();
  virtual ~CltDssAddM2OneSwitchReq();

  CltDssAddM2OneSwitchReq(const CltDssAddM2OneSwitchReq& from);

  inline CltDssAddM2OneSwitchReq& operator=(const CltDssAddM2OneSwitchReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CltDssAddM2OneSwitchReq& default_instance();

  void Swap(CltDssAddM2OneSwitchReq* other);

  // implements Message ----------------------------------------------

  CltDssAddM2OneSwitchReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 ClientId = 1;
  inline bool has_clientid() const;
  inline void clear_clientid();
  static const int kClientIdFieldNumber = 1;
  inline ::google::protobuf::uint32 clientid() const;
  inline void set_clientid(::google::protobuf::uint32 value);

  // optional uint64 DstEpId = 2;
  inline bool has_dstepid() const;
  inline void clear_dstepid();
  static const int kDstEpIdFieldNumber = 2;
  inline ::google::protobuf::uint64 dstepid() const;
  inline void set_dstepid(::google::protobuf::uint64 value);

  // optional .Dss.Event.DssNetAddr DstAddr = 3;
  inline bool has_dstaddr() const;
  inline void clear_dstaddr();
  static const int kDstAddrFieldNumber = 3;
  inline const ::Dss::Event::DssNetAddr& dstaddr() const;
  inline ::Dss::Event::DssNetAddr* mutable_dstaddr();
  inline ::Dss::Event::DssNetAddr* release_dstaddr();
  inline void set_allocated_dstaddr(::Dss::Event::DssNetAddr* dstaddr);

  // optional .Dss.Event.DssNetAddr RcvAddr = 4;
  inline bool has_rcvaddr() const;
  inline void clear_rcvaddr();
  static const int kRcvAddrFieldNumber = 4;
  inline const ::Dss::Event::DssNetAddr& rcvaddr() const;
  inline ::Dss::Event::DssNetAddr* mutable_rcvaddr();
  inline ::Dss::Event::DssNetAddr* release_rcvaddr();
  inline void set_allocated_rcvaddr(::Dss::Event::DssNetAddr* rcvaddr);

  // optional .Dss.Event.DssNetAddr MapAddr = 5;
  inline bool has_mapaddr() const;
  inline void clear_mapaddr();
  static const int kMapAddrFieldNumber = 5;
  inline const ::Dss::Event::DssNetAddr& mapaddr() const;
  inline ::Dss::Event::DssNetAddr* mutable_mapaddr();
  inline ::Dss::Event::DssNetAddr* release_mapaddr();
  inline void set_allocated_mapaddr(::Dss::Event::DssNetAddr* mapaddr);

  // optional .Dss.Event.SecretKey DecKey = 6;
  inline bool has_deckey() const;
  inline void clear_deckey();
  static const int kDecKeyFieldNumber = 6;
  inline const ::Dss::Event::SecretKey& deckey() const;
  inline ::Dss::Event::SecretKey* mutable_deckey();
  inline ::Dss::Event::SecretKey* release_deckey();
  inline void set_allocated_deckey(::Dss::Event::SecretKey* deckey);

  // optional .Dss.Event.SecretKey EncKey = 7;
  inline bool has_enckey() const;
  inline void clear_enckey();
  static const int kEncKeyFieldNumber = 7;
  inline const ::Dss::Event::SecretKey& enckey() const;
  inline ::Dss::Event::SecretKey* mutable_enckey();
  inline ::Dss::Event::SecretKey* release_enckey();
  inline void set_allocated_enckey(::Dss::Event::SecretKey* enckey);

  // optional bool Uniform = 8;
  inline bool has_uniform() const;
  inline void clear_uniform();
  static const int kUniformFieldNumber = 8;
  inline bool uniform() const;
  inline void set_uniform(bool value);

  // optional .Dss.Event.DsType dstype = 9;
  inline bool has_dstype() const;
  inline void clear_dstype();
  static const int kDstypeFieldNumber = 9;
  inline ::Dss::Event::DsType dstype() const;
  inline void set_dstype(::Dss::Event::DsType value);

  // @@protoc_insertion_point(class_scope:Dss.Event.CltDssAddM2OneSwitchReq)
 private:
  inline void set_has_clientid();
  inline void clear_has_clientid();
  inline void set_has_dstepid();
  inline void clear_has_dstepid();
  inline void set_has_dstaddr();
  inline void clear_has_dstaddr();
  inline void set_has_rcvaddr();
  inline void clear_has_rcvaddr();
  inline void set_has_mapaddr();
  inline void clear_has_mapaddr();
  inline void set_has_deckey();
  inline void clear_has_deckey();
  inline void set_has_enckey();
  inline void clear_has_enckey();
  inline void set_has_uniform();
  inline void clear_has_uniform();
  inline void set_has_dstype();
  inline void clear_has_dstype();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 dstepid_;
  ::Dss::Event::DssNetAddr* dstaddr_;
  ::Dss::Event::DssNetAddr* rcvaddr_;
  ::google::protobuf::uint32 clientid_;
  bool uniform_;
  ::Dss::Event::DssNetAddr* mapaddr_;
  ::Dss::Event::SecretKey* deckey_;
  ::Dss::Event::SecretKey* enckey_;
  int dstype_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  friend void  protobuf_AddDesc_dssevent_2eproto();
  friend void protobuf_AssignDesc_dssevent_2eproto();
  friend void protobuf_ShutdownFile_dssevent_2eproto();

  void InitAsDefaultInstance();
  static CltDssAddM2OneSwitchReq* default_instance_;
};
// -------------------------------------------------------------------

class DssCltAddM2OneSwitchAck : public ::google::protobuf::Message {
 public:
  DssCltAddM2OneSwitchAck();
  virtual ~DssCltAddM2OneSwitchAck();

  DssCltAddM2OneSwitchAck(const DssCltAddM2OneSwitchAck& from);

  inline DssCltAddM2OneSwitchAck& operator=(const DssCltAddM2OneSwitchAck& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DssCltAddM2OneSwitchAck& default_instance();

  void Swap(DssCltAddM2OneSwitchAck* other);

  // implements Message ----------------------------------------------

  DssCltAddM2OneSwitchAck* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 ClientId = 1;
  inline bool has_clientid() const;
  inline void clear_clientid();
  static const int kClientIdFieldNumber = 1;
  inline ::google::protobuf::uint32 clientid() const;
  inline void set_clientid(::google::protobuf::uint32 value);

  // optional uint64 DstEpId = 2;
  inline bool has_dstepid() const;
  inline void clear_dstepid();
  static const int kDstEpIdFieldNumber = 2;
  inline ::google::protobuf::uint64 dstepid() const;
  inline void set_dstepid(::google::protobuf::uint64 value);

  // optional .Dss.Event.DssNetAddr DstAddr = 3;
  inline bool has_dstaddr() const;
  inline void clear_dstaddr();
  static const int kDstAddrFieldNumber = 3;
  inline const ::Dss::Event::DssNetAddr& dstaddr() const;
  inline ::Dss::Event::DssNetAddr* mutable_dstaddr();
  inline ::Dss::Event::DssNetAddr* release_dstaddr();
  inline void set_allocated_dstaddr(::Dss::Event::DssNetAddr* dstaddr);

  // optional .Dss.Event.DssNetAddr RcvAddr = 4;
  inline bool has_rcvaddr() const;
  inline void clear_rcvaddr();
  static const int kRcvAddrFieldNumber = 4;
  inline const ::Dss::Event::DssNetAddr& rcvaddr() const;
  inline ::Dss::Event::DssNetAddr* mutable_rcvaddr();
  inline ::Dss::Event::DssNetAddr* release_rcvaddr();
  inline void set_allocated_rcvaddr(::Dss::Event::DssNetAddr* rcvaddr);

  // optional .Dss.Event.DsType dstype = 5;
  inline bool has_dstype() const;
  inline void clear_dstype();
  static const int kDstypeFieldNumber = 5;
  inline ::Dss::Event::DsType dstype() const;
  inline void set_dstype(::Dss::Event::DsType value);

  // @@protoc_insertion_point(class_scope:Dss.Event.DssCltAddM2OneSwitchAck)
 private:
  inline void set_has_clientid();
  inline void clear_has_clientid();
  inline void set_has_dstepid();
  inline void clear_has_dstepid();
  inline void set_has_dstaddr();
  inline void clear_has_dstaddr();
  inline void set_has_rcvaddr();
  inline void clear_has_rcvaddr();
  inline void set_has_dstype();
  inline void clear_has_dstype();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 dstepid_;
  ::Dss::Event::DssNetAddr* dstaddr_;
  ::google::protobuf::uint32 clientid_;
  int dstype_;
  ::Dss::Event::DssNetAddr* rcvaddr_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_dssevent_2eproto();
  friend void protobuf_AssignDesc_dssevent_2eproto();
  friend void protobuf_ShutdownFile_dssevent_2eproto();

  void InitAsDefaultInstance();
  static DssCltAddM2OneSwitchAck* default_instance_;
};
// -------------------------------------------------------------------

class DssCltAddM2OneSwitchNack : public ::google::protobuf::Message {
 public:
  DssCltAddM2OneSwitchNack();
  virtual ~DssCltAddM2OneSwitchNack();

  DssCltAddM2OneSwitchNack(const DssCltAddM2OneSwitchNack& from);

  inline DssCltAddM2OneSwitchNack& operator=(const DssCltAddM2OneSwitchNack& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DssCltAddM2OneSwitchNack& default_instance();

  void Swap(DssCltAddM2OneSwitchNack* other);

  // implements Message ----------------------------------------------

  DssCltAddM2OneSwitchNack* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 ClientId = 1;
  inline bool has_clientid() const;
  inline void clear_clientid();
  static const int kClientIdFieldNumber = 1;
  inline ::google::protobuf::uint32 clientid() const;
  inline void set_clientid(::google::protobuf::uint32 value);

  // optional uint64 DstEpId = 2;
  inline bool has_dstepid() const;
  inline void clear_dstepid();
  static const int kDstEpIdFieldNumber = 2;
  inline ::google::protobuf::uint64 dstepid() const;
  inline void set_dstepid(::google::protobuf::uint64 value);

  // optional .Dss.Event.DssNetAddr DstAddr = 3;
  inline bool has_dstaddr() const;
  inline void clear_dstaddr();
  static const int kDstAddrFieldNumber = 3;
  inline const ::Dss::Event::DssNetAddr& dstaddr() const;
  inline ::Dss::Event::DssNetAddr* mutable_dstaddr();
  inline ::Dss::Event::DssNetAddr* release_dstaddr();
  inline void set_allocated_dstaddr(::Dss::Event::DssNetAddr* dstaddr);

  // optional .Dss.Event.DssNetAddr RcvAddr = 4;
  inline bool has_rcvaddr() const;
  inline void clear_rcvaddr();
  static const int kRcvAddrFieldNumber = 4;
  inline const ::Dss::Event::DssNetAddr& rcvaddr() const;
  inline ::Dss::Event::DssNetAddr* mutable_rcvaddr();
  inline ::Dss::Event::DssNetAddr* release_rcvaddr();
  inline void set_allocated_rcvaddr(::Dss::Event::DssNetAddr* rcvaddr);

  // optional .Dss.Event.DsType dstype = 5;
  inline bool has_dstype() const;
  inline void clear_dstype();
  static const int kDstypeFieldNumber = 5;
  inline ::Dss::Event::DsType dstype() const;
  inline void set_dstype(::Dss::Event::DsType value);

  // @@protoc_insertion_point(class_scope:Dss.Event.DssCltAddM2OneSwitchNack)
 private:
  inline void set_has_clientid();
  inline void clear_has_clientid();
  inline void set_has_dstepid();
  inline void clear_has_dstepid();
  inline void set_has_dstaddr();
  inline void clear_has_dstaddr();
  inline void set_has_rcvaddr();
  inline void clear_has_rcvaddr();
  inline void set_has_dstype();
  inline void clear_has_dstype();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 dstepid_;
  ::Dss::Event::DssNetAddr* dstaddr_;
  ::google::protobuf::uint32 clientid_;
  int dstype_;
  ::Dss::Event::DssNetAddr* rcvaddr_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_dssevent_2eproto();
  friend void protobuf_AssignDesc_dssevent_2eproto();
  friend void protobuf_ShutdownFile_dssevent_2eproto();

  void InitAsDefaultInstance();
  static DssCltAddM2OneSwitchNack* default_instance_;
};
// -------------------------------------------------------------------

class CltDssAddSrcSwitchReq : public ::google::protobuf::Message {
 public:
  CltDssAddSrcSwitchReq();
  virtual ~CltDssAddSrcSwitchReq();

  CltDssAddSrcSwitchReq(const CltDssAddSrcSwitchReq& from);

  inline CltDssAddSrcSwitchReq& operator=(const CltDssAddSrcSwitchReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CltDssAddSrcSwitchReq& default_instance();

  void Swap(CltDssAddSrcSwitchReq* other);

  // implements Message ----------------------------------------------

  CltDssAddSrcSwitchReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 ClientId = 1;
  inline bool has_clientid() const;
  inline void clear_clientid();
  static const int kClientIdFieldNumber = 1;
  inline ::google::protobuf::uint32 clientid() const;
  inline void set_clientid(::google::protobuf::uint32 value);

  // optional uint64 SrcEpId = 2;
  inline bool has_srcepid() const;
  inline void clear_srcepid();
  static const int kSrcEpIdFieldNumber = 2;
  inline ::google::protobuf::uint64 srcepid() const;
  inline void set_srcepid(::google::protobuf::uint64 value);

  // optional .Dss.Event.DssNetAddr SrcAddr = 3;
  inline bool has_srcaddr() const;
  inline void clear_srcaddr();
  static const int kSrcAddrFieldNumber = 3;
  inline const ::Dss::Event::DssNetAddr& srcaddr() const;
  inline ::Dss::Event::DssNetAddr* mutable_srcaddr();
  inline ::Dss::Event::DssNetAddr* release_srcaddr();
  inline void set_allocated_srcaddr(::Dss::Event::DssNetAddr* srcaddr);

  // optional uint64 DstEpId = 4;
  inline bool has_dstepid() const;
  inline void clear_dstepid();
  static const int kDstEpIdFieldNumber = 4;
  inline ::google::protobuf::uint64 dstepid() const;
  inline void set_dstepid(::google::protobuf::uint64 value);

  // optional .Dss.Event.DssNetAddr DstAddr = 5;
  inline bool has_dstaddr() const;
  inline void clear_dstaddr();
  static const int kDstAddrFieldNumber = 5;
  inline const ::Dss::Event::DssNetAddr& dstaddr() const;
  inline ::Dss::Event::DssNetAddr* mutable_dstaddr();
  inline ::Dss::Event::DssNetAddr* release_dstaddr();
  inline void set_allocated_dstaddr(::Dss::Event::DssNetAddr* dstaddr);

  // optional .Dss.Event.DssNetAddr RcvAddr = 6;
  inline bool has_rcvaddr() const;
  inline void clear_rcvaddr();
  static const int kRcvAddrFieldNumber = 6;
  inline const ::Dss::Event::DssNetAddr& rcvaddr() const;
  inline ::Dss::Event::DssNetAddr* mutable_rcvaddr();
  inline ::Dss::Event::DssNetAddr* release_rcvaddr();
  inline void set_allocated_rcvaddr(::Dss::Event::DssNetAddr* rcvaddr);

  // optional .Dss.Event.DssNetAddr MapAddr = 7;
  inline bool has_mapaddr() const;
  inline void clear_mapaddr();
  static const int kMapAddrFieldNumber = 7;
  inline const ::Dss::Event::DssNetAddr& mapaddr() const;
  inline ::Dss::Event::DssNetAddr* mutable_mapaddr();
  inline ::Dss::Event::DssNetAddr* release_mapaddr();
  inline void set_allocated_mapaddr(::Dss::Event::DssNetAddr* mapaddr);

  // optional .Dss.Event.SecretKey DecKey = 8;
  inline bool has_deckey() const;
  inline void clear_deckey();
  static const int kDecKeyFieldNumber = 8;
  inline const ::Dss::Event::SecretKey& deckey() const;
  inline ::Dss::Event::SecretKey* mutable_deckey();
  inline ::Dss::Event::SecretKey* release_deckey();
  inline void set_allocated_deckey(::Dss::Event::SecretKey* deckey);

  // optional .Dss.Event.SecretKey EncKey = 9;
  inline bool has_enckey() const;
  inline void clear_enckey();
  static const int kEncKeyFieldNumber = 9;
  inline const ::Dss::Event::SecretKey& enckey() const;
  inline ::Dss::Event::SecretKey* mutable_enckey();
  inline ::Dss::Event::SecretKey* release_enckey();
  inline void set_allocated_enckey(::Dss::Event::SecretKey* enckey);

  // optional bool Uniform = 10;
  inline bool has_uniform() const;
  inline void clear_uniform();
  static const int kUniformFieldNumber = 10;
  inline bool uniform() const;
  inline void set_uniform(bool value);

  // optional .Dss.Event.DsType dstype = 11;
  inline bool has_dstype() const;
  inline void clear_dstype();
  static const int kDstypeFieldNumber = 11;
  inline ::Dss::Event::DsType dstype() const;
  inline void set_dstype(::Dss::Event::DsType value);

  // @@protoc_insertion_point(class_scope:Dss.Event.CltDssAddSrcSwitchReq)
 private:
  inline void set_has_clientid();
  inline void clear_has_clientid();
  inline void set_has_srcepid();
  inline void clear_has_srcepid();
  inline void set_has_srcaddr();
  inline void clear_has_srcaddr();
  inline void set_has_dstepid();
  inline void clear_has_dstepid();
  inline void set_has_dstaddr();
  inline void clear_has_dstaddr();
  inline void set_has_rcvaddr();
  inline void clear_has_rcvaddr();
  inline void set_has_mapaddr();
  inline void clear_has_mapaddr();
  inline void set_has_deckey();
  inline void clear_has_deckey();
  inline void set_has_enckey();
  inline void clear_has_enckey();
  inline void set_has_uniform();
  inline void clear_has_uniform();
  inline void set_has_dstype();
  inline void clear_has_dstype();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 srcepid_;
  ::Dss::Event::DssNetAddr* srcaddr_;
  ::google::protobuf::uint64 dstepid_;
  ::Dss::Event::DssNetAddr* dstaddr_;
  ::google::protobuf::uint32 clientid_;
  bool uniform_;
  ::Dss::Event::DssNetAddr* rcvaddr_;
  ::Dss::Event::DssNetAddr* mapaddr_;
  ::Dss::Event::SecretKey* deckey_;
  ::Dss::Event::SecretKey* enckey_;
  int dstype_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(11 + 31) / 32];

  friend void  protobuf_AddDesc_dssevent_2eproto();
  friend void protobuf_AssignDesc_dssevent_2eproto();
  friend void protobuf_ShutdownFile_dssevent_2eproto();

  void InitAsDefaultInstance();
  static CltDssAddSrcSwitchReq* default_instance_;
};
// -------------------------------------------------------------------

class DssCltAddSrcSwitchAck : public ::google::protobuf::Message {
 public:
  DssCltAddSrcSwitchAck();
  virtual ~DssCltAddSrcSwitchAck();

  DssCltAddSrcSwitchAck(const DssCltAddSrcSwitchAck& from);

  inline DssCltAddSrcSwitchAck& operator=(const DssCltAddSrcSwitchAck& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DssCltAddSrcSwitchAck& default_instance();

  void Swap(DssCltAddSrcSwitchAck* other);

  // implements Message ----------------------------------------------

  DssCltAddSrcSwitchAck* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 ClientId = 1;
  inline bool has_clientid() const;
  inline void clear_clientid();
  static const int kClientIdFieldNumber = 1;
  inline ::google::protobuf::uint32 clientid() const;
  inline void set_clientid(::google::protobuf::uint32 value);

  // optional uint64 SrcEpId = 2;
  inline bool has_srcepid() const;
  inline void clear_srcepid();
  static const int kSrcEpIdFieldNumber = 2;
  inline ::google::protobuf::uint64 srcepid() const;
  inline void set_srcepid(::google::protobuf::uint64 value);

  // optional .Dss.Event.DssNetAddr SrcAddr = 3;
  inline bool has_srcaddr() const;
  inline void clear_srcaddr();
  static const int kSrcAddrFieldNumber = 3;
  inline const ::Dss::Event::DssNetAddr& srcaddr() const;
  inline ::Dss::Event::DssNetAddr* mutable_srcaddr();
  inline ::Dss::Event::DssNetAddr* release_srcaddr();
  inline void set_allocated_srcaddr(::Dss::Event::DssNetAddr* srcaddr);

  // optional uint64 DstEpId = 4;
  inline bool has_dstepid() const;
  inline void clear_dstepid();
  static const int kDstEpIdFieldNumber = 4;
  inline ::google::protobuf::uint64 dstepid() const;
  inline void set_dstepid(::google::protobuf::uint64 value);

  // optional .Dss.Event.DssNetAddr DstAddr = 5;
  inline bool has_dstaddr() const;
  inline void clear_dstaddr();
  static const int kDstAddrFieldNumber = 5;
  inline const ::Dss::Event::DssNetAddr& dstaddr() const;
  inline ::Dss::Event::DssNetAddr* mutable_dstaddr();
  inline ::Dss::Event::DssNetAddr* release_dstaddr();
  inline void set_allocated_dstaddr(::Dss::Event::DssNetAddr* dstaddr);

  // optional .Dss.Event.DssNetAddr RcvAddr = 6;
  inline bool has_rcvaddr() const;
  inline void clear_rcvaddr();
  static const int kRcvAddrFieldNumber = 6;
  inline const ::Dss::Event::DssNetAddr& rcvaddr() const;
  inline ::Dss::Event::DssNetAddr* mutable_rcvaddr();
  inline ::Dss::Event::DssNetAddr* release_rcvaddr();
  inline void set_allocated_rcvaddr(::Dss::Event::DssNetAddr* rcvaddr);

  // optional .Dss.Event.DsType dstype = 7;
  inline bool has_dstype() const;
  inline void clear_dstype();
  static const int kDstypeFieldNumber = 7;
  inline ::Dss::Event::DsType dstype() const;
  inline void set_dstype(::Dss::Event::DsType value);

  // @@protoc_insertion_point(class_scope:Dss.Event.DssCltAddSrcSwitchAck)
 private:
  inline void set_has_clientid();
  inline void clear_has_clientid();
  inline void set_has_srcepid();
  inline void clear_has_srcepid();
  inline void set_has_srcaddr();
  inline void clear_has_srcaddr();
  inline void set_has_dstepid();
  inline void clear_has_dstepid();
  inline void set_has_dstaddr();
  inline void clear_has_dstaddr();
  inline void set_has_rcvaddr();
  inline void clear_has_rcvaddr();
  inline void set_has_dstype();
  inline void clear_has_dstype();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 srcepid_;
  ::Dss::Event::DssNetAddr* srcaddr_;
  ::google::protobuf::uint64 dstepid_;
  ::google::protobuf::uint32 clientid_;
  int dstype_;
  ::Dss::Event::DssNetAddr* dstaddr_;
  ::Dss::Event::DssNetAddr* rcvaddr_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_dssevent_2eproto();
  friend void protobuf_AssignDesc_dssevent_2eproto();
  friend void protobuf_ShutdownFile_dssevent_2eproto();

  void InitAsDefaultInstance();
  static DssCltAddSrcSwitchAck* default_instance_;
};
// -------------------------------------------------------------------

class DssCltAddSrcSwitchNack : public ::google::protobuf::Message {
 public:
  DssCltAddSrcSwitchNack();
  virtual ~DssCltAddSrcSwitchNack();

  DssCltAddSrcSwitchNack(const DssCltAddSrcSwitchNack& from);

  inline DssCltAddSrcSwitchNack& operator=(const DssCltAddSrcSwitchNack& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DssCltAddSrcSwitchNack& default_instance();

  void Swap(DssCltAddSrcSwitchNack* other);

  // implements Message ----------------------------------------------

  DssCltAddSrcSwitchNack* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 ClientId = 1;
  inline bool has_clientid() const;
  inline void clear_clientid();
  static const int kClientIdFieldNumber = 1;
  inline ::google::protobuf::uint32 clientid() const;
  inline void set_clientid(::google::protobuf::uint32 value);

  // optional uint64 SrcEpId = 2;
  inline bool has_srcepid() const;
  inline void clear_srcepid();
  static const int kSrcEpIdFieldNumber = 2;
  inline ::google::protobuf::uint64 srcepid() const;
  inline void set_srcepid(::google::protobuf::uint64 value);

  // optional .Dss.Event.DssNetAddr SrcAddr = 3;
  inline bool has_srcaddr() const;
  inline void clear_srcaddr();
  static const int kSrcAddrFieldNumber = 3;
  inline const ::Dss::Event::DssNetAddr& srcaddr() const;
  inline ::Dss::Event::DssNetAddr* mutable_srcaddr();
  inline ::Dss::Event::DssNetAddr* release_srcaddr();
  inline void set_allocated_srcaddr(::Dss::Event::DssNetAddr* srcaddr);

  // optional uint64 DstEpId = 4;
  inline bool has_dstepid() const;
  inline void clear_dstepid();
  static const int kDstEpIdFieldNumber = 4;
  inline ::google::protobuf::uint64 dstepid() const;
  inline void set_dstepid(::google::protobuf::uint64 value);

  // optional .Dss.Event.DssNetAddr DstAddr = 5;
  inline bool has_dstaddr() const;
  inline void clear_dstaddr();
  static const int kDstAddrFieldNumber = 5;
  inline const ::Dss::Event::DssNetAddr& dstaddr() const;
  inline ::Dss::Event::DssNetAddr* mutable_dstaddr();
  inline ::Dss::Event::DssNetAddr* release_dstaddr();
  inline void set_allocated_dstaddr(::Dss::Event::DssNetAddr* dstaddr);

  // optional .Dss.Event.DssNetAddr RcvAddr = 6;
  inline bool has_rcvaddr() const;
  inline void clear_rcvaddr();
  static const int kRcvAddrFieldNumber = 6;
  inline const ::Dss::Event::DssNetAddr& rcvaddr() const;
  inline ::Dss::Event::DssNetAddr* mutable_rcvaddr();
  inline ::Dss::Event::DssNetAddr* release_rcvaddr();
  inline void set_allocated_rcvaddr(::Dss::Event::DssNetAddr* rcvaddr);

  // optional .Dss.Event.DsType dstype = 7;
  inline bool has_dstype() const;
  inline void clear_dstype();
  static const int kDstypeFieldNumber = 7;
  inline ::Dss::Event::DsType dstype() const;
  inline void set_dstype(::Dss::Event::DsType value);

  // @@protoc_insertion_point(class_scope:Dss.Event.DssCltAddSrcSwitchNack)
 private:
  inline void set_has_clientid();
  inline void clear_has_clientid();
  inline void set_has_srcepid();
  inline void clear_has_srcepid();
  inline void set_has_srcaddr();
  inline void clear_has_srcaddr();
  inline void set_has_dstepid();
  inline void clear_has_dstepid();
  inline void set_has_dstaddr();
  inline void clear_has_dstaddr();
  inline void set_has_rcvaddr();
  inline void clear_has_rcvaddr();
  inline void set_has_dstype();
  inline void clear_has_dstype();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 srcepid_;
  ::Dss::Event::DssNetAddr* srcaddr_;
  ::google::protobuf::uint64 dstepid_;
  ::google::protobuf::uint32 clientid_;
  int dstype_;
  ::Dss::Event::DssNetAddr* dstaddr_;
  ::Dss::Event::DssNetAddr* rcvaddr_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_dssevent_2eproto();
  friend void protobuf_AssignDesc_dssevent_2eproto();
  friend void protobuf_ShutdownFile_dssevent_2eproto();

  void InitAsDefaultInstance();
  static DssCltAddSrcSwitchNack* default_instance_;
};
// -------------------------------------------------------------------

class CltDssRemoveSwitchCmd : public ::google::protobuf::Message {
 public:
  CltDssRemoveSwitchCmd();
  virtual ~CltDssRemoveSwitchCmd();

  CltDssRemoveSwitchCmd(const CltDssRemoveSwitchCmd& from);

  inline CltDssRemoveSwitchCmd& operator=(const CltDssRemoveSwitchCmd& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CltDssRemoveSwitchCmd& default_instance();

  void Swap(CltDssRemoveSwitchCmd* other);

  // implements Message ----------------------------------------------

  CltDssRemoveSwitchCmd* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 ClientId = 1;
  inline bool has_clientid() const;
  inline void clear_clientid();
  static const int kClientIdFieldNumber = 1;
  inline ::google::protobuf::uint32 clientid() const;
  inline void set_clientid(::google::protobuf::uint32 value);

  // optional uint64 SrcEpId = 2;
  inline bool has_srcepid() const;
  inline void clear_srcepid();
  static const int kSrcEpIdFieldNumber = 2;
  inline ::google::protobuf::uint64 srcepid() const;
  inline void set_srcepid(::google::protobuf::uint64 value);

  // optional .Dss.Event.DssNetAddr SrcAddr = 3;
  inline bool has_srcaddr() const;
  inline void clear_srcaddr();
  static const int kSrcAddrFieldNumber = 3;
  inline const ::Dss::Event::DssNetAddr& srcaddr() const;
  inline ::Dss::Event::DssNetAddr* mutable_srcaddr();
  inline ::Dss::Event::DssNetAddr* release_srcaddr();
  inline void set_allocated_srcaddr(::Dss::Event::DssNetAddr* srcaddr);

  // optional uint64 DstEpId = 4;
  inline bool has_dstepid() const;
  inline void clear_dstepid();
  static const int kDstEpIdFieldNumber = 4;
  inline ::google::protobuf::uint64 dstepid() const;
  inline void set_dstepid(::google::protobuf::uint64 value);

  // optional .Dss.Event.DssNetAddr DstAddr = 5;
  inline bool has_dstaddr() const;
  inline void clear_dstaddr();
  static const int kDstAddrFieldNumber = 5;
  inline const ::Dss::Event::DssNetAddr& dstaddr() const;
  inline ::Dss::Event::DssNetAddr* mutable_dstaddr();
  inline ::Dss::Event::DssNetAddr* release_dstaddr();
  inline void set_allocated_dstaddr(::Dss::Event::DssNetAddr* dstaddr);

  // optional .Dss.Event.DssNetAddr RcvAddr = 6;
  inline bool has_rcvaddr() const;
  inline void clear_rcvaddr();
  static const int kRcvAddrFieldNumber = 6;
  inline const ::Dss::Event::DssNetAddr& rcvaddr() const;
  inline ::Dss::Event::DssNetAddr* mutable_rcvaddr();
  inline ::Dss::Event::DssNetAddr* release_rcvaddr();
  inline void set_allocated_rcvaddr(::Dss::Event::DssNetAddr* rcvaddr);

  // optional .Dss.Event.DssNetAddr MapAddr = 7;
  inline bool has_mapaddr() const;
  inline void clear_mapaddr();
  static const int kMapAddrFieldNumber = 7;
  inline const ::Dss::Event::DssNetAddr& mapaddr() const;
  inline ::Dss::Event::DssNetAddr* mutable_mapaddr();
  inline ::Dss::Event::DssNetAddr* release_mapaddr();
  inline void set_allocated_mapaddr(::Dss::Event::DssNetAddr* mapaddr);

  // optional .Dss.Event.DsType dstype = 8;
  inline bool has_dstype() const;
  inline void clear_dstype();
  static const int kDstypeFieldNumber = 8;
  inline ::Dss::Event::DsType dstype() const;
  inline void set_dstype(::Dss::Event::DsType value);

  // @@protoc_insertion_point(class_scope:Dss.Event.CltDssRemoveSwitchCmd)
 private:
  inline void set_has_clientid();
  inline void clear_has_clientid();
  inline void set_has_srcepid();
  inline void clear_has_srcepid();
  inline void set_has_srcaddr();
  inline void clear_has_srcaddr();
  inline void set_has_dstepid();
  inline void clear_has_dstepid();
  inline void set_has_dstaddr();
  inline void clear_has_dstaddr();
  inline void set_has_rcvaddr();
  inline void clear_has_rcvaddr();
  inline void set_has_mapaddr();
  inline void clear_has_mapaddr();
  inline void set_has_dstype();
  inline void clear_has_dstype();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 srcepid_;
  ::Dss::Event::DssNetAddr* srcaddr_;
  ::google::protobuf::uint64 dstepid_;
  ::google::protobuf::uint32 clientid_;
  int dstype_;
  ::Dss::Event::DssNetAddr* dstaddr_;
  ::Dss::Event::DssNetAddr* rcvaddr_;
  ::Dss::Event::DssNetAddr* mapaddr_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void  protobuf_AddDesc_dssevent_2eproto();
  friend void protobuf_AssignDesc_dssevent_2eproto();
  friend void protobuf_ShutdownFile_dssevent_2eproto();

  void InitAsDefaultInstance();
  static CltDssRemoveSwitchCmd* default_instance_;
};
// -------------------------------------------------------------------

class CltDssAddDumpReq : public ::google::protobuf::Message {
 public:
  CltDssAddDumpReq();
  virtual ~CltDssAddDumpReq();

  CltDssAddDumpReq(const CltDssAddDumpReq& from);

  inline CltDssAddDumpReq& operator=(const CltDssAddDumpReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CltDssAddDumpReq& default_instance();

  void Swap(CltDssAddDumpReq* other);

  // implements Message ----------------------------------------------

  CltDssAddDumpReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 ClientId = 1;
  inline bool has_clientid() const;
  inline void clear_clientid();
  static const int kClientIdFieldNumber = 1;
  inline ::google::protobuf::uint32 clientid() const;
  inline void set_clientid(::google::protobuf::uint32 value);

  // optional .Dss.Event.DssNetAddr RcvAddr = 2;
  inline bool has_rcvaddr() const;
  inline void clear_rcvaddr();
  static const int kRcvAddrFieldNumber = 2;
  inline const ::Dss::Event::DssNetAddr& rcvaddr() const;
  inline ::Dss::Event::DssNetAddr* mutable_rcvaddr();
  inline ::Dss::Event::DssNetAddr* release_rcvaddr();
  inline void set_allocated_rcvaddr(::Dss::Event::DssNetAddr* rcvaddr);

  // @@protoc_insertion_point(class_scope:Dss.Event.CltDssAddDumpReq)
 private:
  inline void set_has_clientid();
  inline void clear_has_clientid();
  inline void set_has_rcvaddr();
  inline void clear_has_rcvaddr();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Dss::Event::DssNetAddr* rcvaddr_;
  ::google::protobuf::uint32 clientid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_dssevent_2eproto();
  friend void protobuf_AssignDesc_dssevent_2eproto();
  friend void protobuf_ShutdownFile_dssevent_2eproto();

  void InitAsDefaultInstance();
  static CltDssAddDumpReq* default_instance_;
};
// -------------------------------------------------------------------

class DssCltAddDumpAck : public ::google::protobuf::Message {
 public:
  DssCltAddDumpAck();
  virtual ~DssCltAddDumpAck();

  DssCltAddDumpAck(const DssCltAddDumpAck& from);

  inline DssCltAddDumpAck& operator=(const DssCltAddDumpAck& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DssCltAddDumpAck& default_instance();

  void Swap(DssCltAddDumpAck* other);

  // implements Message ----------------------------------------------

  DssCltAddDumpAck* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 ClientId = 1;
  inline bool has_clientid() const;
  inline void clear_clientid();
  static const int kClientIdFieldNumber = 1;
  inline ::google::protobuf::uint32 clientid() const;
  inline void set_clientid(::google::protobuf::uint32 value);

  // optional .Dss.Event.DssNetAddr RcvAddr = 2;
  inline bool has_rcvaddr() const;
  inline void clear_rcvaddr();
  static const int kRcvAddrFieldNumber = 2;
  inline const ::Dss::Event::DssNetAddr& rcvaddr() const;
  inline ::Dss::Event::DssNetAddr* mutable_rcvaddr();
  inline ::Dss::Event::DssNetAddr* release_rcvaddr();
  inline void set_allocated_rcvaddr(::Dss::Event::DssNetAddr* rcvaddr);

  // @@protoc_insertion_point(class_scope:Dss.Event.DssCltAddDumpAck)
 private:
  inline void set_has_clientid();
  inline void clear_has_clientid();
  inline void set_has_rcvaddr();
  inline void clear_has_rcvaddr();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Dss::Event::DssNetAddr* rcvaddr_;
  ::google::protobuf::uint32 clientid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_dssevent_2eproto();
  friend void protobuf_AssignDesc_dssevent_2eproto();
  friend void protobuf_ShutdownFile_dssevent_2eproto();

  void InitAsDefaultInstance();
  static DssCltAddDumpAck* default_instance_;
};
// -------------------------------------------------------------------

class DssCltAddDumpNack : public ::google::protobuf::Message {
 public:
  DssCltAddDumpNack();
  virtual ~DssCltAddDumpNack();

  DssCltAddDumpNack(const DssCltAddDumpNack& from);

  inline DssCltAddDumpNack& operator=(const DssCltAddDumpNack& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DssCltAddDumpNack& default_instance();

  void Swap(DssCltAddDumpNack* other);

  // implements Message ----------------------------------------------

  DssCltAddDumpNack* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 ClientId = 1;
  inline bool has_clientid() const;
  inline void clear_clientid();
  static const int kClientIdFieldNumber = 1;
  inline ::google::protobuf::uint32 clientid() const;
  inline void set_clientid(::google::protobuf::uint32 value);

  // optional .Dss.Event.DssNetAddr RcvAddr = 2;
  inline bool has_rcvaddr() const;
  inline void clear_rcvaddr();
  static const int kRcvAddrFieldNumber = 2;
  inline const ::Dss::Event::DssNetAddr& rcvaddr() const;
  inline ::Dss::Event::DssNetAddr* mutable_rcvaddr();
  inline ::Dss::Event::DssNetAddr* release_rcvaddr();
  inline void set_allocated_rcvaddr(::Dss::Event::DssNetAddr* rcvaddr);

  // @@protoc_insertion_point(class_scope:Dss.Event.DssCltAddDumpNack)
 private:
  inline void set_has_clientid();
  inline void clear_has_clientid();
  inline void set_has_rcvaddr();
  inline void clear_has_rcvaddr();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Dss::Event::DssNetAddr* rcvaddr_;
  ::google::protobuf::uint32 clientid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_dssevent_2eproto();
  friend void protobuf_AssignDesc_dssevent_2eproto();
  friend void protobuf_ShutdownFile_dssevent_2eproto();

  void InitAsDefaultInstance();
  static DssCltAddDumpNack* default_instance_;
};
// -------------------------------------------------------------------

class CltDssRemoveDumpCmd : public ::google::protobuf::Message {
 public:
  CltDssRemoveDumpCmd();
  virtual ~CltDssRemoveDumpCmd();

  CltDssRemoveDumpCmd(const CltDssRemoveDumpCmd& from);

  inline CltDssRemoveDumpCmd& operator=(const CltDssRemoveDumpCmd& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CltDssRemoveDumpCmd& default_instance();

  void Swap(CltDssRemoveDumpCmd* other);

  // implements Message ----------------------------------------------

  CltDssRemoveDumpCmd* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 ClientId = 1;
  inline bool has_clientid() const;
  inline void clear_clientid();
  static const int kClientIdFieldNumber = 1;
  inline ::google::protobuf::uint32 clientid() const;
  inline void set_clientid(::google::protobuf::uint32 value);

  // optional .Dss.Event.DssNetAddr RcvAddr = 2;
  inline bool has_rcvaddr() const;
  inline void clear_rcvaddr();
  static const int kRcvAddrFieldNumber = 2;
  inline const ::Dss::Event::DssNetAddr& rcvaddr() const;
  inline ::Dss::Event::DssNetAddr* mutable_rcvaddr();
  inline ::Dss::Event::DssNetAddr* release_rcvaddr();
  inline void set_allocated_rcvaddr(::Dss::Event::DssNetAddr* rcvaddr);

  // @@protoc_insertion_point(class_scope:Dss.Event.CltDssRemoveDumpCmd)
 private:
  inline void set_has_clientid();
  inline void clear_has_clientid();
  inline void set_has_rcvaddr();
  inline void clear_has_rcvaddr();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Dss::Event::DssNetAddr* rcvaddr_;
  ::google::protobuf::uint32 clientid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_dssevent_2eproto();
  friend void protobuf_AssignDesc_dssevent_2eproto();
  friend void protobuf_ShutdownFile_dssevent_2eproto();

  void InitAsDefaultInstance();
  static CltDssRemoveDumpCmd* default_instance_;
};
// -------------------------------------------------------------------

class DssCltSrvLostNtf : public ::google::protobuf::Message {
 public:
  DssCltSrvLostNtf();
  virtual ~DssCltSrvLostNtf();

  DssCltSrvLostNtf(const DssCltSrvLostNtf& from);

  inline DssCltSrvLostNtf& operator=(const DssCltSrvLostNtf& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DssCltSrvLostNtf& default_instance();

  void Swap(DssCltSrvLostNtf* other);

  // implements Message ----------------------------------------------

  DssCltSrvLostNtf* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 ClientId = 1;
  inline bool has_clientid() const;
  inline void clear_clientid();
  static const int kClientIdFieldNumber = 1;
  inline ::google::protobuf::uint32 clientid() const;
  inline void set_clientid(::google::protobuf::uint32 value);

  // optional uint32 SrvHandle = 2;
  inline bool has_srvhandle() const;
  inline void clear_srvhandle();
  static const int kSrvHandleFieldNumber = 2;
  inline ::google::protobuf::uint32 srvhandle() const;
  inline void set_srvhandle(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Dss.Event.DssCltSrvLostNtf)
 private:
  inline void set_has_clientid();
  inline void clear_has_clientid();
  inline void set_has_srvhandle();
  inline void clear_has_srvhandle();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 clientid_;
  ::google::protobuf::uint32 srvhandle_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_dssevent_2eproto();
  friend void protobuf_AssignDesc_dssevent_2eproto();
  friend void protobuf_ShutdownFile_dssevent_2eproto();

  void InitAsDefaultInstance();
  static DssCltSrvLostNtf* default_instance_;
};
// -------------------------------------------------------------------

class DssCltSrvRegisterNtf : public ::google::protobuf::Message {
 public:
  DssCltSrvRegisterNtf();
  virtual ~DssCltSrvRegisterNtf();

  DssCltSrvRegisterNtf(const DssCltSrvRegisterNtf& from);

  inline DssCltSrvRegisterNtf& operator=(const DssCltSrvRegisterNtf& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DssCltSrvRegisterNtf& default_instance();

  void Swap(DssCltSrvRegisterNtf* other);

  // implements Message ----------------------------------------------

  DssCltSrvRegisterNtf* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 ClientId = 1;
  inline bool has_clientid() const;
  inline void clear_clientid();
  static const int kClientIdFieldNumber = 1;
  inline ::google::protobuf::uint32 clientid() const;
  inline void set_clientid(::google::protobuf::uint32 value);

  // optional uint32 SrvHandle = 2;
  inline bool has_srvhandle() const;
  inline void clear_srvhandle();
  static const int kSrvHandleFieldNumber = 2;
  inline ::google::protobuf::uint32 srvhandle() const;
  inline void set_srvhandle(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Dss.Event.DssCltSrvRegisterNtf)
 private:
  inline void set_has_clientid();
  inline void clear_has_clientid();
  inline void set_has_srvhandle();
  inline void clear_has_srvhandle();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 clientid_;
  ::google::protobuf::uint32 srvhandle_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_dssevent_2eproto();
  friend void protobuf_AssignDesc_dssevent_2eproto();
  friend void protobuf_ShutdownFile_dssevent_2eproto();

  void InitAsDefaultInstance();
  static DssCltSrvRegisterNtf* default_instance_;
};
// -------------------------------------------------------------------

class CltDssAliveDetectReq : public ::google::protobuf::Message {
 public:
  CltDssAliveDetectReq();
  virtual ~CltDssAliveDetectReq();

  CltDssAliveDetectReq(const CltDssAliveDetectReq& from);

  inline CltDssAliveDetectReq& operator=(const CltDssAliveDetectReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CltDssAliveDetectReq& default_instance();

  void Swap(CltDssAliveDetectReq* other);

  // implements Message ----------------------------------------------

  CltDssAliveDetectReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 reserved = 1;
  inline bool has_reserved() const;
  inline void clear_reserved();
  static const int kReservedFieldNumber = 1;
  inline ::google::protobuf::uint32 reserved() const;
  inline void set_reserved(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Dss.Event.CltDssAliveDetectReq)
 private:
  inline void set_has_reserved();
  inline void clear_has_reserved();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 reserved_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_dssevent_2eproto();
  friend void protobuf_AssignDesc_dssevent_2eproto();
  friend void protobuf_ShutdownFile_dssevent_2eproto();

  void InitAsDefaultInstance();
  static CltDssAliveDetectReq* default_instance_;
};
// -------------------------------------------------------------------

class DssCltAliveDetectRsp : public ::google::protobuf::Message {
 public:
  DssCltAliveDetectRsp();
  virtual ~DssCltAliveDetectRsp();

  DssCltAliveDetectRsp(const DssCltAliveDetectRsp& from);

  inline DssCltAliveDetectRsp& operator=(const DssCltAliveDetectRsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DssCltAliveDetectRsp& default_instance();

  void Swap(DssCltAliveDetectRsp* other);

  // implements Message ----------------------------------------------

  DssCltAliveDetectRsp* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 reserved = 1;
  inline bool has_reserved() const;
  inline void clear_reserved();
  static const int kReservedFieldNumber = 1;
  inline ::google::protobuf::uint32 reserved() const;
  inline void set_reserved(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Dss.Event.DssCltAliveDetectRsp)
 private:
  inline void set_has_reserved();
  inline void clear_has_reserved();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 reserved_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_dssevent_2eproto();
  friend void protobuf_AssignDesc_dssevent_2eproto();
  friend void protobuf_ShutdownFile_dssevent_2eproto();

  void InitAsDefaultInstance();
  static DssCltAliveDetectRsp* default_instance_;
};
// -------------------------------------------------------------------

class CltDssAttachLanIpOfPortReq : public ::google::protobuf::Message {
 public:
  CltDssAttachLanIpOfPortReq();
  virtual ~CltDssAttachLanIpOfPortReq();

  CltDssAttachLanIpOfPortReq(const CltDssAttachLanIpOfPortReq& from);

  inline CltDssAttachLanIpOfPortReq& operator=(const CltDssAttachLanIpOfPortReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CltDssAttachLanIpOfPortReq& default_instance();

  void Swap(CltDssAttachLanIpOfPortReq* other);

  // implements Message ----------------------------------------------

  CltDssAttachLanIpOfPortReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 ClientId = 1;
  inline bool has_clientid() const;
  inline void clear_clientid();
  static const int kClientIdFieldNumber = 1;
  inline ::google::protobuf::uint32 clientid() const;
  inline void set_clientid(::google::protobuf::uint32 value);

  // optional uint32 SrvHandle = 2;
  inline bool has_srvhandle() const;
  inline void clear_srvhandle();
  static const int kSrvHandleFieldNumber = 2;
  inline ::google::protobuf::uint32 srvhandle() const;
  inline void set_srvhandle(::google::protobuf::uint32 value);

  // optional uint32 Port = 3;
  inline bool has_port() const;
  inline void clear_port();
  static const int kPortFieldNumber = 3;
  inline ::google::protobuf::uint32 port() const;
  inline void set_port(::google::protobuf::uint32 value);

  // optional .Dss.Event.DssNetAddr subnet = 4;
  inline bool has_subnet() const;
  inline void clear_subnet();
  static const int kSubnetFieldNumber = 4;
  inline const ::Dss::Event::DssNetAddr& subnet() const;
  inline ::Dss::Event::DssNetAddr* mutable_subnet();
  inline ::Dss::Event::DssNetAddr* release_subnet();
  inline void set_allocated_subnet(::Dss::Event::DssNetAddr* subnet);

  // @@protoc_insertion_point(class_scope:Dss.Event.CltDssAttachLanIpOfPortReq)
 private:
  inline void set_has_clientid();
  inline void clear_has_clientid();
  inline void set_has_srvhandle();
  inline void clear_has_srvhandle();
  inline void set_has_port();
  inline void clear_has_port();
  inline void set_has_subnet();
  inline void clear_has_subnet();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 clientid_;
  ::google::protobuf::uint32 srvhandle_;
  ::Dss::Event::DssNetAddr* subnet_;
  ::google::protobuf::uint32 port_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_dssevent_2eproto();
  friend void protobuf_AssignDesc_dssevent_2eproto();
  friend void protobuf_ShutdownFile_dssevent_2eproto();

  void InitAsDefaultInstance();
  static CltDssAttachLanIpOfPortReq* default_instance_;
};
// -------------------------------------------------------------------

class DssCltAttachLanIpOfPortAck : public ::google::protobuf::Message {
 public:
  DssCltAttachLanIpOfPortAck();
  virtual ~DssCltAttachLanIpOfPortAck();

  DssCltAttachLanIpOfPortAck(const DssCltAttachLanIpOfPortAck& from);

  inline DssCltAttachLanIpOfPortAck& operator=(const DssCltAttachLanIpOfPortAck& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DssCltAttachLanIpOfPortAck& default_instance();

  void Swap(DssCltAttachLanIpOfPortAck* other);

  // implements Message ----------------------------------------------

  DssCltAttachLanIpOfPortAck* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 ClientId = 1;
  inline bool has_clientid() const;
  inline void clear_clientid();
  static const int kClientIdFieldNumber = 1;
  inline ::google::protobuf::uint32 clientid() const;
  inline void set_clientid(::google::protobuf::uint32 value);

  // optional uint32 SrvHandle = 2;
  inline bool has_srvhandle() const;
  inline void clear_srvhandle();
  static const int kSrvHandleFieldNumber = 2;
  inline ::google::protobuf::uint32 srvhandle() const;
  inline void set_srvhandle(::google::protobuf::uint32 value);

  // optional uint32 Port = 3;
  inline bool has_port() const;
  inline void clear_port();
  static const int kPortFieldNumber = 3;
  inline ::google::protobuf::uint32 port() const;
  inline void set_port(::google::protobuf::uint32 value);

  // optional string IpAddr = 4;
  inline bool has_ipaddr() const;
  inline void clear_ipaddr();
  static const int kIpAddrFieldNumber = 4;
  inline const ::std::string& ipaddr() const;
  inline void set_ipaddr(const ::std::string& value);
  inline void set_ipaddr(const char* value);
  inline void set_ipaddr(const char* value, size_t size);
  inline ::std::string* mutable_ipaddr();
  inline ::std::string* release_ipaddr();
  inline void set_allocated_ipaddr(::std::string* ipaddr);

  // @@protoc_insertion_point(class_scope:Dss.Event.DssCltAttachLanIpOfPortAck)
 private:
  inline void set_has_clientid();
  inline void clear_has_clientid();
  inline void set_has_srvhandle();
  inline void clear_has_srvhandle();
  inline void set_has_port();
  inline void clear_has_port();
  inline void set_has_ipaddr();
  inline void clear_has_ipaddr();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 clientid_;
  ::google::protobuf::uint32 srvhandle_;
  ::std::string* ipaddr_;
  ::google::protobuf::uint32 port_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_dssevent_2eproto();
  friend void protobuf_AssignDesc_dssevent_2eproto();
  friend void protobuf_ShutdownFile_dssevent_2eproto();

  void InitAsDefaultInstance();
  static DssCltAttachLanIpOfPortAck* default_instance_;
};
// -------------------------------------------------------------------

class DssCltAttachLanIpOfPortNack : public ::google::protobuf::Message {
 public:
  DssCltAttachLanIpOfPortNack();
  virtual ~DssCltAttachLanIpOfPortNack();

  DssCltAttachLanIpOfPortNack(const DssCltAttachLanIpOfPortNack& from);

  inline DssCltAttachLanIpOfPortNack& operator=(const DssCltAttachLanIpOfPortNack& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DssCltAttachLanIpOfPortNack& default_instance();

  void Swap(DssCltAttachLanIpOfPortNack* other);

  // implements Message ----------------------------------------------

  DssCltAttachLanIpOfPortNack* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 ClientId = 1;
  inline bool has_clientid() const;
  inline void clear_clientid();
  static const int kClientIdFieldNumber = 1;
  inline ::google::protobuf::uint32 clientid() const;
  inline void set_clientid(::google::protobuf::uint32 value);

  // optional uint32 SrvHandle = 2;
  inline bool has_srvhandle() const;
  inline void clear_srvhandle();
  static const int kSrvHandleFieldNumber = 2;
  inline ::google::protobuf::uint32 srvhandle() const;
  inline void set_srvhandle(::google::protobuf::uint32 value);

  // optional uint32 Port = 3;
  inline bool has_port() const;
  inline void clear_port();
  static const int kPortFieldNumber = 3;
  inline ::google::protobuf::uint32 port() const;
  inline void set_port(::google::protobuf::uint32 value);

  // optional .Dss.Event.DssNetAddr subnet = 4;
  inline bool has_subnet() const;
  inline void clear_subnet();
  static const int kSubnetFieldNumber = 4;
  inline const ::Dss::Event::DssNetAddr& subnet() const;
  inline ::Dss::Event::DssNetAddr* mutable_subnet();
  inline ::Dss::Event::DssNetAddr* release_subnet();
  inline void set_allocated_subnet(::Dss::Event::DssNetAddr* subnet);

  // @@protoc_insertion_point(class_scope:Dss.Event.DssCltAttachLanIpOfPortNack)
 private:
  inline void set_has_clientid();
  inline void clear_has_clientid();
  inline void set_has_srvhandle();
  inline void clear_has_srvhandle();
  inline void set_has_port();
  inline void clear_has_port();
  inline void set_has_subnet();
  inline void clear_has_subnet();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 clientid_;
  ::google::protobuf::uint32 srvhandle_;
  ::Dss::Event::DssNetAddr* subnet_;
  ::google::protobuf::uint32 port_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_dssevent_2eproto();
  friend void protobuf_AssignDesc_dssevent_2eproto();
  friend void protobuf_ShutdownFile_dssevent_2eproto();

  void InitAsDefaultInstance();
  static DssCltAttachLanIpOfPortNack* default_instance_;
};
// -------------------------------------------------------------------

class CltDssAttachWanIpOfPortReq : public ::google::protobuf::Message {
 public:
  CltDssAttachWanIpOfPortReq();
  virtual ~CltDssAttachWanIpOfPortReq();

  CltDssAttachWanIpOfPortReq(const CltDssAttachWanIpOfPortReq& from);

  inline CltDssAttachWanIpOfPortReq& operator=(const CltDssAttachWanIpOfPortReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CltDssAttachWanIpOfPortReq& default_instance();

  void Swap(CltDssAttachWanIpOfPortReq* other);

  // implements Message ----------------------------------------------

  CltDssAttachWanIpOfPortReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 ClientId = 1;
  inline bool has_clientid() const;
  inline void clear_clientid();
  static const int kClientIdFieldNumber = 1;
  inline ::google::protobuf::uint32 clientid() const;
  inline void set_clientid(::google::protobuf::uint32 value);

  // optional uint32 SrvHandle = 2;
  inline bool has_srvhandle() const;
  inline void clear_srvhandle();
  static const int kSrvHandleFieldNumber = 2;
  inline ::google::protobuf::uint32 srvhandle() const;
  inline void set_srvhandle(::google::protobuf::uint32 value);

  // optional uint32 Port = 3;
  inline bool has_port() const;
  inline void clear_port();
  static const int kPortFieldNumber = 3;
  inline ::google::protobuf::uint32 port() const;
  inline void set_port(::google::protobuf::uint32 value);

  // optional .Dss.Event.CarrierType carriertype = 4;
  inline bool has_carriertype() const;
  inline void clear_carriertype();
  static const int kCarriertypeFieldNumber = 4;
  inline ::Dss::Event::CarrierType carriertype() const;
  inline void set_carriertype(::Dss::Event::CarrierType value);

  // @@protoc_insertion_point(class_scope:Dss.Event.CltDssAttachWanIpOfPortReq)
 private:
  inline void set_has_clientid();
  inline void clear_has_clientid();
  inline void set_has_srvhandle();
  inline void clear_has_srvhandle();
  inline void set_has_port();
  inline void clear_has_port();
  inline void set_has_carriertype();
  inline void clear_has_carriertype();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 clientid_;
  ::google::protobuf::uint32 srvhandle_;
  ::google::protobuf::uint32 port_;
  int carriertype_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_dssevent_2eproto();
  friend void protobuf_AssignDesc_dssevent_2eproto();
  friend void protobuf_ShutdownFile_dssevent_2eproto();

  void InitAsDefaultInstance();
  static CltDssAttachWanIpOfPortReq* default_instance_;
};
// -------------------------------------------------------------------

class DssCltAttachWanIpOfPortAck : public ::google::protobuf::Message {
 public:
  DssCltAttachWanIpOfPortAck();
  virtual ~DssCltAttachWanIpOfPortAck();

  DssCltAttachWanIpOfPortAck(const DssCltAttachWanIpOfPortAck& from);

  inline DssCltAttachWanIpOfPortAck& operator=(const DssCltAttachWanIpOfPortAck& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DssCltAttachWanIpOfPortAck& default_instance();

  void Swap(DssCltAttachWanIpOfPortAck* other);

  // implements Message ----------------------------------------------

  DssCltAttachWanIpOfPortAck* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 ClientId = 1;
  inline bool has_clientid() const;
  inline void clear_clientid();
  static const int kClientIdFieldNumber = 1;
  inline ::google::protobuf::uint32 clientid() const;
  inline void set_clientid(::google::protobuf::uint32 value);

  // optional uint32 SrvHandle = 2;
  inline bool has_srvhandle() const;
  inline void clear_srvhandle();
  static const int kSrvHandleFieldNumber = 2;
  inline ::google::protobuf::uint32 srvhandle() const;
  inline void set_srvhandle(::google::protobuf::uint32 value);

  // optional uint32 Port = 3;
  inline bool has_port() const;
  inline void clear_port();
  static const int kPortFieldNumber = 3;
  inline ::google::protobuf::uint32 port() const;
  inline void set_port(::google::protobuf::uint32 value);

  // optional string IpAddr = 4;
  inline bool has_ipaddr() const;
  inline void clear_ipaddr();
  static const int kIpAddrFieldNumber = 4;
  inline const ::std::string& ipaddr() const;
  inline void set_ipaddr(const ::std::string& value);
  inline void set_ipaddr(const char* value);
  inline void set_ipaddr(const char* value, size_t size);
  inline ::std::string* mutable_ipaddr();
  inline ::std::string* release_ipaddr();
  inline void set_allocated_ipaddr(::std::string* ipaddr);

  // @@protoc_insertion_point(class_scope:Dss.Event.DssCltAttachWanIpOfPortAck)
 private:
  inline void set_has_clientid();
  inline void clear_has_clientid();
  inline void set_has_srvhandle();
  inline void clear_has_srvhandle();
  inline void set_has_port();
  inline void clear_has_port();
  inline void set_has_ipaddr();
  inline void clear_has_ipaddr();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 clientid_;
  ::google::protobuf::uint32 srvhandle_;
  ::std::string* ipaddr_;
  ::google::protobuf::uint32 port_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_dssevent_2eproto();
  friend void protobuf_AssignDesc_dssevent_2eproto();
  friend void protobuf_ShutdownFile_dssevent_2eproto();

  void InitAsDefaultInstance();
  static DssCltAttachWanIpOfPortAck* default_instance_;
};
// -------------------------------------------------------------------

class DssCltAttachWanIpOfPortNack : public ::google::protobuf::Message {
 public:
  DssCltAttachWanIpOfPortNack();
  virtual ~DssCltAttachWanIpOfPortNack();

  DssCltAttachWanIpOfPortNack(const DssCltAttachWanIpOfPortNack& from);

  inline DssCltAttachWanIpOfPortNack& operator=(const DssCltAttachWanIpOfPortNack& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DssCltAttachWanIpOfPortNack& default_instance();

  void Swap(DssCltAttachWanIpOfPortNack* other);

  // implements Message ----------------------------------------------

  DssCltAttachWanIpOfPortNack* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 ClientId = 1;
  inline bool has_clientid() const;
  inline void clear_clientid();
  static const int kClientIdFieldNumber = 1;
  inline ::google::protobuf::uint32 clientid() const;
  inline void set_clientid(::google::protobuf::uint32 value);

  // optional uint32 SrvHandle = 2;
  inline bool has_srvhandle() const;
  inline void clear_srvhandle();
  static const int kSrvHandleFieldNumber = 2;
  inline ::google::protobuf::uint32 srvhandle() const;
  inline void set_srvhandle(::google::protobuf::uint32 value);

  // optional uint32 Port = 3;
  inline bool has_port() const;
  inline void clear_port();
  static const int kPortFieldNumber = 3;
  inline ::google::protobuf::uint32 port() const;
  inline void set_port(::google::protobuf::uint32 value);

  // optional .Dss.Event.CarrierType carriertype = 4;
  inline bool has_carriertype() const;
  inline void clear_carriertype();
  static const int kCarriertypeFieldNumber = 4;
  inline ::Dss::Event::CarrierType carriertype() const;
  inline void set_carriertype(::Dss::Event::CarrierType value);

  // @@protoc_insertion_point(class_scope:Dss.Event.DssCltAttachWanIpOfPortNack)
 private:
  inline void set_has_clientid();
  inline void clear_has_clientid();
  inline void set_has_srvhandle();
  inline void clear_has_srvhandle();
  inline void set_has_port();
  inline void clear_has_port();
  inline void set_has_carriertype();
  inline void clear_has_carriertype();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 clientid_;
  ::google::protobuf::uint32 srvhandle_;
  ::google::protobuf::uint32 port_;
  int carriertype_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_dssevent_2eproto();
  friend void protobuf_AssignDesc_dssevent_2eproto();
  friend void protobuf_ShutdownFile_dssevent_2eproto();

  void InitAsDefaultInstance();
  static DssCltAttachWanIpOfPortNack* default_instance_;
};
// ===================================================================


// ===================================================================

// DssCltCreatClientReq

// optional string Alias = 1;
inline bool DssCltCreatClientReq::has_alias() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DssCltCreatClientReq::set_has_alias() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DssCltCreatClientReq::clear_has_alias() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DssCltCreatClientReq::clear_alias() {
  if (alias_ != &::google::protobuf::internal::kEmptyString) {
    alias_->clear();
  }
  clear_has_alias();
}
inline const ::std::string& DssCltCreatClientReq::alias() const {
  return *alias_;
}
inline void DssCltCreatClientReq::set_alias(const ::std::string& value) {
  set_has_alias();
  if (alias_ == &::google::protobuf::internal::kEmptyString) {
    alias_ = new ::std::string;
  }
  alias_->assign(value);
}
inline void DssCltCreatClientReq::set_alias(const char* value) {
  set_has_alias();
  if (alias_ == &::google::protobuf::internal::kEmptyString) {
    alias_ = new ::std::string;
  }
  alias_->assign(value);
}
inline void DssCltCreatClientReq::set_alias(const char* value, size_t size) {
  set_has_alias();
  if (alias_ == &::google::protobuf::internal::kEmptyString) {
    alias_ = new ::std::string;
  }
  alias_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DssCltCreatClientReq::mutable_alias() {
  set_has_alias();
  if (alias_ == &::google::protobuf::internal::kEmptyString) {
    alias_ = new ::std::string;
  }
  return alias_;
}
inline ::std::string* DssCltCreatClientReq::release_alias() {
  clear_has_alias();
  if (alias_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = alias_;
    alias_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DssCltCreatClientReq::set_allocated_alias(::std::string* alias) {
  if (alias_ != &::google::protobuf::internal::kEmptyString) {
    delete alias_;
  }
  if (alias) {
    set_has_alias();
    alias_ = alias;
  } else {
    clear_has_alias();
    alias_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .Dss.Event.DssObj Type = 2;
inline bool DssCltCreatClientReq::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DssCltCreatClientReq::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DssCltCreatClientReq::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DssCltCreatClientReq::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::Dss::Event::DssObj DssCltCreatClientReq::type() const {
  return static_cast< ::Dss::Event::DssObj >(type_);
}
inline void DssCltCreatClientReq::set_type(::Dss::Event::DssObj value) {
  assert(::Dss::Event::DssObj_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional string QName = 3;
inline bool DssCltCreatClientReq::has_qname() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DssCltCreatClientReq::set_has_qname() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DssCltCreatClientReq::clear_has_qname() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DssCltCreatClientReq::clear_qname() {
  if (qname_ != &::google::protobuf::internal::kEmptyString) {
    qname_->clear();
  }
  clear_has_qname();
}
inline const ::std::string& DssCltCreatClientReq::qname() const {
  return *qname_;
}
inline void DssCltCreatClientReq::set_qname(const ::std::string& value) {
  set_has_qname();
  if (qname_ == &::google::protobuf::internal::kEmptyString) {
    qname_ = new ::std::string;
  }
  qname_->assign(value);
}
inline void DssCltCreatClientReq::set_qname(const char* value) {
  set_has_qname();
  if (qname_ == &::google::protobuf::internal::kEmptyString) {
    qname_ = new ::std::string;
  }
  qname_->assign(value);
}
inline void DssCltCreatClientReq::set_qname(const char* value, size_t size) {
  set_has_qname();
  if (qname_ == &::google::protobuf::internal::kEmptyString) {
    qname_ = new ::std::string;
  }
  qname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DssCltCreatClientReq::mutable_qname() {
  set_has_qname();
  if (qname_ == &::google::protobuf::internal::kEmptyString) {
    qname_ = new ::std::string;
  }
  return qname_;
}
inline ::std::string* DssCltCreatClientReq::release_qname() {
  clear_has_qname();
  if (qname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = qname_;
    qname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DssCltCreatClientReq::set_allocated_qname(::std::string* qname) {
  if (qname_ != &::google::protobuf::internal::kEmptyString) {
    delete qname_;
  }
  if (qname) {
    set_has_qname();
    qname_ = qname;
  } else {
    clear_has_qname();
    qname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// DssCltCreatClientAck

// optional string Alias = 1;
inline bool DssCltCreatClientAck::has_alias() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DssCltCreatClientAck::set_has_alias() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DssCltCreatClientAck::clear_has_alias() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DssCltCreatClientAck::clear_alias() {
  if (alias_ != &::google::protobuf::internal::kEmptyString) {
    alias_->clear();
  }
  clear_has_alias();
}
inline const ::std::string& DssCltCreatClientAck::alias() const {
  return *alias_;
}
inline void DssCltCreatClientAck::set_alias(const ::std::string& value) {
  set_has_alias();
  if (alias_ == &::google::protobuf::internal::kEmptyString) {
    alias_ = new ::std::string;
  }
  alias_->assign(value);
}
inline void DssCltCreatClientAck::set_alias(const char* value) {
  set_has_alias();
  if (alias_ == &::google::protobuf::internal::kEmptyString) {
    alias_ = new ::std::string;
  }
  alias_->assign(value);
}
inline void DssCltCreatClientAck::set_alias(const char* value, size_t size) {
  set_has_alias();
  if (alias_ == &::google::protobuf::internal::kEmptyString) {
    alias_ = new ::std::string;
  }
  alias_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DssCltCreatClientAck::mutable_alias() {
  set_has_alias();
  if (alias_ == &::google::protobuf::internal::kEmptyString) {
    alias_ = new ::std::string;
  }
  return alias_;
}
inline ::std::string* DssCltCreatClientAck::release_alias() {
  clear_has_alias();
  if (alias_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = alias_;
    alias_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DssCltCreatClientAck::set_allocated_alias(::std::string* alias) {
  if (alias_ != &::google::protobuf::internal::kEmptyString) {
    delete alias_;
  }
  if (alias) {
    set_has_alias();
    alias_ = alias;
  } else {
    clear_has_alias();
    alias_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .Dss.Event.DssObj Type = 2;
inline bool DssCltCreatClientAck::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DssCltCreatClientAck::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DssCltCreatClientAck::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DssCltCreatClientAck::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::Dss::Event::DssObj DssCltCreatClientAck::type() const {
  return static_cast< ::Dss::Event::DssObj >(type_);
}
inline void DssCltCreatClientAck::set_type(::Dss::Event::DssObj value) {
  assert(::Dss::Event::DssObj_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional uint32 ClientId = 3;
inline bool DssCltCreatClientAck::has_clientid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DssCltCreatClientAck::set_has_clientid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DssCltCreatClientAck::clear_has_clientid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DssCltCreatClientAck::clear_clientid() {
  clientid_ = 0u;
  clear_has_clientid();
}
inline ::google::protobuf::uint32 DssCltCreatClientAck::clientid() const {
  return clientid_;
}
inline void DssCltCreatClientAck::set_clientid(::google::protobuf::uint32 value) {
  set_has_clientid();
  clientid_ = value;
}

// optional uint32 keepalivetime = 4;
inline bool DssCltCreatClientAck::has_keepalivetime() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DssCltCreatClientAck::set_has_keepalivetime() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DssCltCreatClientAck::clear_has_keepalivetime() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DssCltCreatClientAck::clear_keepalivetime() {
  keepalivetime_ = 0u;
  clear_has_keepalivetime();
}
inline ::google::protobuf::uint32 DssCltCreatClientAck::keepalivetime() const {
  return keepalivetime_;
}
inline void DssCltCreatClientAck::set_keepalivetime(::google::protobuf::uint32 value) {
  set_has_keepalivetime();
  keepalivetime_ = value;
}

// -------------------------------------------------------------------

// DssCltPing

// optional uint32 ClientId = 1;
inline bool DssCltPing::has_clientid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DssCltPing::set_has_clientid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DssCltPing::clear_has_clientid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DssCltPing::clear_clientid() {
  clientid_ = 0u;
  clear_has_clientid();
}
inline ::google::protobuf::uint32 DssCltPing::clientid() const {
  return clientid_;
}
inline void DssCltPing::set_clientid(::google::protobuf::uint32 value) {
  set_has_clientid();
  clientid_ = value;
}

// -------------------------------------------------------------------

// CltDssPong

// optional uint32 ClientId = 1;
inline bool CltDssPong::has_clientid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CltDssPong::set_has_clientid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CltDssPong::clear_has_clientid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CltDssPong::clear_clientid() {
  clientid_ = 0u;
  clear_has_clientid();
}
inline ::google::protobuf::uint32 CltDssPong::clientid() const {
  return clientid_;
}
inline void CltDssPong::set_clientid(::google::protobuf::uint32 value) {
  set_has_clientid();
  clientid_ = value;
}

// -------------------------------------------------------------------

// DssCltCreatClientNack

// optional string Alias = 1;
inline bool DssCltCreatClientNack::has_alias() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DssCltCreatClientNack::set_has_alias() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DssCltCreatClientNack::clear_has_alias() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DssCltCreatClientNack::clear_alias() {
  if (alias_ != &::google::protobuf::internal::kEmptyString) {
    alias_->clear();
  }
  clear_has_alias();
}
inline const ::std::string& DssCltCreatClientNack::alias() const {
  return *alias_;
}
inline void DssCltCreatClientNack::set_alias(const ::std::string& value) {
  set_has_alias();
  if (alias_ == &::google::protobuf::internal::kEmptyString) {
    alias_ = new ::std::string;
  }
  alias_->assign(value);
}
inline void DssCltCreatClientNack::set_alias(const char* value) {
  set_has_alias();
  if (alias_ == &::google::protobuf::internal::kEmptyString) {
    alias_ = new ::std::string;
  }
  alias_->assign(value);
}
inline void DssCltCreatClientNack::set_alias(const char* value, size_t size) {
  set_has_alias();
  if (alias_ == &::google::protobuf::internal::kEmptyString) {
    alias_ = new ::std::string;
  }
  alias_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DssCltCreatClientNack::mutable_alias() {
  set_has_alias();
  if (alias_ == &::google::protobuf::internal::kEmptyString) {
    alias_ = new ::std::string;
  }
  return alias_;
}
inline ::std::string* DssCltCreatClientNack::release_alias() {
  clear_has_alias();
  if (alias_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = alias_;
    alias_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DssCltCreatClientNack::set_allocated_alias(::std::string* alias) {
  if (alias_ != &::google::protobuf::internal::kEmptyString) {
    delete alias_;
  }
  if (alias) {
    set_has_alias();
    alias_ = alias;
  } else {
    clear_has_alias();
    alias_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .Dss.Event.DssObj Type = 2;
inline bool DssCltCreatClientNack::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DssCltCreatClientNack::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DssCltCreatClientNack::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DssCltCreatClientNack::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::Dss::Event::DssObj DssCltCreatClientNack::type() const {
  return static_cast< ::Dss::Event::DssObj >(type_);
}
inline void DssCltCreatClientNack::set_type(::Dss::Event::DssObj value) {
  assert(::Dss::Event::DssObj_IsValid(value));
  set_has_type();
  type_ = value;
}

// -------------------------------------------------------------------

// CltDssDestroyClientCmd

// optional uint32 ClientId = 1;
inline bool CltDssDestroyClientCmd::has_clientid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CltDssDestroyClientCmd::set_has_clientid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CltDssDestroyClientCmd::clear_has_clientid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CltDssDestroyClientCmd::clear_clientid() {
  clientid_ = 0u;
  clear_has_clientid();
}
inline ::google::protobuf::uint32 CltDssDestroyClientCmd::clientid() const {
  return clientid_;
}
inline void CltDssDestroyClientCmd::set_clientid(::google::protobuf::uint32 value) {
  set_has_clientid();
  clientid_ = value;
}

// -------------------------------------------------------------------

// CltDssSyncApplyLanPortReq

// optional uint32 ClientId = 1;
inline bool CltDssSyncApplyLanPortReq::has_clientid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CltDssSyncApplyLanPortReq::set_has_clientid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CltDssSyncApplyLanPortReq::clear_has_clientid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CltDssSyncApplyLanPortReq::clear_clientid() {
  clientid_ = 0u;
  clear_has_clientid();
}
inline ::google::protobuf::uint32 CltDssSyncApplyLanPortReq::clientid() const {
  return clientid_;
}
inline void CltDssSyncApplyLanPortReq::set_clientid(::google::protobuf::uint32 value) {
  set_has_clientid();
  clientid_ = value;
}

// optional string MeetingHandle = 2;
inline bool CltDssSyncApplyLanPortReq::has_meetinghandle() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CltDssSyncApplyLanPortReq::set_has_meetinghandle() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CltDssSyncApplyLanPortReq::clear_has_meetinghandle() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CltDssSyncApplyLanPortReq::clear_meetinghandle() {
  if (meetinghandle_ != &::google::protobuf::internal::kEmptyString) {
    meetinghandle_->clear();
  }
  clear_has_meetinghandle();
}
inline const ::std::string& CltDssSyncApplyLanPortReq::meetinghandle() const {
  return *meetinghandle_;
}
inline void CltDssSyncApplyLanPortReq::set_meetinghandle(const ::std::string& value) {
  set_has_meetinghandle();
  if (meetinghandle_ == &::google::protobuf::internal::kEmptyString) {
    meetinghandle_ = new ::std::string;
  }
  meetinghandle_->assign(value);
}
inline void CltDssSyncApplyLanPortReq::set_meetinghandle(const char* value) {
  set_has_meetinghandle();
  if (meetinghandle_ == &::google::protobuf::internal::kEmptyString) {
    meetinghandle_ = new ::std::string;
  }
  meetinghandle_->assign(value);
}
inline void CltDssSyncApplyLanPortReq::set_meetinghandle(const char* value, size_t size) {
  set_has_meetinghandle();
  if (meetinghandle_ == &::google::protobuf::internal::kEmptyString) {
    meetinghandle_ = new ::std::string;
  }
  meetinghandle_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CltDssSyncApplyLanPortReq::mutable_meetinghandle() {
  set_has_meetinghandle();
  if (meetinghandle_ == &::google::protobuf::internal::kEmptyString) {
    meetinghandle_ = new ::std::string;
  }
  return meetinghandle_;
}
inline ::std::string* CltDssSyncApplyLanPortReq::release_meetinghandle() {
  clear_has_meetinghandle();
  if (meetinghandle_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = meetinghandle_;
    meetinghandle_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CltDssSyncApplyLanPortReq::set_allocated_meetinghandle(::std::string* meetinghandle) {
  if (meetinghandle_ != &::google::protobuf::internal::kEmptyString) {
    delete meetinghandle_;
  }
  if (meetinghandle) {
    set_has_meetinghandle();
    meetinghandle_ = meetinghandle;
  } else {
    clear_has_meetinghandle();
    meetinghandle_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 BandWidth = 3;
inline bool CltDssSyncApplyLanPortReq::has_bandwidth() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CltDssSyncApplyLanPortReq::set_has_bandwidth() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CltDssSyncApplyLanPortReq::clear_has_bandwidth() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CltDssSyncApplyLanPortReq::clear_bandwidth() {
  bandwidth_ = 0u;
  clear_has_bandwidth();
}
inline ::google::protobuf::uint32 CltDssSyncApplyLanPortReq::bandwidth() const {
  return bandwidth_;
}
inline void CltDssSyncApplyLanPortReq::set_bandwidth(::google::protobuf::uint32 value) {
  set_has_bandwidth();
  bandwidth_ = value;
}

// repeated .Dss.Event.ApplyLanPort portdesc = 4;
inline int CltDssSyncApplyLanPortReq::portdesc_size() const {
  return portdesc_.size();
}
inline void CltDssSyncApplyLanPortReq::clear_portdesc() {
  portdesc_.Clear();
}
inline const ::Dss::Event::ApplyLanPort& CltDssSyncApplyLanPortReq::portdesc(int index) const {
  return portdesc_.Get(index);
}
inline ::Dss::Event::ApplyLanPort* CltDssSyncApplyLanPortReq::mutable_portdesc(int index) {
  return portdesc_.Mutable(index);
}
inline ::Dss::Event::ApplyLanPort* CltDssSyncApplyLanPortReq::add_portdesc() {
  return portdesc_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Dss::Event::ApplyLanPort >&
CltDssSyncApplyLanPortReq::portdesc() const {
  return portdesc_;
}
inline ::google::protobuf::RepeatedPtrField< ::Dss::Event::ApplyLanPort >*
CltDssSyncApplyLanPortReq::mutable_portdesc() {
  return &portdesc_;
}

// -------------------------------------------------------------------

// DssCltSyncApplyLanPortReply

// optional uint32 ClientId = 1;
inline bool DssCltSyncApplyLanPortReply::has_clientid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DssCltSyncApplyLanPortReply::set_has_clientid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DssCltSyncApplyLanPortReply::clear_has_clientid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DssCltSyncApplyLanPortReply::clear_clientid() {
  clientid_ = 0u;
  clear_has_clientid();
}
inline ::google::protobuf::uint32 DssCltSyncApplyLanPortReply::clientid() const {
  return clientid_;
}
inline void DssCltSyncApplyLanPortReply::set_clientid(::google::protobuf::uint32 value) {
  set_has_clientid();
  clientid_ = value;
}

// optional string MeetingHandle = 2;
inline bool DssCltSyncApplyLanPortReply::has_meetinghandle() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DssCltSyncApplyLanPortReply::set_has_meetinghandle() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DssCltSyncApplyLanPortReply::clear_has_meetinghandle() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DssCltSyncApplyLanPortReply::clear_meetinghandle() {
  if (meetinghandle_ != &::google::protobuf::internal::kEmptyString) {
    meetinghandle_->clear();
  }
  clear_has_meetinghandle();
}
inline const ::std::string& DssCltSyncApplyLanPortReply::meetinghandle() const {
  return *meetinghandle_;
}
inline void DssCltSyncApplyLanPortReply::set_meetinghandle(const ::std::string& value) {
  set_has_meetinghandle();
  if (meetinghandle_ == &::google::protobuf::internal::kEmptyString) {
    meetinghandle_ = new ::std::string;
  }
  meetinghandle_->assign(value);
}
inline void DssCltSyncApplyLanPortReply::set_meetinghandle(const char* value) {
  set_has_meetinghandle();
  if (meetinghandle_ == &::google::protobuf::internal::kEmptyString) {
    meetinghandle_ = new ::std::string;
  }
  meetinghandle_->assign(value);
}
inline void DssCltSyncApplyLanPortReply::set_meetinghandle(const char* value, size_t size) {
  set_has_meetinghandle();
  if (meetinghandle_ == &::google::protobuf::internal::kEmptyString) {
    meetinghandle_ = new ::std::string;
  }
  meetinghandle_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DssCltSyncApplyLanPortReply::mutable_meetinghandle() {
  set_has_meetinghandle();
  if (meetinghandle_ == &::google::protobuf::internal::kEmptyString) {
    meetinghandle_ = new ::std::string;
  }
  return meetinghandle_;
}
inline ::std::string* DssCltSyncApplyLanPortReply::release_meetinghandle() {
  clear_has_meetinghandle();
  if (meetinghandle_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = meetinghandle_;
    meetinghandle_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DssCltSyncApplyLanPortReply::set_allocated_meetinghandle(::std::string* meetinghandle) {
  if (meetinghandle_ != &::google::protobuf::internal::kEmptyString) {
    delete meetinghandle_;
  }
  if (meetinghandle) {
    set_has_meetinghandle();
    meetinghandle_ = meetinghandle;
  } else {
    clear_has_meetinghandle();
    meetinghandle_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 BandWidth = 3;
inline bool DssCltSyncApplyLanPortReply::has_bandwidth() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DssCltSyncApplyLanPortReply::set_has_bandwidth() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DssCltSyncApplyLanPortReply::clear_has_bandwidth() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DssCltSyncApplyLanPortReply::clear_bandwidth() {
  bandwidth_ = 0u;
  clear_has_bandwidth();
}
inline ::google::protobuf::uint32 DssCltSyncApplyLanPortReply::bandwidth() const {
  return bandwidth_;
}
inline void DssCltSyncApplyLanPortReply::set_bandwidth(::google::protobuf::uint32 value) {
  set_has_bandwidth();
  bandwidth_ = value;
}

// repeated .Dss.Event.ApplyLanPortReply reply = 4;
inline int DssCltSyncApplyLanPortReply::reply_size() const {
  return reply_.size();
}
inline void DssCltSyncApplyLanPortReply::clear_reply() {
  reply_.Clear();
}
inline const ::Dss::Event::ApplyLanPortReply& DssCltSyncApplyLanPortReply::reply(int index) const {
  return reply_.Get(index);
}
inline ::Dss::Event::ApplyLanPortReply* DssCltSyncApplyLanPortReply::mutable_reply(int index) {
  return reply_.Mutable(index);
}
inline ::Dss::Event::ApplyLanPortReply* DssCltSyncApplyLanPortReply::add_reply() {
  return reply_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Dss::Event::ApplyLanPortReply >&
DssCltSyncApplyLanPortReply::reply() const {
  return reply_;
}
inline ::google::protobuf::RepeatedPtrField< ::Dss::Event::ApplyLanPortReply >*
DssCltSyncApplyLanPortReply::mutable_reply() {
  return &reply_;
}

// -------------------------------------------------------------------

// CltDssSyncApplyConsLanPortReq

// optional uint32 ClientId = 1;
inline bool CltDssSyncApplyConsLanPortReq::has_clientid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CltDssSyncApplyConsLanPortReq::set_has_clientid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CltDssSyncApplyConsLanPortReq::clear_has_clientid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CltDssSyncApplyConsLanPortReq::clear_clientid() {
  clientid_ = 0u;
  clear_has_clientid();
}
inline ::google::protobuf::uint32 CltDssSyncApplyConsLanPortReq::clientid() const {
  return clientid_;
}
inline void CltDssSyncApplyConsLanPortReq::set_clientid(::google::protobuf::uint32 value) {
  set_has_clientid();
  clientid_ = value;
}

// optional string MeetingHandle = 2;
inline bool CltDssSyncApplyConsLanPortReq::has_meetinghandle() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CltDssSyncApplyConsLanPortReq::set_has_meetinghandle() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CltDssSyncApplyConsLanPortReq::clear_has_meetinghandle() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CltDssSyncApplyConsLanPortReq::clear_meetinghandle() {
  if (meetinghandle_ != &::google::protobuf::internal::kEmptyString) {
    meetinghandle_->clear();
  }
  clear_has_meetinghandle();
}
inline const ::std::string& CltDssSyncApplyConsLanPortReq::meetinghandle() const {
  return *meetinghandle_;
}
inline void CltDssSyncApplyConsLanPortReq::set_meetinghandle(const ::std::string& value) {
  set_has_meetinghandle();
  if (meetinghandle_ == &::google::protobuf::internal::kEmptyString) {
    meetinghandle_ = new ::std::string;
  }
  meetinghandle_->assign(value);
}
inline void CltDssSyncApplyConsLanPortReq::set_meetinghandle(const char* value) {
  set_has_meetinghandle();
  if (meetinghandle_ == &::google::protobuf::internal::kEmptyString) {
    meetinghandle_ = new ::std::string;
  }
  meetinghandle_->assign(value);
}
inline void CltDssSyncApplyConsLanPortReq::set_meetinghandle(const char* value, size_t size) {
  set_has_meetinghandle();
  if (meetinghandle_ == &::google::protobuf::internal::kEmptyString) {
    meetinghandle_ = new ::std::string;
  }
  meetinghandle_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CltDssSyncApplyConsLanPortReq::mutable_meetinghandle() {
  set_has_meetinghandle();
  if (meetinghandle_ == &::google::protobuf::internal::kEmptyString) {
    meetinghandle_ = new ::std::string;
  }
  return meetinghandle_;
}
inline ::std::string* CltDssSyncApplyConsLanPortReq::release_meetinghandle() {
  clear_has_meetinghandle();
  if (meetinghandle_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = meetinghandle_;
    meetinghandle_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CltDssSyncApplyConsLanPortReq::set_allocated_meetinghandle(::std::string* meetinghandle) {
  if (meetinghandle_ != &::google::protobuf::internal::kEmptyString) {
    delete meetinghandle_;
  }
  if (meetinghandle) {
    set_has_meetinghandle();
    meetinghandle_ = meetinghandle;
  } else {
    clear_has_meetinghandle();
    meetinghandle_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 BandWidth = 3;
inline bool CltDssSyncApplyConsLanPortReq::has_bandwidth() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CltDssSyncApplyConsLanPortReq::set_has_bandwidth() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CltDssSyncApplyConsLanPortReq::clear_has_bandwidth() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CltDssSyncApplyConsLanPortReq::clear_bandwidth() {
  bandwidth_ = 0u;
  clear_has_bandwidth();
}
inline ::google::protobuf::uint32 CltDssSyncApplyConsLanPortReq::bandwidth() const {
  return bandwidth_;
}
inline void CltDssSyncApplyConsLanPortReq::set_bandwidth(::google::protobuf::uint32 value) {
  set_has_bandwidth();
  bandwidth_ = value;
}

// optional .Dss.Event.ApplyLanPort portdesc = 4;
inline bool CltDssSyncApplyConsLanPortReq::has_portdesc() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CltDssSyncApplyConsLanPortReq::set_has_portdesc() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CltDssSyncApplyConsLanPortReq::clear_has_portdesc() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CltDssSyncApplyConsLanPortReq::clear_portdesc() {
  if (portdesc_ != NULL) portdesc_->::Dss::Event::ApplyLanPort::Clear();
  clear_has_portdesc();
}
inline const ::Dss::Event::ApplyLanPort& CltDssSyncApplyConsLanPortReq::portdesc() const {
  return portdesc_ != NULL ? *portdesc_ : *default_instance_->portdesc_;
}
inline ::Dss::Event::ApplyLanPort* CltDssSyncApplyConsLanPortReq::mutable_portdesc() {
  set_has_portdesc();
  if (portdesc_ == NULL) portdesc_ = new ::Dss::Event::ApplyLanPort;
  return portdesc_;
}
inline ::Dss::Event::ApplyLanPort* CltDssSyncApplyConsLanPortReq::release_portdesc() {
  clear_has_portdesc();
  ::Dss::Event::ApplyLanPort* temp = portdesc_;
  portdesc_ = NULL;
  return temp;
}
inline void CltDssSyncApplyConsLanPortReq::set_allocated_portdesc(::Dss::Event::ApplyLanPort* portdesc) {
  delete portdesc_;
  portdesc_ = portdesc;
  if (portdesc) {
    set_has_portdesc();
  } else {
    clear_has_portdesc();
  }
}

// optional bool ForceIp = 5;
inline bool CltDssSyncApplyConsLanPortReq::has_forceip() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CltDssSyncApplyConsLanPortReq::set_has_forceip() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CltDssSyncApplyConsLanPortReq::clear_has_forceip() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CltDssSyncApplyConsLanPortReq::clear_forceip() {
  forceip_ = false;
  clear_has_forceip();
}
inline bool CltDssSyncApplyConsLanPortReq::forceip() const {
  return forceip_;
}
inline void CltDssSyncApplyConsLanPortReq::set_forceip(bool value) {
  set_has_forceip();
  forceip_ = value;
}

// optional bool Adaptive = 6;
inline bool CltDssSyncApplyConsLanPortReq::has_adaptive() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CltDssSyncApplyConsLanPortReq::set_has_adaptive() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CltDssSyncApplyConsLanPortReq::clear_has_adaptive() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CltDssSyncApplyConsLanPortReq::clear_adaptive() {
  adaptive_ = false;
  clear_has_adaptive();
}
inline bool CltDssSyncApplyConsLanPortReq::adaptive() const {
  return adaptive_;
}
inline void CltDssSyncApplyConsLanPortReq::set_adaptive(bool value) {
  set_has_adaptive();
  adaptive_ = value;
}

// optional uint32 ConsPortNum = 7;
inline bool CltDssSyncApplyConsLanPortReq::has_consportnum() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CltDssSyncApplyConsLanPortReq::set_has_consportnum() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CltDssSyncApplyConsLanPortReq::clear_has_consportnum() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CltDssSyncApplyConsLanPortReq::clear_consportnum() {
  consportnum_ = 0u;
  clear_has_consportnum();
}
inline ::google::protobuf::uint32 CltDssSyncApplyConsLanPortReq::consportnum() const {
  return consportnum_;
}
inline void CltDssSyncApplyConsLanPortReq::set_consportnum(::google::protobuf::uint32 value) {
  set_has_consportnum();
  consportnum_ = value;
}

// -------------------------------------------------------------------

// DssCltSyncApplyConsLanPortReply

// optional uint32 ClientId = 1;
inline bool DssCltSyncApplyConsLanPortReply::has_clientid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DssCltSyncApplyConsLanPortReply::set_has_clientid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DssCltSyncApplyConsLanPortReply::clear_has_clientid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DssCltSyncApplyConsLanPortReply::clear_clientid() {
  clientid_ = 0u;
  clear_has_clientid();
}
inline ::google::protobuf::uint32 DssCltSyncApplyConsLanPortReply::clientid() const {
  return clientid_;
}
inline void DssCltSyncApplyConsLanPortReply::set_clientid(::google::protobuf::uint32 value) {
  set_has_clientid();
  clientid_ = value;
}

// optional string MeetingHandle = 2;
inline bool DssCltSyncApplyConsLanPortReply::has_meetinghandle() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DssCltSyncApplyConsLanPortReply::set_has_meetinghandle() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DssCltSyncApplyConsLanPortReply::clear_has_meetinghandle() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DssCltSyncApplyConsLanPortReply::clear_meetinghandle() {
  if (meetinghandle_ != &::google::protobuf::internal::kEmptyString) {
    meetinghandle_->clear();
  }
  clear_has_meetinghandle();
}
inline const ::std::string& DssCltSyncApplyConsLanPortReply::meetinghandle() const {
  return *meetinghandle_;
}
inline void DssCltSyncApplyConsLanPortReply::set_meetinghandle(const ::std::string& value) {
  set_has_meetinghandle();
  if (meetinghandle_ == &::google::protobuf::internal::kEmptyString) {
    meetinghandle_ = new ::std::string;
  }
  meetinghandle_->assign(value);
}
inline void DssCltSyncApplyConsLanPortReply::set_meetinghandle(const char* value) {
  set_has_meetinghandle();
  if (meetinghandle_ == &::google::protobuf::internal::kEmptyString) {
    meetinghandle_ = new ::std::string;
  }
  meetinghandle_->assign(value);
}
inline void DssCltSyncApplyConsLanPortReply::set_meetinghandle(const char* value, size_t size) {
  set_has_meetinghandle();
  if (meetinghandle_ == &::google::protobuf::internal::kEmptyString) {
    meetinghandle_ = new ::std::string;
  }
  meetinghandle_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DssCltSyncApplyConsLanPortReply::mutable_meetinghandle() {
  set_has_meetinghandle();
  if (meetinghandle_ == &::google::protobuf::internal::kEmptyString) {
    meetinghandle_ = new ::std::string;
  }
  return meetinghandle_;
}
inline ::std::string* DssCltSyncApplyConsLanPortReply::release_meetinghandle() {
  clear_has_meetinghandle();
  if (meetinghandle_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = meetinghandle_;
    meetinghandle_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DssCltSyncApplyConsLanPortReply::set_allocated_meetinghandle(::std::string* meetinghandle) {
  if (meetinghandle_ != &::google::protobuf::internal::kEmptyString) {
    delete meetinghandle_;
  }
  if (meetinghandle) {
    set_has_meetinghandle();
    meetinghandle_ = meetinghandle;
  } else {
    clear_has_meetinghandle();
    meetinghandle_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 BandWidth = 3;
inline bool DssCltSyncApplyConsLanPortReply::has_bandwidth() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DssCltSyncApplyConsLanPortReply::set_has_bandwidth() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DssCltSyncApplyConsLanPortReply::clear_has_bandwidth() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DssCltSyncApplyConsLanPortReply::clear_bandwidth() {
  bandwidth_ = 0u;
  clear_has_bandwidth();
}
inline ::google::protobuf::uint32 DssCltSyncApplyConsLanPortReply::bandwidth() const {
  return bandwidth_;
}
inline void DssCltSyncApplyConsLanPortReply::set_bandwidth(::google::protobuf::uint32 value) {
  set_has_bandwidth();
  bandwidth_ = value;
}

// optional .Dss.Event.ApplyLanPortReply reply = 4;
inline bool DssCltSyncApplyConsLanPortReply::has_reply() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DssCltSyncApplyConsLanPortReply::set_has_reply() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DssCltSyncApplyConsLanPortReply::clear_has_reply() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DssCltSyncApplyConsLanPortReply::clear_reply() {
  if (reply_ != NULL) reply_->::Dss::Event::ApplyLanPortReply::Clear();
  clear_has_reply();
}
inline const ::Dss::Event::ApplyLanPortReply& DssCltSyncApplyConsLanPortReply::reply() const {
  return reply_ != NULL ? *reply_ : *default_instance_->reply_;
}
inline ::Dss::Event::ApplyLanPortReply* DssCltSyncApplyConsLanPortReply::mutable_reply() {
  set_has_reply();
  if (reply_ == NULL) reply_ = new ::Dss::Event::ApplyLanPortReply;
  return reply_;
}
inline ::Dss::Event::ApplyLanPortReply* DssCltSyncApplyConsLanPortReply::release_reply() {
  clear_has_reply();
  ::Dss::Event::ApplyLanPortReply* temp = reply_;
  reply_ = NULL;
  return temp;
}
inline void DssCltSyncApplyConsLanPortReply::set_allocated_reply(::Dss::Event::ApplyLanPortReply* reply) {
  delete reply_;
  reply_ = reply;
  if (reply) {
    set_has_reply();
  } else {
    clear_has_reply();
  }
}

// optional bool ForceIp = 5;
inline bool DssCltSyncApplyConsLanPortReply::has_forceip() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DssCltSyncApplyConsLanPortReply::set_has_forceip() {
  _has_bits_[0] |= 0x00000010u;
}
inline void DssCltSyncApplyConsLanPortReply::clear_has_forceip() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void DssCltSyncApplyConsLanPortReply::clear_forceip() {
  forceip_ = false;
  clear_has_forceip();
}
inline bool DssCltSyncApplyConsLanPortReply::forceip() const {
  return forceip_;
}
inline void DssCltSyncApplyConsLanPortReply::set_forceip(bool value) {
  set_has_forceip();
  forceip_ = value;
}

// optional bool Adaptive = 6;
inline bool DssCltSyncApplyConsLanPortReply::has_adaptive() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void DssCltSyncApplyConsLanPortReply::set_has_adaptive() {
  _has_bits_[0] |= 0x00000020u;
}
inline void DssCltSyncApplyConsLanPortReply::clear_has_adaptive() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void DssCltSyncApplyConsLanPortReply::clear_adaptive() {
  adaptive_ = false;
  clear_has_adaptive();
}
inline bool DssCltSyncApplyConsLanPortReply::adaptive() const {
  return adaptive_;
}
inline void DssCltSyncApplyConsLanPortReply::set_adaptive(bool value) {
  set_has_adaptive();
  adaptive_ = value;
}

// optional uint32 ConsPortNum = 7;
inline bool DssCltSyncApplyConsLanPortReply::has_consportnum() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void DssCltSyncApplyConsLanPortReply::set_has_consportnum() {
  _has_bits_[0] |= 0x00000040u;
}
inline void DssCltSyncApplyConsLanPortReply::clear_has_consportnum() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void DssCltSyncApplyConsLanPortReply::clear_consportnum() {
  consportnum_ = 0u;
  clear_has_consportnum();
}
inline ::google::protobuf::uint32 DssCltSyncApplyConsLanPortReply::consportnum() const {
  return consportnum_;
}
inline void DssCltSyncApplyConsLanPortReply::set_consportnum(::google::protobuf::uint32 value) {
  set_has_consportnum();
  consportnum_ = value;
}

// -------------------------------------------------------------------

// CltDssASyncApplyConsLanPortReq

// optional uint32 ClientId = 1;
inline bool CltDssASyncApplyConsLanPortReq::has_clientid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CltDssASyncApplyConsLanPortReq::set_has_clientid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CltDssASyncApplyConsLanPortReq::clear_has_clientid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CltDssASyncApplyConsLanPortReq::clear_clientid() {
  clientid_ = 0u;
  clear_has_clientid();
}
inline ::google::protobuf::uint32 CltDssASyncApplyConsLanPortReq::clientid() const {
  return clientid_;
}
inline void CltDssASyncApplyConsLanPortReq::set_clientid(::google::protobuf::uint32 value) {
  set_has_clientid();
  clientid_ = value;
}

// optional string MeetingHandle = 2;
inline bool CltDssASyncApplyConsLanPortReq::has_meetinghandle() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CltDssASyncApplyConsLanPortReq::set_has_meetinghandle() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CltDssASyncApplyConsLanPortReq::clear_has_meetinghandle() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CltDssASyncApplyConsLanPortReq::clear_meetinghandle() {
  if (meetinghandle_ != &::google::protobuf::internal::kEmptyString) {
    meetinghandle_->clear();
  }
  clear_has_meetinghandle();
}
inline const ::std::string& CltDssASyncApplyConsLanPortReq::meetinghandle() const {
  return *meetinghandle_;
}
inline void CltDssASyncApplyConsLanPortReq::set_meetinghandle(const ::std::string& value) {
  set_has_meetinghandle();
  if (meetinghandle_ == &::google::protobuf::internal::kEmptyString) {
    meetinghandle_ = new ::std::string;
  }
  meetinghandle_->assign(value);
}
inline void CltDssASyncApplyConsLanPortReq::set_meetinghandle(const char* value) {
  set_has_meetinghandle();
  if (meetinghandle_ == &::google::protobuf::internal::kEmptyString) {
    meetinghandle_ = new ::std::string;
  }
  meetinghandle_->assign(value);
}
inline void CltDssASyncApplyConsLanPortReq::set_meetinghandle(const char* value, size_t size) {
  set_has_meetinghandle();
  if (meetinghandle_ == &::google::protobuf::internal::kEmptyString) {
    meetinghandle_ = new ::std::string;
  }
  meetinghandle_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CltDssASyncApplyConsLanPortReq::mutable_meetinghandle() {
  set_has_meetinghandle();
  if (meetinghandle_ == &::google::protobuf::internal::kEmptyString) {
    meetinghandle_ = new ::std::string;
  }
  return meetinghandle_;
}
inline ::std::string* CltDssASyncApplyConsLanPortReq::release_meetinghandle() {
  clear_has_meetinghandle();
  if (meetinghandle_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = meetinghandle_;
    meetinghandle_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CltDssASyncApplyConsLanPortReq::set_allocated_meetinghandle(::std::string* meetinghandle) {
  if (meetinghandle_ != &::google::protobuf::internal::kEmptyString) {
    delete meetinghandle_;
  }
  if (meetinghandle) {
    set_has_meetinghandle();
    meetinghandle_ = meetinghandle;
  } else {
    clear_has_meetinghandle();
    meetinghandle_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 BandWidth = 3;
inline bool CltDssASyncApplyConsLanPortReq::has_bandwidth() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CltDssASyncApplyConsLanPortReq::set_has_bandwidth() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CltDssASyncApplyConsLanPortReq::clear_has_bandwidth() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CltDssASyncApplyConsLanPortReq::clear_bandwidth() {
  bandwidth_ = 0u;
  clear_has_bandwidth();
}
inline ::google::protobuf::uint32 CltDssASyncApplyConsLanPortReq::bandwidth() const {
  return bandwidth_;
}
inline void CltDssASyncApplyConsLanPortReq::set_bandwidth(::google::protobuf::uint32 value) {
  set_has_bandwidth();
  bandwidth_ = value;
}

// optional .Dss.Event.ApplyLanPort portdesc = 4;
inline bool CltDssASyncApplyConsLanPortReq::has_portdesc() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CltDssASyncApplyConsLanPortReq::set_has_portdesc() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CltDssASyncApplyConsLanPortReq::clear_has_portdesc() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CltDssASyncApplyConsLanPortReq::clear_portdesc() {
  if (portdesc_ != NULL) portdesc_->::Dss::Event::ApplyLanPort::Clear();
  clear_has_portdesc();
}
inline const ::Dss::Event::ApplyLanPort& CltDssASyncApplyConsLanPortReq::portdesc() const {
  return portdesc_ != NULL ? *portdesc_ : *default_instance_->portdesc_;
}
inline ::Dss::Event::ApplyLanPort* CltDssASyncApplyConsLanPortReq::mutable_portdesc() {
  set_has_portdesc();
  if (portdesc_ == NULL) portdesc_ = new ::Dss::Event::ApplyLanPort;
  return portdesc_;
}
inline ::Dss::Event::ApplyLanPort* CltDssASyncApplyConsLanPortReq::release_portdesc() {
  clear_has_portdesc();
  ::Dss::Event::ApplyLanPort* temp = portdesc_;
  portdesc_ = NULL;
  return temp;
}
inline void CltDssASyncApplyConsLanPortReq::set_allocated_portdesc(::Dss::Event::ApplyLanPort* portdesc) {
  delete portdesc_;
  portdesc_ = portdesc;
  if (portdesc) {
    set_has_portdesc();
  } else {
    clear_has_portdesc();
  }
}

// optional bool ForceIp = 5;
inline bool CltDssASyncApplyConsLanPortReq::has_forceip() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CltDssASyncApplyConsLanPortReq::set_has_forceip() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CltDssASyncApplyConsLanPortReq::clear_has_forceip() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CltDssASyncApplyConsLanPortReq::clear_forceip() {
  forceip_ = false;
  clear_has_forceip();
}
inline bool CltDssASyncApplyConsLanPortReq::forceip() const {
  return forceip_;
}
inline void CltDssASyncApplyConsLanPortReq::set_forceip(bool value) {
  set_has_forceip();
  forceip_ = value;
}

// optional bool Adaptive = 6;
inline bool CltDssASyncApplyConsLanPortReq::has_adaptive() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CltDssASyncApplyConsLanPortReq::set_has_adaptive() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CltDssASyncApplyConsLanPortReq::clear_has_adaptive() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CltDssASyncApplyConsLanPortReq::clear_adaptive() {
  adaptive_ = false;
  clear_has_adaptive();
}
inline bool CltDssASyncApplyConsLanPortReq::adaptive() const {
  return adaptive_;
}
inline void CltDssASyncApplyConsLanPortReq::set_adaptive(bool value) {
  set_has_adaptive();
  adaptive_ = value;
}

// optional uint32 ConsPortNum = 7;
inline bool CltDssASyncApplyConsLanPortReq::has_consportnum() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CltDssASyncApplyConsLanPortReq::set_has_consportnum() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CltDssASyncApplyConsLanPortReq::clear_has_consportnum() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CltDssASyncApplyConsLanPortReq::clear_consportnum() {
  consportnum_ = 0u;
  clear_has_consportnum();
}
inline ::google::protobuf::uint32 CltDssASyncApplyConsLanPortReq::consportnum() const {
  return consportnum_;
}
inline void CltDssASyncApplyConsLanPortReq::set_consportnum(::google::protobuf::uint32 value) {
  set_has_consportnum();
  consportnum_ = value;
}

// -------------------------------------------------------------------

// DssCltASyncApplyConsLanPortReply

// optional uint32 ClientId = 1;
inline bool DssCltASyncApplyConsLanPortReply::has_clientid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DssCltASyncApplyConsLanPortReply::set_has_clientid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DssCltASyncApplyConsLanPortReply::clear_has_clientid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DssCltASyncApplyConsLanPortReply::clear_clientid() {
  clientid_ = 0u;
  clear_has_clientid();
}
inline ::google::protobuf::uint32 DssCltASyncApplyConsLanPortReply::clientid() const {
  return clientid_;
}
inline void DssCltASyncApplyConsLanPortReply::set_clientid(::google::protobuf::uint32 value) {
  set_has_clientid();
  clientid_ = value;
}

// optional string MeetingHandle = 2;
inline bool DssCltASyncApplyConsLanPortReply::has_meetinghandle() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DssCltASyncApplyConsLanPortReply::set_has_meetinghandle() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DssCltASyncApplyConsLanPortReply::clear_has_meetinghandle() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DssCltASyncApplyConsLanPortReply::clear_meetinghandle() {
  if (meetinghandle_ != &::google::protobuf::internal::kEmptyString) {
    meetinghandle_->clear();
  }
  clear_has_meetinghandle();
}
inline const ::std::string& DssCltASyncApplyConsLanPortReply::meetinghandle() const {
  return *meetinghandle_;
}
inline void DssCltASyncApplyConsLanPortReply::set_meetinghandle(const ::std::string& value) {
  set_has_meetinghandle();
  if (meetinghandle_ == &::google::protobuf::internal::kEmptyString) {
    meetinghandle_ = new ::std::string;
  }
  meetinghandle_->assign(value);
}
inline void DssCltASyncApplyConsLanPortReply::set_meetinghandle(const char* value) {
  set_has_meetinghandle();
  if (meetinghandle_ == &::google::protobuf::internal::kEmptyString) {
    meetinghandle_ = new ::std::string;
  }
  meetinghandle_->assign(value);
}
inline void DssCltASyncApplyConsLanPortReply::set_meetinghandle(const char* value, size_t size) {
  set_has_meetinghandle();
  if (meetinghandle_ == &::google::protobuf::internal::kEmptyString) {
    meetinghandle_ = new ::std::string;
  }
  meetinghandle_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DssCltASyncApplyConsLanPortReply::mutable_meetinghandle() {
  set_has_meetinghandle();
  if (meetinghandle_ == &::google::protobuf::internal::kEmptyString) {
    meetinghandle_ = new ::std::string;
  }
  return meetinghandle_;
}
inline ::std::string* DssCltASyncApplyConsLanPortReply::release_meetinghandle() {
  clear_has_meetinghandle();
  if (meetinghandle_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = meetinghandle_;
    meetinghandle_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DssCltASyncApplyConsLanPortReply::set_allocated_meetinghandle(::std::string* meetinghandle) {
  if (meetinghandle_ != &::google::protobuf::internal::kEmptyString) {
    delete meetinghandle_;
  }
  if (meetinghandle) {
    set_has_meetinghandle();
    meetinghandle_ = meetinghandle;
  } else {
    clear_has_meetinghandle();
    meetinghandle_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 BandWidth = 3;
inline bool DssCltASyncApplyConsLanPortReply::has_bandwidth() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DssCltASyncApplyConsLanPortReply::set_has_bandwidth() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DssCltASyncApplyConsLanPortReply::clear_has_bandwidth() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DssCltASyncApplyConsLanPortReply::clear_bandwidth() {
  bandwidth_ = 0u;
  clear_has_bandwidth();
}
inline ::google::protobuf::uint32 DssCltASyncApplyConsLanPortReply::bandwidth() const {
  return bandwidth_;
}
inline void DssCltASyncApplyConsLanPortReply::set_bandwidth(::google::protobuf::uint32 value) {
  set_has_bandwidth();
  bandwidth_ = value;
}

// optional .Dss.Event.ApplyLanPortReply reply = 4;
inline bool DssCltASyncApplyConsLanPortReply::has_reply() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DssCltASyncApplyConsLanPortReply::set_has_reply() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DssCltASyncApplyConsLanPortReply::clear_has_reply() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DssCltASyncApplyConsLanPortReply::clear_reply() {
  if (reply_ != NULL) reply_->::Dss::Event::ApplyLanPortReply::Clear();
  clear_has_reply();
}
inline const ::Dss::Event::ApplyLanPortReply& DssCltASyncApplyConsLanPortReply::reply() const {
  return reply_ != NULL ? *reply_ : *default_instance_->reply_;
}
inline ::Dss::Event::ApplyLanPortReply* DssCltASyncApplyConsLanPortReply::mutable_reply() {
  set_has_reply();
  if (reply_ == NULL) reply_ = new ::Dss::Event::ApplyLanPortReply;
  return reply_;
}
inline ::Dss::Event::ApplyLanPortReply* DssCltASyncApplyConsLanPortReply::release_reply() {
  clear_has_reply();
  ::Dss::Event::ApplyLanPortReply* temp = reply_;
  reply_ = NULL;
  return temp;
}
inline void DssCltASyncApplyConsLanPortReply::set_allocated_reply(::Dss::Event::ApplyLanPortReply* reply) {
  delete reply_;
  reply_ = reply;
  if (reply) {
    set_has_reply();
  } else {
    clear_has_reply();
  }
}

// optional bool ForceIp = 5;
inline bool DssCltASyncApplyConsLanPortReply::has_forceip() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DssCltASyncApplyConsLanPortReply::set_has_forceip() {
  _has_bits_[0] |= 0x00000010u;
}
inline void DssCltASyncApplyConsLanPortReply::clear_has_forceip() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void DssCltASyncApplyConsLanPortReply::clear_forceip() {
  forceip_ = false;
  clear_has_forceip();
}
inline bool DssCltASyncApplyConsLanPortReply::forceip() const {
  return forceip_;
}
inline void DssCltASyncApplyConsLanPortReply::set_forceip(bool value) {
  set_has_forceip();
  forceip_ = value;
}

// optional bool Adaptive = 6;
inline bool DssCltASyncApplyConsLanPortReply::has_adaptive() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void DssCltASyncApplyConsLanPortReply::set_has_adaptive() {
  _has_bits_[0] |= 0x00000020u;
}
inline void DssCltASyncApplyConsLanPortReply::clear_has_adaptive() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void DssCltASyncApplyConsLanPortReply::clear_adaptive() {
  adaptive_ = false;
  clear_has_adaptive();
}
inline bool DssCltASyncApplyConsLanPortReply::adaptive() const {
  return adaptive_;
}
inline void DssCltASyncApplyConsLanPortReply::set_adaptive(bool value) {
  set_has_adaptive();
  adaptive_ = value;
}

// optional uint32 ConsPortNum = 7;
inline bool DssCltASyncApplyConsLanPortReply::has_consportnum() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void DssCltASyncApplyConsLanPortReply::set_has_consportnum() {
  _has_bits_[0] |= 0x00000040u;
}
inline void DssCltASyncApplyConsLanPortReply::clear_has_consportnum() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void DssCltASyncApplyConsLanPortReply::clear_consportnum() {
  consportnum_ = 0u;
  clear_has_consportnum();
}
inline ::google::protobuf::uint32 DssCltASyncApplyConsLanPortReply::consportnum() const {
  return consportnum_;
}
inline void DssCltASyncApplyConsLanPortReply::set_consportnum(::google::protobuf::uint32 value) {
  set_has_consportnum();
  consportnum_ = value;
}

// -------------------------------------------------------------------

// CltDssSyncApplyWanPortReq

// optional uint32 ClientId = 1;
inline bool CltDssSyncApplyWanPortReq::has_clientid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CltDssSyncApplyWanPortReq::set_has_clientid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CltDssSyncApplyWanPortReq::clear_has_clientid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CltDssSyncApplyWanPortReq::clear_clientid() {
  clientid_ = 0u;
  clear_has_clientid();
}
inline ::google::protobuf::uint32 CltDssSyncApplyWanPortReq::clientid() const {
  return clientid_;
}
inline void CltDssSyncApplyWanPortReq::set_clientid(::google::protobuf::uint32 value) {
  set_has_clientid();
  clientid_ = value;
}

// optional string MeetingHandle = 2;
inline bool CltDssSyncApplyWanPortReq::has_meetinghandle() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CltDssSyncApplyWanPortReq::set_has_meetinghandle() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CltDssSyncApplyWanPortReq::clear_has_meetinghandle() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CltDssSyncApplyWanPortReq::clear_meetinghandle() {
  if (meetinghandle_ != &::google::protobuf::internal::kEmptyString) {
    meetinghandle_->clear();
  }
  clear_has_meetinghandle();
}
inline const ::std::string& CltDssSyncApplyWanPortReq::meetinghandle() const {
  return *meetinghandle_;
}
inline void CltDssSyncApplyWanPortReq::set_meetinghandle(const ::std::string& value) {
  set_has_meetinghandle();
  if (meetinghandle_ == &::google::protobuf::internal::kEmptyString) {
    meetinghandle_ = new ::std::string;
  }
  meetinghandle_->assign(value);
}
inline void CltDssSyncApplyWanPortReq::set_meetinghandle(const char* value) {
  set_has_meetinghandle();
  if (meetinghandle_ == &::google::protobuf::internal::kEmptyString) {
    meetinghandle_ = new ::std::string;
  }
  meetinghandle_->assign(value);
}
inline void CltDssSyncApplyWanPortReq::set_meetinghandle(const char* value, size_t size) {
  set_has_meetinghandle();
  if (meetinghandle_ == &::google::protobuf::internal::kEmptyString) {
    meetinghandle_ = new ::std::string;
  }
  meetinghandle_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CltDssSyncApplyWanPortReq::mutable_meetinghandle() {
  set_has_meetinghandle();
  if (meetinghandle_ == &::google::protobuf::internal::kEmptyString) {
    meetinghandle_ = new ::std::string;
  }
  return meetinghandle_;
}
inline ::std::string* CltDssSyncApplyWanPortReq::release_meetinghandle() {
  clear_has_meetinghandle();
  if (meetinghandle_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = meetinghandle_;
    meetinghandle_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CltDssSyncApplyWanPortReq::set_allocated_meetinghandle(::std::string* meetinghandle) {
  if (meetinghandle_ != &::google::protobuf::internal::kEmptyString) {
    delete meetinghandle_;
  }
  if (meetinghandle) {
    set_has_meetinghandle();
    meetinghandle_ = meetinghandle;
  } else {
    clear_has_meetinghandle();
    meetinghandle_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 BandWidth = 3;
inline bool CltDssSyncApplyWanPortReq::has_bandwidth() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CltDssSyncApplyWanPortReq::set_has_bandwidth() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CltDssSyncApplyWanPortReq::clear_has_bandwidth() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CltDssSyncApplyWanPortReq::clear_bandwidth() {
  bandwidth_ = 0u;
  clear_has_bandwidth();
}
inline ::google::protobuf::uint32 CltDssSyncApplyWanPortReq::bandwidth() const {
  return bandwidth_;
}
inline void CltDssSyncApplyWanPortReq::set_bandwidth(::google::protobuf::uint32 value) {
  set_has_bandwidth();
  bandwidth_ = value;
}

// repeated .Dss.Event.ApplyWanPort portdesc = 4;
inline int CltDssSyncApplyWanPortReq::portdesc_size() const {
  return portdesc_.size();
}
inline void CltDssSyncApplyWanPortReq::clear_portdesc() {
  portdesc_.Clear();
}
inline const ::Dss::Event::ApplyWanPort& CltDssSyncApplyWanPortReq::portdesc(int index) const {
  return portdesc_.Get(index);
}
inline ::Dss::Event::ApplyWanPort* CltDssSyncApplyWanPortReq::mutable_portdesc(int index) {
  return portdesc_.Mutable(index);
}
inline ::Dss::Event::ApplyWanPort* CltDssSyncApplyWanPortReq::add_portdesc() {
  return portdesc_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Dss::Event::ApplyWanPort >&
CltDssSyncApplyWanPortReq::portdesc() const {
  return portdesc_;
}
inline ::google::protobuf::RepeatedPtrField< ::Dss::Event::ApplyWanPort >*
CltDssSyncApplyWanPortReq::mutable_portdesc() {
  return &portdesc_;
}

// -------------------------------------------------------------------

// DssCltSyncApplyWanPortReply

// optional uint32 ClientId = 1;
inline bool DssCltSyncApplyWanPortReply::has_clientid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DssCltSyncApplyWanPortReply::set_has_clientid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DssCltSyncApplyWanPortReply::clear_has_clientid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DssCltSyncApplyWanPortReply::clear_clientid() {
  clientid_ = 0u;
  clear_has_clientid();
}
inline ::google::protobuf::uint32 DssCltSyncApplyWanPortReply::clientid() const {
  return clientid_;
}
inline void DssCltSyncApplyWanPortReply::set_clientid(::google::protobuf::uint32 value) {
  set_has_clientid();
  clientid_ = value;
}

// optional string MeetingHandle = 2;
inline bool DssCltSyncApplyWanPortReply::has_meetinghandle() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DssCltSyncApplyWanPortReply::set_has_meetinghandle() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DssCltSyncApplyWanPortReply::clear_has_meetinghandle() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DssCltSyncApplyWanPortReply::clear_meetinghandle() {
  if (meetinghandle_ != &::google::protobuf::internal::kEmptyString) {
    meetinghandle_->clear();
  }
  clear_has_meetinghandle();
}
inline const ::std::string& DssCltSyncApplyWanPortReply::meetinghandle() const {
  return *meetinghandle_;
}
inline void DssCltSyncApplyWanPortReply::set_meetinghandle(const ::std::string& value) {
  set_has_meetinghandle();
  if (meetinghandle_ == &::google::protobuf::internal::kEmptyString) {
    meetinghandle_ = new ::std::string;
  }
  meetinghandle_->assign(value);
}
inline void DssCltSyncApplyWanPortReply::set_meetinghandle(const char* value) {
  set_has_meetinghandle();
  if (meetinghandle_ == &::google::protobuf::internal::kEmptyString) {
    meetinghandle_ = new ::std::string;
  }
  meetinghandle_->assign(value);
}
inline void DssCltSyncApplyWanPortReply::set_meetinghandle(const char* value, size_t size) {
  set_has_meetinghandle();
  if (meetinghandle_ == &::google::protobuf::internal::kEmptyString) {
    meetinghandle_ = new ::std::string;
  }
  meetinghandle_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DssCltSyncApplyWanPortReply::mutable_meetinghandle() {
  set_has_meetinghandle();
  if (meetinghandle_ == &::google::protobuf::internal::kEmptyString) {
    meetinghandle_ = new ::std::string;
  }
  return meetinghandle_;
}
inline ::std::string* DssCltSyncApplyWanPortReply::release_meetinghandle() {
  clear_has_meetinghandle();
  if (meetinghandle_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = meetinghandle_;
    meetinghandle_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DssCltSyncApplyWanPortReply::set_allocated_meetinghandle(::std::string* meetinghandle) {
  if (meetinghandle_ != &::google::protobuf::internal::kEmptyString) {
    delete meetinghandle_;
  }
  if (meetinghandle) {
    set_has_meetinghandle();
    meetinghandle_ = meetinghandle;
  } else {
    clear_has_meetinghandle();
    meetinghandle_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 BandWidth = 3;
inline bool DssCltSyncApplyWanPortReply::has_bandwidth() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DssCltSyncApplyWanPortReply::set_has_bandwidth() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DssCltSyncApplyWanPortReply::clear_has_bandwidth() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DssCltSyncApplyWanPortReply::clear_bandwidth() {
  bandwidth_ = 0u;
  clear_has_bandwidth();
}
inline ::google::protobuf::uint32 DssCltSyncApplyWanPortReply::bandwidth() const {
  return bandwidth_;
}
inline void DssCltSyncApplyWanPortReply::set_bandwidth(::google::protobuf::uint32 value) {
  set_has_bandwidth();
  bandwidth_ = value;
}

// repeated .Dss.Event.ApplyWanPortReply reply = 4;
inline int DssCltSyncApplyWanPortReply::reply_size() const {
  return reply_.size();
}
inline void DssCltSyncApplyWanPortReply::clear_reply() {
  reply_.Clear();
}
inline const ::Dss::Event::ApplyWanPortReply& DssCltSyncApplyWanPortReply::reply(int index) const {
  return reply_.Get(index);
}
inline ::Dss::Event::ApplyWanPortReply* DssCltSyncApplyWanPortReply::mutable_reply(int index) {
  return reply_.Mutable(index);
}
inline ::Dss::Event::ApplyWanPortReply* DssCltSyncApplyWanPortReply::add_reply() {
  return reply_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Dss::Event::ApplyWanPortReply >&
DssCltSyncApplyWanPortReply::reply() const {
  return reply_;
}
inline ::google::protobuf::RepeatedPtrField< ::Dss::Event::ApplyWanPortReply >*
DssCltSyncApplyWanPortReply::mutable_reply() {
  return &reply_;
}

// -------------------------------------------------------------------

// CltDssASyncApplyLanPortReq

// optional uint32 ClientId = 1;
inline bool CltDssASyncApplyLanPortReq::has_clientid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CltDssASyncApplyLanPortReq::set_has_clientid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CltDssASyncApplyLanPortReq::clear_has_clientid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CltDssASyncApplyLanPortReq::clear_clientid() {
  clientid_ = 0u;
  clear_has_clientid();
}
inline ::google::protobuf::uint32 CltDssASyncApplyLanPortReq::clientid() const {
  return clientid_;
}
inline void CltDssASyncApplyLanPortReq::set_clientid(::google::protobuf::uint32 value) {
  set_has_clientid();
  clientid_ = value;
}

// optional string MeetingHandle = 2;
inline bool CltDssASyncApplyLanPortReq::has_meetinghandle() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CltDssASyncApplyLanPortReq::set_has_meetinghandle() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CltDssASyncApplyLanPortReq::clear_has_meetinghandle() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CltDssASyncApplyLanPortReq::clear_meetinghandle() {
  if (meetinghandle_ != &::google::protobuf::internal::kEmptyString) {
    meetinghandle_->clear();
  }
  clear_has_meetinghandle();
}
inline const ::std::string& CltDssASyncApplyLanPortReq::meetinghandle() const {
  return *meetinghandle_;
}
inline void CltDssASyncApplyLanPortReq::set_meetinghandle(const ::std::string& value) {
  set_has_meetinghandle();
  if (meetinghandle_ == &::google::protobuf::internal::kEmptyString) {
    meetinghandle_ = new ::std::string;
  }
  meetinghandle_->assign(value);
}
inline void CltDssASyncApplyLanPortReq::set_meetinghandle(const char* value) {
  set_has_meetinghandle();
  if (meetinghandle_ == &::google::protobuf::internal::kEmptyString) {
    meetinghandle_ = new ::std::string;
  }
  meetinghandle_->assign(value);
}
inline void CltDssASyncApplyLanPortReq::set_meetinghandle(const char* value, size_t size) {
  set_has_meetinghandle();
  if (meetinghandle_ == &::google::protobuf::internal::kEmptyString) {
    meetinghandle_ = new ::std::string;
  }
  meetinghandle_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CltDssASyncApplyLanPortReq::mutable_meetinghandle() {
  set_has_meetinghandle();
  if (meetinghandle_ == &::google::protobuf::internal::kEmptyString) {
    meetinghandle_ = new ::std::string;
  }
  return meetinghandle_;
}
inline ::std::string* CltDssASyncApplyLanPortReq::release_meetinghandle() {
  clear_has_meetinghandle();
  if (meetinghandle_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = meetinghandle_;
    meetinghandle_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CltDssASyncApplyLanPortReq::set_allocated_meetinghandle(::std::string* meetinghandle) {
  if (meetinghandle_ != &::google::protobuf::internal::kEmptyString) {
    delete meetinghandle_;
  }
  if (meetinghandle) {
    set_has_meetinghandle();
    meetinghandle_ = meetinghandle;
  } else {
    clear_has_meetinghandle();
    meetinghandle_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 BandWidth = 3;
inline bool CltDssASyncApplyLanPortReq::has_bandwidth() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CltDssASyncApplyLanPortReq::set_has_bandwidth() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CltDssASyncApplyLanPortReq::clear_has_bandwidth() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CltDssASyncApplyLanPortReq::clear_bandwidth() {
  bandwidth_ = 0u;
  clear_has_bandwidth();
}
inline ::google::protobuf::uint32 CltDssASyncApplyLanPortReq::bandwidth() const {
  return bandwidth_;
}
inline void CltDssASyncApplyLanPortReq::set_bandwidth(::google::protobuf::uint32 value) {
  set_has_bandwidth();
  bandwidth_ = value;
}

// repeated .Dss.Event.ApplyLanPort portdesc = 4;
inline int CltDssASyncApplyLanPortReq::portdesc_size() const {
  return portdesc_.size();
}
inline void CltDssASyncApplyLanPortReq::clear_portdesc() {
  portdesc_.Clear();
}
inline const ::Dss::Event::ApplyLanPort& CltDssASyncApplyLanPortReq::portdesc(int index) const {
  return portdesc_.Get(index);
}
inline ::Dss::Event::ApplyLanPort* CltDssASyncApplyLanPortReq::mutable_portdesc(int index) {
  return portdesc_.Mutable(index);
}
inline ::Dss::Event::ApplyLanPort* CltDssASyncApplyLanPortReq::add_portdesc() {
  return portdesc_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Dss::Event::ApplyLanPort >&
CltDssASyncApplyLanPortReq::portdesc() const {
  return portdesc_;
}
inline ::google::protobuf::RepeatedPtrField< ::Dss::Event::ApplyLanPort >*
CltDssASyncApplyLanPortReq::mutable_portdesc() {
  return &portdesc_;
}

// -------------------------------------------------------------------

// DssCltASyncApplyLanPortReply

// optional uint32 ClientId = 1;
inline bool DssCltASyncApplyLanPortReply::has_clientid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DssCltASyncApplyLanPortReply::set_has_clientid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DssCltASyncApplyLanPortReply::clear_has_clientid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DssCltASyncApplyLanPortReply::clear_clientid() {
  clientid_ = 0u;
  clear_has_clientid();
}
inline ::google::protobuf::uint32 DssCltASyncApplyLanPortReply::clientid() const {
  return clientid_;
}
inline void DssCltASyncApplyLanPortReply::set_clientid(::google::protobuf::uint32 value) {
  set_has_clientid();
  clientid_ = value;
}

// optional string MeetingHandle = 2;
inline bool DssCltASyncApplyLanPortReply::has_meetinghandle() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DssCltASyncApplyLanPortReply::set_has_meetinghandle() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DssCltASyncApplyLanPortReply::clear_has_meetinghandle() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DssCltASyncApplyLanPortReply::clear_meetinghandle() {
  if (meetinghandle_ != &::google::protobuf::internal::kEmptyString) {
    meetinghandle_->clear();
  }
  clear_has_meetinghandle();
}
inline const ::std::string& DssCltASyncApplyLanPortReply::meetinghandle() const {
  return *meetinghandle_;
}
inline void DssCltASyncApplyLanPortReply::set_meetinghandle(const ::std::string& value) {
  set_has_meetinghandle();
  if (meetinghandle_ == &::google::protobuf::internal::kEmptyString) {
    meetinghandle_ = new ::std::string;
  }
  meetinghandle_->assign(value);
}
inline void DssCltASyncApplyLanPortReply::set_meetinghandle(const char* value) {
  set_has_meetinghandle();
  if (meetinghandle_ == &::google::protobuf::internal::kEmptyString) {
    meetinghandle_ = new ::std::string;
  }
  meetinghandle_->assign(value);
}
inline void DssCltASyncApplyLanPortReply::set_meetinghandle(const char* value, size_t size) {
  set_has_meetinghandle();
  if (meetinghandle_ == &::google::protobuf::internal::kEmptyString) {
    meetinghandle_ = new ::std::string;
  }
  meetinghandle_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DssCltASyncApplyLanPortReply::mutable_meetinghandle() {
  set_has_meetinghandle();
  if (meetinghandle_ == &::google::protobuf::internal::kEmptyString) {
    meetinghandle_ = new ::std::string;
  }
  return meetinghandle_;
}
inline ::std::string* DssCltASyncApplyLanPortReply::release_meetinghandle() {
  clear_has_meetinghandle();
  if (meetinghandle_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = meetinghandle_;
    meetinghandle_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DssCltASyncApplyLanPortReply::set_allocated_meetinghandle(::std::string* meetinghandle) {
  if (meetinghandle_ != &::google::protobuf::internal::kEmptyString) {
    delete meetinghandle_;
  }
  if (meetinghandle) {
    set_has_meetinghandle();
    meetinghandle_ = meetinghandle;
  } else {
    clear_has_meetinghandle();
    meetinghandle_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 BandWidth = 3;
inline bool DssCltASyncApplyLanPortReply::has_bandwidth() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DssCltASyncApplyLanPortReply::set_has_bandwidth() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DssCltASyncApplyLanPortReply::clear_has_bandwidth() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DssCltASyncApplyLanPortReply::clear_bandwidth() {
  bandwidth_ = 0u;
  clear_has_bandwidth();
}
inline ::google::protobuf::uint32 DssCltASyncApplyLanPortReply::bandwidth() const {
  return bandwidth_;
}
inline void DssCltASyncApplyLanPortReply::set_bandwidth(::google::protobuf::uint32 value) {
  set_has_bandwidth();
  bandwidth_ = value;
}

// repeated .Dss.Event.ApplyLanPortReply reply = 4;
inline int DssCltASyncApplyLanPortReply::reply_size() const {
  return reply_.size();
}
inline void DssCltASyncApplyLanPortReply::clear_reply() {
  reply_.Clear();
}
inline const ::Dss::Event::ApplyLanPortReply& DssCltASyncApplyLanPortReply::reply(int index) const {
  return reply_.Get(index);
}
inline ::Dss::Event::ApplyLanPortReply* DssCltASyncApplyLanPortReply::mutable_reply(int index) {
  return reply_.Mutable(index);
}
inline ::Dss::Event::ApplyLanPortReply* DssCltASyncApplyLanPortReply::add_reply() {
  return reply_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Dss::Event::ApplyLanPortReply >&
DssCltASyncApplyLanPortReply::reply() const {
  return reply_;
}
inline ::google::protobuf::RepeatedPtrField< ::Dss::Event::ApplyLanPortReply >*
DssCltASyncApplyLanPortReply::mutable_reply() {
  return &reply_;
}

// -------------------------------------------------------------------

// CltDssASyncApplyWanPortReq

// optional uint32 ClientId = 1;
inline bool CltDssASyncApplyWanPortReq::has_clientid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CltDssASyncApplyWanPortReq::set_has_clientid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CltDssASyncApplyWanPortReq::clear_has_clientid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CltDssASyncApplyWanPortReq::clear_clientid() {
  clientid_ = 0u;
  clear_has_clientid();
}
inline ::google::protobuf::uint32 CltDssASyncApplyWanPortReq::clientid() const {
  return clientid_;
}
inline void CltDssASyncApplyWanPortReq::set_clientid(::google::protobuf::uint32 value) {
  set_has_clientid();
  clientid_ = value;
}

// optional string MeetingHandle = 2;
inline bool CltDssASyncApplyWanPortReq::has_meetinghandle() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CltDssASyncApplyWanPortReq::set_has_meetinghandle() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CltDssASyncApplyWanPortReq::clear_has_meetinghandle() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CltDssASyncApplyWanPortReq::clear_meetinghandle() {
  if (meetinghandle_ != &::google::protobuf::internal::kEmptyString) {
    meetinghandle_->clear();
  }
  clear_has_meetinghandle();
}
inline const ::std::string& CltDssASyncApplyWanPortReq::meetinghandle() const {
  return *meetinghandle_;
}
inline void CltDssASyncApplyWanPortReq::set_meetinghandle(const ::std::string& value) {
  set_has_meetinghandle();
  if (meetinghandle_ == &::google::protobuf::internal::kEmptyString) {
    meetinghandle_ = new ::std::string;
  }
  meetinghandle_->assign(value);
}
inline void CltDssASyncApplyWanPortReq::set_meetinghandle(const char* value) {
  set_has_meetinghandle();
  if (meetinghandle_ == &::google::protobuf::internal::kEmptyString) {
    meetinghandle_ = new ::std::string;
  }
  meetinghandle_->assign(value);
}
inline void CltDssASyncApplyWanPortReq::set_meetinghandle(const char* value, size_t size) {
  set_has_meetinghandle();
  if (meetinghandle_ == &::google::protobuf::internal::kEmptyString) {
    meetinghandle_ = new ::std::string;
  }
  meetinghandle_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CltDssASyncApplyWanPortReq::mutable_meetinghandle() {
  set_has_meetinghandle();
  if (meetinghandle_ == &::google::protobuf::internal::kEmptyString) {
    meetinghandle_ = new ::std::string;
  }
  return meetinghandle_;
}
inline ::std::string* CltDssASyncApplyWanPortReq::release_meetinghandle() {
  clear_has_meetinghandle();
  if (meetinghandle_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = meetinghandle_;
    meetinghandle_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CltDssASyncApplyWanPortReq::set_allocated_meetinghandle(::std::string* meetinghandle) {
  if (meetinghandle_ != &::google::protobuf::internal::kEmptyString) {
    delete meetinghandle_;
  }
  if (meetinghandle) {
    set_has_meetinghandle();
    meetinghandle_ = meetinghandle;
  } else {
    clear_has_meetinghandle();
    meetinghandle_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 BandWidth = 3;
inline bool CltDssASyncApplyWanPortReq::has_bandwidth() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CltDssASyncApplyWanPortReq::set_has_bandwidth() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CltDssASyncApplyWanPortReq::clear_has_bandwidth() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CltDssASyncApplyWanPortReq::clear_bandwidth() {
  bandwidth_ = 0u;
  clear_has_bandwidth();
}
inline ::google::protobuf::uint32 CltDssASyncApplyWanPortReq::bandwidth() const {
  return bandwidth_;
}
inline void CltDssASyncApplyWanPortReq::set_bandwidth(::google::protobuf::uint32 value) {
  set_has_bandwidth();
  bandwidth_ = value;
}

// repeated .Dss.Event.ApplyWanPort portdesc = 4;
inline int CltDssASyncApplyWanPortReq::portdesc_size() const {
  return portdesc_.size();
}
inline void CltDssASyncApplyWanPortReq::clear_portdesc() {
  portdesc_.Clear();
}
inline const ::Dss::Event::ApplyWanPort& CltDssASyncApplyWanPortReq::portdesc(int index) const {
  return portdesc_.Get(index);
}
inline ::Dss::Event::ApplyWanPort* CltDssASyncApplyWanPortReq::mutable_portdesc(int index) {
  return portdesc_.Mutable(index);
}
inline ::Dss::Event::ApplyWanPort* CltDssASyncApplyWanPortReq::add_portdesc() {
  return portdesc_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Dss::Event::ApplyWanPort >&
CltDssASyncApplyWanPortReq::portdesc() const {
  return portdesc_;
}
inline ::google::protobuf::RepeatedPtrField< ::Dss::Event::ApplyWanPort >*
CltDssASyncApplyWanPortReq::mutable_portdesc() {
  return &portdesc_;
}

// -------------------------------------------------------------------

// DssCltASyncApplyWanPortReply

// optional uint32 ClientId = 1;
inline bool DssCltASyncApplyWanPortReply::has_clientid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DssCltASyncApplyWanPortReply::set_has_clientid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DssCltASyncApplyWanPortReply::clear_has_clientid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DssCltASyncApplyWanPortReply::clear_clientid() {
  clientid_ = 0u;
  clear_has_clientid();
}
inline ::google::protobuf::uint32 DssCltASyncApplyWanPortReply::clientid() const {
  return clientid_;
}
inline void DssCltASyncApplyWanPortReply::set_clientid(::google::protobuf::uint32 value) {
  set_has_clientid();
  clientid_ = value;
}

// optional string MeetingHandle = 2;
inline bool DssCltASyncApplyWanPortReply::has_meetinghandle() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DssCltASyncApplyWanPortReply::set_has_meetinghandle() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DssCltASyncApplyWanPortReply::clear_has_meetinghandle() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DssCltASyncApplyWanPortReply::clear_meetinghandle() {
  if (meetinghandle_ != &::google::protobuf::internal::kEmptyString) {
    meetinghandle_->clear();
  }
  clear_has_meetinghandle();
}
inline const ::std::string& DssCltASyncApplyWanPortReply::meetinghandle() const {
  return *meetinghandle_;
}
inline void DssCltASyncApplyWanPortReply::set_meetinghandle(const ::std::string& value) {
  set_has_meetinghandle();
  if (meetinghandle_ == &::google::protobuf::internal::kEmptyString) {
    meetinghandle_ = new ::std::string;
  }
  meetinghandle_->assign(value);
}
inline void DssCltASyncApplyWanPortReply::set_meetinghandle(const char* value) {
  set_has_meetinghandle();
  if (meetinghandle_ == &::google::protobuf::internal::kEmptyString) {
    meetinghandle_ = new ::std::string;
  }
  meetinghandle_->assign(value);
}
inline void DssCltASyncApplyWanPortReply::set_meetinghandle(const char* value, size_t size) {
  set_has_meetinghandle();
  if (meetinghandle_ == &::google::protobuf::internal::kEmptyString) {
    meetinghandle_ = new ::std::string;
  }
  meetinghandle_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DssCltASyncApplyWanPortReply::mutable_meetinghandle() {
  set_has_meetinghandle();
  if (meetinghandle_ == &::google::protobuf::internal::kEmptyString) {
    meetinghandle_ = new ::std::string;
  }
  return meetinghandle_;
}
inline ::std::string* DssCltASyncApplyWanPortReply::release_meetinghandle() {
  clear_has_meetinghandle();
  if (meetinghandle_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = meetinghandle_;
    meetinghandle_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DssCltASyncApplyWanPortReply::set_allocated_meetinghandle(::std::string* meetinghandle) {
  if (meetinghandle_ != &::google::protobuf::internal::kEmptyString) {
    delete meetinghandle_;
  }
  if (meetinghandle) {
    set_has_meetinghandle();
    meetinghandle_ = meetinghandle;
  } else {
    clear_has_meetinghandle();
    meetinghandle_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 BandWidth = 3;
inline bool DssCltASyncApplyWanPortReply::has_bandwidth() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DssCltASyncApplyWanPortReply::set_has_bandwidth() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DssCltASyncApplyWanPortReply::clear_has_bandwidth() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DssCltASyncApplyWanPortReply::clear_bandwidth() {
  bandwidth_ = 0u;
  clear_has_bandwidth();
}
inline ::google::protobuf::uint32 DssCltASyncApplyWanPortReply::bandwidth() const {
  return bandwidth_;
}
inline void DssCltASyncApplyWanPortReply::set_bandwidth(::google::protobuf::uint32 value) {
  set_has_bandwidth();
  bandwidth_ = value;
}

// repeated .Dss.Event.ApplyWanPortReply reply = 4;
inline int DssCltASyncApplyWanPortReply::reply_size() const {
  return reply_.size();
}
inline void DssCltASyncApplyWanPortReply::clear_reply() {
  reply_.Clear();
}
inline const ::Dss::Event::ApplyWanPortReply& DssCltASyncApplyWanPortReply::reply(int index) const {
  return reply_.Get(index);
}
inline ::Dss::Event::ApplyWanPortReply* DssCltASyncApplyWanPortReply::mutable_reply(int index) {
  return reply_.Mutable(index);
}
inline ::Dss::Event::ApplyWanPortReply* DssCltASyncApplyWanPortReply::add_reply() {
  return reply_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Dss::Event::ApplyWanPortReply >&
DssCltASyncApplyWanPortReply::reply() const {
  return reply_;
}
inline ::google::protobuf::RepeatedPtrField< ::Dss::Event::ApplyWanPortReply >*
DssCltASyncApplyWanPortReply::mutable_reply() {
  return &reply_;
}

// -------------------------------------------------------------------

// CltDssReleasePortCmd

// optional uint32 ClientId = 1;
inline bool CltDssReleasePortCmd::has_clientid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CltDssReleasePortCmd::set_has_clientid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CltDssReleasePortCmd::clear_has_clientid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CltDssReleasePortCmd::clear_clientid() {
  clientid_ = 0u;
  clear_has_clientid();
}
inline ::google::protobuf::uint32 CltDssReleasePortCmd::clientid() const {
  return clientid_;
}
inline void CltDssReleasePortCmd::set_clientid(::google::protobuf::uint32 value) {
  set_has_clientid();
  clientid_ = value;
}

// optional .Dss.Event.DssNetAddr Address = 2;
inline bool CltDssReleasePortCmd::has_address() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CltDssReleasePortCmd::set_has_address() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CltDssReleasePortCmd::clear_has_address() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CltDssReleasePortCmd::clear_address() {
  if (address_ != NULL) address_->::Dss::Event::DssNetAddr::Clear();
  clear_has_address();
}
inline const ::Dss::Event::DssNetAddr& CltDssReleasePortCmd::address() const {
  return address_ != NULL ? *address_ : *default_instance_->address_;
}
inline ::Dss::Event::DssNetAddr* CltDssReleasePortCmd::mutable_address() {
  set_has_address();
  if (address_ == NULL) address_ = new ::Dss::Event::DssNetAddr;
  return address_;
}
inline ::Dss::Event::DssNetAddr* CltDssReleasePortCmd::release_address() {
  clear_has_address();
  ::Dss::Event::DssNetAddr* temp = address_;
  address_ = NULL;
  return temp;
}
inline void CltDssReleasePortCmd::set_allocated_address(::Dss::Event::DssNetAddr* address) {
  delete address_;
  address_ = address;
  if (address) {
    set_has_address();
  } else {
    clear_has_address();
  }
}

// -------------------------------------------------------------------

// CltDssAddBridgeReq

// optional uint32 ClientId = 1;
inline bool CltDssAddBridgeReq::has_clientid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CltDssAddBridgeReq::set_has_clientid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CltDssAddBridgeReq::clear_has_clientid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CltDssAddBridgeReq::clear_clientid() {
  clientid_ = 0u;
  clear_has_clientid();
}
inline ::google::protobuf::uint32 CltDssAddBridgeReq::clientid() const {
  return clientid_;
}
inline void CltDssAddBridgeReq::set_clientid(::google::protobuf::uint32 value) {
  set_has_clientid();
  clientid_ = value;
}

// optional .Dss.Event.DssNetAddr RcvAddr = 2;
inline bool CltDssAddBridgeReq::has_rcvaddr() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CltDssAddBridgeReq::set_has_rcvaddr() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CltDssAddBridgeReq::clear_has_rcvaddr() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CltDssAddBridgeReq::clear_rcvaddr() {
  if (rcvaddr_ != NULL) rcvaddr_->::Dss::Event::DssNetAddr::Clear();
  clear_has_rcvaddr();
}
inline const ::Dss::Event::DssNetAddr& CltDssAddBridgeReq::rcvaddr() const {
  return rcvaddr_ != NULL ? *rcvaddr_ : *default_instance_->rcvaddr_;
}
inline ::Dss::Event::DssNetAddr* CltDssAddBridgeReq::mutable_rcvaddr() {
  set_has_rcvaddr();
  if (rcvaddr_ == NULL) rcvaddr_ = new ::Dss::Event::DssNetAddr;
  return rcvaddr_;
}
inline ::Dss::Event::DssNetAddr* CltDssAddBridgeReq::release_rcvaddr() {
  clear_has_rcvaddr();
  ::Dss::Event::DssNetAddr* temp = rcvaddr_;
  rcvaddr_ = NULL;
  return temp;
}
inline void CltDssAddBridgeReq::set_allocated_rcvaddr(::Dss::Event::DssNetAddr* rcvaddr) {
  delete rcvaddr_;
  rcvaddr_ = rcvaddr;
  if (rcvaddr) {
    set_has_rcvaddr();
  } else {
    clear_has_rcvaddr();
  }
}

// optional uint32 StartServerHandle = 3;
inline bool CltDssAddBridgeReq::has_startserverhandle() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CltDssAddBridgeReq::set_has_startserverhandle() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CltDssAddBridgeReq::clear_has_startserverhandle() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CltDssAddBridgeReq::clear_startserverhandle() {
  startserverhandle_ = 0u;
  clear_has_startserverhandle();
}
inline ::google::protobuf::uint32 CltDssAddBridgeReq::startserverhandle() const {
  return startserverhandle_;
}
inline void CltDssAddBridgeReq::set_startserverhandle(::google::protobuf::uint32 value) {
  set_has_startserverhandle();
  startserverhandle_ = value;
}

// optional bool forceip = 4;
inline bool CltDssAddBridgeReq::has_forceip() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CltDssAddBridgeReq::set_has_forceip() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CltDssAddBridgeReq::clear_has_forceip() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CltDssAddBridgeReq::clear_forceip() {
  forceip_ = false;
  clear_has_forceip();
}
inline bool CltDssAddBridgeReq::forceip() const {
  return forceip_;
}
inline void CltDssAddBridgeReq::set_forceip(bool value) {
  set_has_forceip();
  forceip_ = value;
}

// -------------------------------------------------------------------

// DssCltAddBridgeAck

// optional uint32 ClientId = 1;
inline bool DssCltAddBridgeAck::has_clientid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DssCltAddBridgeAck::set_has_clientid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DssCltAddBridgeAck::clear_has_clientid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DssCltAddBridgeAck::clear_clientid() {
  clientid_ = 0u;
  clear_has_clientid();
}
inline ::google::protobuf::uint32 DssCltAddBridgeAck::clientid() const {
  return clientid_;
}
inline void DssCltAddBridgeAck::set_clientid(::google::protobuf::uint32 value) {
  set_has_clientid();
  clientid_ = value;
}

// optional .Dss.Event.DssNetAddr RcvAddr = 2;
inline bool DssCltAddBridgeAck::has_rcvaddr() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DssCltAddBridgeAck::set_has_rcvaddr() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DssCltAddBridgeAck::clear_has_rcvaddr() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DssCltAddBridgeAck::clear_rcvaddr() {
  if (rcvaddr_ != NULL) rcvaddr_->::Dss::Event::DssNetAddr::Clear();
  clear_has_rcvaddr();
}
inline const ::Dss::Event::DssNetAddr& DssCltAddBridgeAck::rcvaddr() const {
  return rcvaddr_ != NULL ? *rcvaddr_ : *default_instance_->rcvaddr_;
}
inline ::Dss::Event::DssNetAddr* DssCltAddBridgeAck::mutable_rcvaddr() {
  set_has_rcvaddr();
  if (rcvaddr_ == NULL) rcvaddr_ = new ::Dss::Event::DssNetAddr;
  return rcvaddr_;
}
inline ::Dss::Event::DssNetAddr* DssCltAddBridgeAck::release_rcvaddr() {
  clear_has_rcvaddr();
  ::Dss::Event::DssNetAddr* temp = rcvaddr_;
  rcvaddr_ = NULL;
  return temp;
}
inline void DssCltAddBridgeAck::set_allocated_rcvaddr(::Dss::Event::DssNetAddr* rcvaddr) {
  delete rcvaddr_;
  rcvaddr_ = rcvaddr;
  if (rcvaddr) {
    set_has_rcvaddr();
  } else {
    clear_has_rcvaddr();
  }
}

// optional uint32 StartServerHandle = 3;
inline bool DssCltAddBridgeAck::has_startserverhandle() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DssCltAddBridgeAck::set_has_startserverhandle() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DssCltAddBridgeAck::clear_has_startserverhandle() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DssCltAddBridgeAck::clear_startserverhandle() {
  startserverhandle_ = 0u;
  clear_has_startserverhandle();
}
inline ::google::protobuf::uint32 DssCltAddBridgeAck::startserverhandle() const {
  return startserverhandle_;
}
inline void DssCltAddBridgeAck::set_startserverhandle(::google::protobuf::uint32 value) {
  set_has_startserverhandle();
  startserverhandle_ = value;
}

// optional uint32 BridgeHandle = 4;
inline bool DssCltAddBridgeAck::has_bridgehandle() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DssCltAddBridgeAck::set_has_bridgehandle() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DssCltAddBridgeAck::clear_has_bridgehandle() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DssCltAddBridgeAck::clear_bridgehandle() {
  bridgehandle_ = 0u;
  clear_has_bridgehandle();
}
inline ::google::protobuf::uint32 DssCltAddBridgeAck::bridgehandle() const {
  return bridgehandle_;
}
inline void DssCltAddBridgeAck::set_bridgehandle(::google::protobuf::uint32 value) {
  set_has_bridgehandle();
  bridgehandle_ = value;
}

// -------------------------------------------------------------------

// DssCltAddBridgeNack

// optional uint32 ClientId = 1;
inline bool DssCltAddBridgeNack::has_clientid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DssCltAddBridgeNack::set_has_clientid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DssCltAddBridgeNack::clear_has_clientid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DssCltAddBridgeNack::clear_clientid() {
  clientid_ = 0u;
  clear_has_clientid();
}
inline ::google::protobuf::uint32 DssCltAddBridgeNack::clientid() const {
  return clientid_;
}
inline void DssCltAddBridgeNack::set_clientid(::google::protobuf::uint32 value) {
  set_has_clientid();
  clientid_ = value;
}

// optional .Dss.Event.DssNetAddr RcvAddr = 2;
inline bool DssCltAddBridgeNack::has_rcvaddr() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DssCltAddBridgeNack::set_has_rcvaddr() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DssCltAddBridgeNack::clear_has_rcvaddr() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DssCltAddBridgeNack::clear_rcvaddr() {
  if (rcvaddr_ != NULL) rcvaddr_->::Dss::Event::DssNetAddr::Clear();
  clear_has_rcvaddr();
}
inline const ::Dss::Event::DssNetAddr& DssCltAddBridgeNack::rcvaddr() const {
  return rcvaddr_ != NULL ? *rcvaddr_ : *default_instance_->rcvaddr_;
}
inline ::Dss::Event::DssNetAddr* DssCltAddBridgeNack::mutable_rcvaddr() {
  set_has_rcvaddr();
  if (rcvaddr_ == NULL) rcvaddr_ = new ::Dss::Event::DssNetAddr;
  return rcvaddr_;
}
inline ::Dss::Event::DssNetAddr* DssCltAddBridgeNack::release_rcvaddr() {
  clear_has_rcvaddr();
  ::Dss::Event::DssNetAddr* temp = rcvaddr_;
  rcvaddr_ = NULL;
  return temp;
}
inline void DssCltAddBridgeNack::set_allocated_rcvaddr(::Dss::Event::DssNetAddr* rcvaddr) {
  delete rcvaddr_;
  rcvaddr_ = rcvaddr;
  if (rcvaddr) {
    set_has_rcvaddr();
  } else {
    clear_has_rcvaddr();
  }
}

// optional uint32 StartServerHandle = 3;
inline bool DssCltAddBridgeNack::has_startserverhandle() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DssCltAddBridgeNack::set_has_startserverhandle() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DssCltAddBridgeNack::clear_has_startserverhandle() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DssCltAddBridgeNack::clear_startserverhandle() {
  startserverhandle_ = 0u;
  clear_has_startserverhandle();
}
inline ::google::protobuf::uint32 DssCltAddBridgeNack::startserverhandle() const {
  return startserverhandle_;
}
inline void DssCltAddBridgeNack::set_startserverhandle(::google::protobuf::uint32 value) {
  set_has_startserverhandle();
  startserverhandle_ = value;
}

// -------------------------------------------------------------------

// CltDssRemoveBridgeCmd

// optional uint32 ClientId = 1;
inline bool CltDssRemoveBridgeCmd::has_clientid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CltDssRemoveBridgeCmd::set_has_clientid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CltDssRemoveBridgeCmd::clear_has_clientid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CltDssRemoveBridgeCmd::clear_clientid() {
  clientid_ = 0u;
  clear_has_clientid();
}
inline ::google::protobuf::uint32 CltDssRemoveBridgeCmd::clientid() const {
  return clientid_;
}
inline void CltDssRemoveBridgeCmd::set_clientid(::google::protobuf::uint32 value) {
  set_has_clientid();
  clientid_ = value;
}

// optional uint32 BridgeHandle = 2;
inline bool CltDssRemoveBridgeCmd::has_bridgehandle() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CltDssRemoveBridgeCmd::set_has_bridgehandle() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CltDssRemoveBridgeCmd::clear_has_bridgehandle() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CltDssRemoveBridgeCmd::clear_bridgehandle() {
  bridgehandle_ = 0u;
  clear_has_bridgehandle();
}
inline ::google::protobuf::uint32 CltDssRemoveBridgeCmd::bridgehandle() const {
  return bridgehandle_;
}
inline void CltDssRemoveBridgeCmd::set_bridgehandle(::google::protobuf::uint32 value) {
  set_has_bridgehandle();
  bridgehandle_ = value;
}

// -------------------------------------------------------------------

// CltDssSendToBridgeReq

// optional uint32 ClientId = 1;
inline bool CltDssSendToBridgeReq::has_clientid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CltDssSendToBridgeReq::set_has_clientid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CltDssSendToBridgeReq::clear_has_clientid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CltDssSendToBridgeReq::clear_clientid() {
  clientid_ = 0u;
  clear_has_clientid();
}
inline ::google::protobuf::uint32 CltDssSendToBridgeReq::clientid() const {
  return clientid_;
}
inline void CltDssSendToBridgeReq::set_clientid(::google::protobuf::uint32 value) {
  set_has_clientid();
  clientid_ = value;
}

// optional uint32 BridgeHandle = 2;
inline bool CltDssSendToBridgeReq::has_bridgehandle() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CltDssSendToBridgeReq::set_has_bridgehandle() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CltDssSendToBridgeReq::clear_has_bridgehandle() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CltDssSendToBridgeReq::clear_bridgehandle() {
  bridgehandle_ = 0u;
  clear_has_bridgehandle();
}
inline ::google::protobuf::uint32 CltDssSendToBridgeReq::bridgehandle() const {
  return bridgehandle_;
}
inline void CltDssSendToBridgeReq::set_bridgehandle(::google::protobuf::uint32 value) {
  set_has_bridgehandle();
  bridgehandle_ = value;
}

// optional .Dss.Event.DssNetAddr RcvAddr = 3;
inline bool CltDssSendToBridgeReq::has_rcvaddr() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CltDssSendToBridgeReq::set_has_rcvaddr() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CltDssSendToBridgeReq::clear_has_rcvaddr() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CltDssSendToBridgeReq::clear_rcvaddr() {
  if (rcvaddr_ != NULL) rcvaddr_->::Dss::Event::DssNetAddr::Clear();
  clear_has_rcvaddr();
}
inline const ::Dss::Event::DssNetAddr& CltDssSendToBridgeReq::rcvaddr() const {
  return rcvaddr_ != NULL ? *rcvaddr_ : *default_instance_->rcvaddr_;
}
inline ::Dss::Event::DssNetAddr* CltDssSendToBridgeReq::mutable_rcvaddr() {
  set_has_rcvaddr();
  if (rcvaddr_ == NULL) rcvaddr_ = new ::Dss::Event::DssNetAddr;
  return rcvaddr_;
}
inline ::Dss::Event::DssNetAddr* CltDssSendToBridgeReq::release_rcvaddr() {
  clear_has_rcvaddr();
  ::Dss::Event::DssNetAddr* temp = rcvaddr_;
  rcvaddr_ = NULL;
  return temp;
}
inline void CltDssSendToBridgeReq::set_allocated_rcvaddr(::Dss::Event::DssNetAddr* rcvaddr) {
  delete rcvaddr_;
  rcvaddr_ = rcvaddr;
  if (rcvaddr) {
    set_has_rcvaddr();
  } else {
    clear_has_rcvaddr();
  }
}

// -------------------------------------------------------------------

// DssCltSendToBridgeAck

// optional uint32 ClientId = 1;
inline bool DssCltSendToBridgeAck::has_clientid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DssCltSendToBridgeAck::set_has_clientid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DssCltSendToBridgeAck::clear_has_clientid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DssCltSendToBridgeAck::clear_clientid() {
  clientid_ = 0u;
  clear_has_clientid();
}
inline ::google::protobuf::uint32 DssCltSendToBridgeAck::clientid() const {
  return clientid_;
}
inline void DssCltSendToBridgeAck::set_clientid(::google::protobuf::uint32 value) {
  set_has_clientid();
  clientid_ = value;
}

// optional uint32 BridgeHandle = 2;
inline bool DssCltSendToBridgeAck::has_bridgehandle() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DssCltSendToBridgeAck::set_has_bridgehandle() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DssCltSendToBridgeAck::clear_has_bridgehandle() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DssCltSendToBridgeAck::clear_bridgehandle() {
  bridgehandle_ = 0u;
  clear_has_bridgehandle();
}
inline ::google::protobuf::uint32 DssCltSendToBridgeAck::bridgehandle() const {
  return bridgehandle_;
}
inline void DssCltSendToBridgeAck::set_bridgehandle(::google::protobuf::uint32 value) {
  set_has_bridgehandle();
  bridgehandle_ = value;
}

// optional .Dss.Event.DssNetAddr RcvAddr = 3;
inline bool DssCltSendToBridgeAck::has_rcvaddr() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DssCltSendToBridgeAck::set_has_rcvaddr() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DssCltSendToBridgeAck::clear_has_rcvaddr() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DssCltSendToBridgeAck::clear_rcvaddr() {
  if (rcvaddr_ != NULL) rcvaddr_->::Dss::Event::DssNetAddr::Clear();
  clear_has_rcvaddr();
}
inline const ::Dss::Event::DssNetAddr& DssCltSendToBridgeAck::rcvaddr() const {
  return rcvaddr_ != NULL ? *rcvaddr_ : *default_instance_->rcvaddr_;
}
inline ::Dss::Event::DssNetAddr* DssCltSendToBridgeAck::mutable_rcvaddr() {
  set_has_rcvaddr();
  if (rcvaddr_ == NULL) rcvaddr_ = new ::Dss::Event::DssNetAddr;
  return rcvaddr_;
}
inline ::Dss::Event::DssNetAddr* DssCltSendToBridgeAck::release_rcvaddr() {
  clear_has_rcvaddr();
  ::Dss::Event::DssNetAddr* temp = rcvaddr_;
  rcvaddr_ = NULL;
  return temp;
}
inline void DssCltSendToBridgeAck::set_allocated_rcvaddr(::Dss::Event::DssNetAddr* rcvaddr) {
  delete rcvaddr_;
  rcvaddr_ = rcvaddr;
  if (rcvaddr) {
    set_has_rcvaddr();
  } else {
    clear_has_rcvaddr();
  }
}

// -------------------------------------------------------------------

// DssCltSendToBridgeNack

// optional uint32 ClientId = 1;
inline bool DssCltSendToBridgeNack::has_clientid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DssCltSendToBridgeNack::set_has_clientid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DssCltSendToBridgeNack::clear_has_clientid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DssCltSendToBridgeNack::clear_clientid() {
  clientid_ = 0u;
  clear_has_clientid();
}
inline ::google::protobuf::uint32 DssCltSendToBridgeNack::clientid() const {
  return clientid_;
}
inline void DssCltSendToBridgeNack::set_clientid(::google::protobuf::uint32 value) {
  set_has_clientid();
  clientid_ = value;
}

// optional uint32 BridgeHandle = 2;
inline bool DssCltSendToBridgeNack::has_bridgehandle() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DssCltSendToBridgeNack::set_has_bridgehandle() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DssCltSendToBridgeNack::clear_has_bridgehandle() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DssCltSendToBridgeNack::clear_bridgehandle() {
  bridgehandle_ = 0u;
  clear_has_bridgehandle();
}
inline ::google::protobuf::uint32 DssCltSendToBridgeNack::bridgehandle() const {
  return bridgehandle_;
}
inline void DssCltSendToBridgeNack::set_bridgehandle(::google::protobuf::uint32 value) {
  set_has_bridgehandle();
  bridgehandle_ = value;
}

// optional .Dss.Event.DssNetAddr RcvAddr = 3;
inline bool DssCltSendToBridgeNack::has_rcvaddr() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DssCltSendToBridgeNack::set_has_rcvaddr() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DssCltSendToBridgeNack::clear_has_rcvaddr() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DssCltSendToBridgeNack::clear_rcvaddr() {
  if (rcvaddr_ != NULL) rcvaddr_->::Dss::Event::DssNetAddr::Clear();
  clear_has_rcvaddr();
}
inline const ::Dss::Event::DssNetAddr& DssCltSendToBridgeNack::rcvaddr() const {
  return rcvaddr_ != NULL ? *rcvaddr_ : *default_instance_->rcvaddr_;
}
inline ::Dss::Event::DssNetAddr* DssCltSendToBridgeNack::mutable_rcvaddr() {
  set_has_rcvaddr();
  if (rcvaddr_ == NULL) rcvaddr_ = new ::Dss::Event::DssNetAddr;
  return rcvaddr_;
}
inline ::Dss::Event::DssNetAddr* DssCltSendToBridgeNack::release_rcvaddr() {
  clear_has_rcvaddr();
  ::Dss::Event::DssNetAddr* temp = rcvaddr_;
  rcvaddr_ = NULL;
  return temp;
}
inline void DssCltSendToBridgeNack::set_allocated_rcvaddr(::Dss::Event::DssNetAddr* rcvaddr) {
  delete rcvaddr_;
  rcvaddr_ = rcvaddr;
  if (rcvaddr) {
    set_has_rcvaddr();
  } else {
    clear_has_rcvaddr();
  }
}

// -------------------------------------------------------------------

// CltDssStopSendToBridgeCmd

// optional uint32 ClientId = 1;
inline bool CltDssStopSendToBridgeCmd::has_clientid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CltDssStopSendToBridgeCmd::set_has_clientid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CltDssStopSendToBridgeCmd::clear_has_clientid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CltDssStopSendToBridgeCmd::clear_clientid() {
  clientid_ = 0u;
  clear_has_clientid();
}
inline ::google::protobuf::uint32 CltDssStopSendToBridgeCmd::clientid() const {
  return clientid_;
}
inline void CltDssStopSendToBridgeCmd::set_clientid(::google::protobuf::uint32 value) {
  set_has_clientid();
  clientid_ = value;
}

// optional uint32 BridgeHandle = 2;
inline bool CltDssStopSendToBridgeCmd::has_bridgehandle() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CltDssStopSendToBridgeCmd::set_has_bridgehandle() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CltDssStopSendToBridgeCmd::clear_has_bridgehandle() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CltDssStopSendToBridgeCmd::clear_bridgehandle() {
  bridgehandle_ = 0u;
  clear_has_bridgehandle();
}
inline ::google::protobuf::uint32 CltDssStopSendToBridgeCmd::bridgehandle() const {
  return bridgehandle_;
}
inline void CltDssStopSendToBridgeCmd::set_bridgehandle(::google::protobuf::uint32 value) {
  set_has_bridgehandle();
  bridgehandle_ = value;
}

// optional .Dss.Event.DssNetAddr RcvAddr = 3;
inline bool CltDssStopSendToBridgeCmd::has_rcvaddr() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CltDssStopSendToBridgeCmd::set_has_rcvaddr() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CltDssStopSendToBridgeCmd::clear_has_rcvaddr() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CltDssStopSendToBridgeCmd::clear_rcvaddr() {
  if (rcvaddr_ != NULL) rcvaddr_->::Dss::Event::DssNetAddr::Clear();
  clear_has_rcvaddr();
}
inline const ::Dss::Event::DssNetAddr& CltDssStopSendToBridgeCmd::rcvaddr() const {
  return rcvaddr_ != NULL ? *rcvaddr_ : *default_instance_->rcvaddr_;
}
inline ::Dss::Event::DssNetAddr* CltDssStopSendToBridgeCmd::mutable_rcvaddr() {
  set_has_rcvaddr();
  if (rcvaddr_ == NULL) rcvaddr_ = new ::Dss::Event::DssNetAddr;
  return rcvaddr_;
}
inline ::Dss::Event::DssNetAddr* CltDssStopSendToBridgeCmd::release_rcvaddr() {
  clear_has_rcvaddr();
  ::Dss::Event::DssNetAddr* temp = rcvaddr_;
  rcvaddr_ = NULL;
  return temp;
}
inline void CltDssStopSendToBridgeCmd::set_allocated_rcvaddr(::Dss::Event::DssNetAddr* rcvaddr) {
  delete rcvaddr_;
  rcvaddr_ = rcvaddr;
  if (rcvaddr) {
    set_has_rcvaddr();
  } else {
    clear_has_rcvaddr();
  }
}

// -------------------------------------------------------------------

// CltDssReceiveFromBridgeReq

// optional uint32 ClientId = 1;
inline bool CltDssReceiveFromBridgeReq::has_clientid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CltDssReceiveFromBridgeReq::set_has_clientid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CltDssReceiveFromBridgeReq::clear_has_clientid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CltDssReceiveFromBridgeReq::clear_clientid() {
  clientid_ = 0u;
  clear_has_clientid();
}
inline ::google::protobuf::uint32 CltDssReceiveFromBridgeReq::clientid() const {
  return clientid_;
}
inline void CltDssReceiveFromBridgeReq::set_clientid(::google::protobuf::uint32 value) {
  set_has_clientid();
  clientid_ = value;
}

// optional uint32 BridgeHandle = 2;
inline bool CltDssReceiveFromBridgeReq::has_bridgehandle() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CltDssReceiveFromBridgeReq::set_has_bridgehandle() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CltDssReceiveFromBridgeReq::clear_has_bridgehandle() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CltDssReceiveFromBridgeReq::clear_bridgehandle() {
  bridgehandle_ = 0u;
  clear_has_bridgehandle();
}
inline ::google::protobuf::uint32 CltDssReceiveFromBridgeReq::bridgehandle() const {
  return bridgehandle_;
}
inline void CltDssReceiveFromBridgeReq::set_bridgehandle(::google::protobuf::uint32 value) {
  set_has_bridgehandle();
  bridgehandle_ = value;
}

// optional uint64 DstEpId = 3;
inline bool CltDssReceiveFromBridgeReq::has_dstepid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CltDssReceiveFromBridgeReq::set_has_dstepid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CltDssReceiveFromBridgeReq::clear_has_dstepid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CltDssReceiveFromBridgeReq::clear_dstepid() {
  dstepid_ = GOOGLE_ULONGLONG(0);
  clear_has_dstepid();
}
inline ::google::protobuf::uint64 CltDssReceiveFromBridgeReq::dstepid() const {
  return dstepid_;
}
inline void CltDssReceiveFromBridgeReq::set_dstepid(::google::protobuf::uint64 value) {
  set_has_dstepid();
  dstepid_ = value;
}

// optional .Dss.Event.DssNetAddr DstAddr = 4;
inline bool CltDssReceiveFromBridgeReq::has_dstaddr() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CltDssReceiveFromBridgeReq::set_has_dstaddr() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CltDssReceiveFromBridgeReq::clear_has_dstaddr() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CltDssReceiveFromBridgeReq::clear_dstaddr() {
  if (dstaddr_ != NULL) dstaddr_->::Dss::Event::DssNetAddr::Clear();
  clear_has_dstaddr();
}
inline const ::Dss::Event::DssNetAddr& CltDssReceiveFromBridgeReq::dstaddr() const {
  return dstaddr_ != NULL ? *dstaddr_ : *default_instance_->dstaddr_;
}
inline ::Dss::Event::DssNetAddr* CltDssReceiveFromBridgeReq::mutable_dstaddr() {
  set_has_dstaddr();
  if (dstaddr_ == NULL) dstaddr_ = new ::Dss::Event::DssNetAddr;
  return dstaddr_;
}
inline ::Dss::Event::DssNetAddr* CltDssReceiveFromBridgeReq::release_dstaddr() {
  clear_has_dstaddr();
  ::Dss::Event::DssNetAddr* temp = dstaddr_;
  dstaddr_ = NULL;
  return temp;
}
inline void CltDssReceiveFromBridgeReq::set_allocated_dstaddr(::Dss::Event::DssNetAddr* dstaddr) {
  delete dstaddr_;
  dstaddr_ = dstaddr;
  if (dstaddr) {
    set_has_dstaddr();
  } else {
    clear_has_dstaddr();
  }
}

// -------------------------------------------------------------------

// DssCltReceiveFromBridgeAck

// optional uint32 ClientId = 1;
inline bool DssCltReceiveFromBridgeAck::has_clientid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DssCltReceiveFromBridgeAck::set_has_clientid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DssCltReceiveFromBridgeAck::clear_has_clientid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DssCltReceiveFromBridgeAck::clear_clientid() {
  clientid_ = 0u;
  clear_has_clientid();
}
inline ::google::protobuf::uint32 DssCltReceiveFromBridgeAck::clientid() const {
  return clientid_;
}
inline void DssCltReceiveFromBridgeAck::set_clientid(::google::protobuf::uint32 value) {
  set_has_clientid();
  clientid_ = value;
}

// optional uint32 BridgeHandle = 2;
inline bool DssCltReceiveFromBridgeAck::has_bridgehandle() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DssCltReceiveFromBridgeAck::set_has_bridgehandle() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DssCltReceiveFromBridgeAck::clear_has_bridgehandle() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DssCltReceiveFromBridgeAck::clear_bridgehandle() {
  bridgehandle_ = 0u;
  clear_has_bridgehandle();
}
inline ::google::protobuf::uint32 DssCltReceiveFromBridgeAck::bridgehandle() const {
  return bridgehandle_;
}
inline void DssCltReceiveFromBridgeAck::set_bridgehandle(::google::protobuf::uint32 value) {
  set_has_bridgehandle();
  bridgehandle_ = value;
}

// optional uint64 DstEpId = 3;
inline bool DssCltReceiveFromBridgeAck::has_dstepid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DssCltReceiveFromBridgeAck::set_has_dstepid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DssCltReceiveFromBridgeAck::clear_has_dstepid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DssCltReceiveFromBridgeAck::clear_dstepid() {
  dstepid_ = GOOGLE_ULONGLONG(0);
  clear_has_dstepid();
}
inline ::google::protobuf::uint64 DssCltReceiveFromBridgeAck::dstepid() const {
  return dstepid_;
}
inline void DssCltReceiveFromBridgeAck::set_dstepid(::google::protobuf::uint64 value) {
  set_has_dstepid();
  dstepid_ = value;
}

// optional .Dss.Event.DssNetAddr DstAddr = 4;
inline bool DssCltReceiveFromBridgeAck::has_dstaddr() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DssCltReceiveFromBridgeAck::set_has_dstaddr() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DssCltReceiveFromBridgeAck::clear_has_dstaddr() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DssCltReceiveFromBridgeAck::clear_dstaddr() {
  if (dstaddr_ != NULL) dstaddr_->::Dss::Event::DssNetAddr::Clear();
  clear_has_dstaddr();
}
inline const ::Dss::Event::DssNetAddr& DssCltReceiveFromBridgeAck::dstaddr() const {
  return dstaddr_ != NULL ? *dstaddr_ : *default_instance_->dstaddr_;
}
inline ::Dss::Event::DssNetAddr* DssCltReceiveFromBridgeAck::mutable_dstaddr() {
  set_has_dstaddr();
  if (dstaddr_ == NULL) dstaddr_ = new ::Dss::Event::DssNetAddr;
  return dstaddr_;
}
inline ::Dss::Event::DssNetAddr* DssCltReceiveFromBridgeAck::release_dstaddr() {
  clear_has_dstaddr();
  ::Dss::Event::DssNetAddr* temp = dstaddr_;
  dstaddr_ = NULL;
  return temp;
}
inline void DssCltReceiveFromBridgeAck::set_allocated_dstaddr(::Dss::Event::DssNetAddr* dstaddr) {
  delete dstaddr_;
  dstaddr_ = dstaddr;
  if (dstaddr) {
    set_has_dstaddr();
  } else {
    clear_has_dstaddr();
  }
}

// -------------------------------------------------------------------

// DssCltReceiveFromBridgeNack

// optional uint32 ClientId = 1;
inline bool DssCltReceiveFromBridgeNack::has_clientid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DssCltReceiveFromBridgeNack::set_has_clientid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DssCltReceiveFromBridgeNack::clear_has_clientid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DssCltReceiveFromBridgeNack::clear_clientid() {
  clientid_ = 0u;
  clear_has_clientid();
}
inline ::google::protobuf::uint32 DssCltReceiveFromBridgeNack::clientid() const {
  return clientid_;
}
inline void DssCltReceiveFromBridgeNack::set_clientid(::google::protobuf::uint32 value) {
  set_has_clientid();
  clientid_ = value;
}

// optional uint32 BridgeHandle = 2;
inline bool DssCltReceiveFromBridgeNack::has_bridgehandle() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DssCltReceiveFromBridgeNack::set_has_bridgehandle() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DssCltReceiveFromBridgeNack::clear_has_bridgehandle() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DssCltReceiveFromBridgeNack::clear_bridgehandle() {
  bridgehandle_ = 0u;
  clear_has_bridgehandle();
}
inline ::google::protobuf::uint32 DssCltReceiveFromBridgeNack::bridgehandle() const {
  return bridgehandle_;
}
inline void DssCltReceiveFromBridgeNack::set_bridgehandle(::google::protobuf::uint32 value) {
  set_has_bridgehandle();
  bridgehandle_ = value;
}

// optional uint64 DstEpId = 3;
inline bool DssCltReceiveFromBridgeNack::has_dstepid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DssCltReceiveFromBridgeNack::set_has_dstepid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DssCltReceiveFromBridgeNack::clear_has_dstepid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DssCltReceiveFromBridgeNack::clear_dstepid() {
  dstepid_ = GOOGLE_ULONGLONG(0);
  clear_has_dstepid();
}
inline ::google::protobuf::uint64 DssCltReceiveFromBridgeNack::dstepid() const {
  return dstepid_;
}
inline void DssCltReceiveFromBridgeNack::set_dstepid(::google::protobuf::uint64 value) {
  set_has_dstepid();
  dstepid_ = value;
}

// optional .Dss.Event.DssNetAddr DstAddr = 4;
inline bool DssCltReceiveFromBridgeNack::has_dstaddr() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DssCltReceiveFromBridgeNack::set_has_dstaddr() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DssCltReceiveFromBridgeNack::clear_has_dstaddr() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DssCltReceiveFromBridgeNack::clear_dstaddr() {
  if (dstaddr_ != NULL) dstaddr_->::Dss::Event::DssNetAddr::Clear();
  clear_has_dstaddr();
}
inline const ::Dss::Event::DssNetAddr& DssCltReceiveFromBridgeNack::dstaddr() const {
  return dstaddr_ != NULL ? *dstaddr_ : *default_instance_->dstaddr_;
}
inline ::Dss::Event::DssNetAddr* DssCltReceiveFromBridgeNack::mutable_dstaddr() {
  set_has_dstaddr();
  if (dstaddr_ == NULL) dstaddr_ = new ::Dss::Event::DssNetAddr;
  return dstaddr_;
}
inline ::Dss::Event::DssNetAddr* DssCltReceiveFromBridgeNack::release_dstaddr() {
  clear_has_dstaddr();
  ::Dss::Event::DssNetAddr* temp = dstaddr_;
  dstaddr_ = NULL;
  return temp;
}
inline void DssCltReceiveFromBridgeNack::set_allocated_dstaddr(::Dss::Event::DssNetAddr* dstaddr) {
  delete dstaddr_;
  dstaddr_ = dstaddr;
  if (dstaddr) {
    set_has_dstaddr();
  } else {
    clear_has_dstaddr();
  }
}

// -------------------------------------------------------------------

// CltDssStopReceiveFromBridgeCmd

// optional uint32 ClientId = 1;
inline bool CltDssStopReceiveFromBridgeCmd::has_clientid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CltDssStopReceiveFromBridgeCmd::set_has_clientid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CltDssStopReceiveFromBridgeCmd::clear_has_clientid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CltDssStopReceiveFromBridgeCmd::clear_clientid() {
  clientid_ = 0u;
  clear_has_clientid();
}
inline ::google::protobuf::uint32 CltDssStopReceiveFromBridgeCmd::clientid() const {
  return clientid_;
}
inline void CltDssStopReceiveFromBridgeCmd::set_clientid(::google::protobuf::uint32 value) {
  set_has_clientid();
  clientid_ = value;
}

// optional uint32 BridgeHandle = 2;
inline bool CltDssStopReceiveFromBridgeCmd::has_bridgehandle() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CltDssStopReceiveFromBridgeCmd::set_has_bridgehandle() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CltDssStopReceiveFromBridgeCmd::clear_has_bridgehandle() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CltDssStopReceiveFromBridgeCmd::clear_bridgehandle() {
  bridgehandle_ = 0u;
  clear_has_bridgehandle();
}
inline ::google::protobuf::uint32 CltDssStopReceiveFromBridgeCmd::bridgehandle() const {
  return bridgehandle_;
}
inline void CltDssStopReceiveFromBridgeCmd::set_bridgehandle(::google::protobuf::uint32 value) {
  set_has_bridgehandle();
  bridgehandle_ = value;
}

// optional .Dss.Event.DssNetAddr MapAddr = 3;
inline bool CltDssStopReceiveFromBridgeCmd::has_mapaddr() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CltDssStopReceiveFromBridgeCmd::set_has_mapaddr() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CltDssStopReceiveFromBridgeCmd::clear_has_mapaddr() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CltDssStopReceiveFromBridgeCmd::clear_mapaddr() {
  if (mapaddr_ != NULL) mapaddr_->::Dss::Event::DssNetAddr::Clear();
  clear_has_mapaddr();
}
inline const ::Dss::Event::DssNetAddr& CltDssStopReceiveFromBridgeCmd::mapaddr() const {
  return mapaddr_ != NULL ? *mapaddr_ : *default_instance_->mapaddr_;
}
inline ::Dss::Event::DssNetAddr* CltDssStopReceiveFromBridgeCmd::mutable_mapaddr() {
  set_has_mapaddr();
  if (mapaddr_ == NULL) mapaddr_ = new ::Dss::Event::DssNetAddr;
  return mapaddr_;
}
inline ::Dss::Event::DssNetAddr* CltDssStopReceiveFromBridgeCmd::release_mapaddr() {
  clear_has_mapaddr();
  ::Dss::Event::DssNetAddr* temp = mapaddr_;
  mapaddr_ = NULL;
  return temp;
}
inline void CltDssStopReceiveFromBridgeCmd::set_allocated_mapaddr(::Dss::Event::DssNetAddr* mapaddr) {
  delete mapaddr_;
  mapaddr_ = mapaddr;
  if (mapaddr) {
    set_has_mapaddr();
  } else {
    clear_has_mapaddr();
  }
}

// optional uint64 DstEpId = 4;
inline bool CltDssStopReceiveFromBridgeCmd::has_dstepid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CltDssStopReceiveFromBridgeCmd::set_has_dstepid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CltDssStopReceiveFromBridgeCmd::clear_has_dstepid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CltDssStopReceiveFromBridgeCmd::clear_dstepid() {
  dstepid_ = GOOGLE_ULONGLONG(0);
  clear_has_dstepid();
}
inline ::google::protobuf::uint64 CltDssStopReceiveFromBridgeCmd::dstepid() const {
  return dstepid_;
}
inline void CltDssStopReceiveFromBridgeCmd::set_dstepid(::google::protobuf::uint64 value) {
  set_has_dstepid();
  dstepid_ = value;
}

// optional .Dss.Event.DssNetAddr DstAddr = 5;
inline bool CltDssStopReceiveFromBridgeCmd::has_dstaddr() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CltDssStopReceiveFromBridgeCmd::set_has_dstaddr() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CltDssStopReceiveFromBridgeCmd::clear_has_dstaddr() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CltDssStopReceiveFromBridgeCmd::clear_dstaddr() {
  if (dstaddr_ != NULL) dstaddr_->::Dss::Event::DssNetAddr::Clear();
  clear_has_dstaddr();
}
inline const ::Dss::Event::DssNetAddr& CltDssStopReceiveFromBridgeCmd::dstaddr() const {
  return dstaddr_ != NULL ? *dstaddr_ : *default_instance_->dstaddr_;
}
inline ::Dss::Event::DssNetAddr* CltDssStopReceiveFromBridgeCmd::mutable_dstaddr() {
  set_has_dstaddr();
  if (dstaddr_ == NULL) dstaddr_ = new ::Dss::Event::DssNetAddr;
  return dstaddr_;
}
inline ::Dss::Event::DssNetAddr* CltDssStopReceiveFromBridgeCmd::release_dstaddr() {
  clear_has_dstaddr();
  ::Dss::Event::DssNetAddr* temp = dstaddr_;
  dstaddr_ = NULL;
  return temp;
}
inline void CltDssStopReceiveFromBridgeCmd::set_allocated_dstaddr(::Dss::Event::DssNetAddr* dstaddr) {
  delete dstaddr_;
  dstaddr_ = dstaddr;
  if (dstaddr) {
    set_has_dstaddr();
  } else {
    clear_has_dstaddr();
  }
}

// -------------------------------------------------------------------

// CltDssAddSwitchReq

// optional uint32 ClientId = 1;
inline bool CltDssAddSwitchReq::has_clientid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CltDssAddSwitchReq::set_has_clientid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CltDssAddSwitchReq::clear_has_clientid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CltDssAddSwitchReq::clear_clientid() {
  clientid_ = 0u;
  clear_has_clientid();
}
inline ::google::protobuf::uint32 CltDssAddSwitchReq::clientid() const {
  return clientid_;
}
inline void CltDssAddSwitchReq::set_clientid(::google::protobuf::uint32 value) {
  set_has_clientid();
  clientid_ = value;
}

// optional uint64 DstEpId = 2;
inline bool CltDssAddSwitchReq::has_dstepid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CltDssAddSwitchReq::set_has_dstepid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CltDssAddSwitchReq::clear_has_dstepid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CltDssAddSwitchReq::clear_dstepid() {
  dstepid_ = GOOGLE_ULONGLONG(0);
  clear_has_dstepid();
}
inline ::google::protobuf::uint64 CltDssAddSwitchReq::dstepid() const {
  return dstepid_;
}
inline void CltDssAddSwitchReq::set_dstepid(::google::protobuf::uint64 value) {
  set_has_dstepid();
  dstepid_ = value;
}

// optional .Dss.Event.DssNetAddr DstAddr = 3;
inline bool CltDssAddSwitchReq::has_dstaddr() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CltDssAddSwitchReq::set_has_dstaddr() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CltDssAddSwitchReq::clear_has_dstaddr() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CltDssAddSwitchReq::clear_dstaddr() {
  if (dstaddr_ != NULL) dstaddr_->::Dss::Event::DssNetAddr::Clear();
  clear_has_dstaddr();
}
inline const ::Dss::Event::DssNetAddr& CltDssAddSwitchReq::dstaddr() const {
  return dstaddr_ != NULL ? *dstaddr_ : *default_instance_->dstaddr_;
}
inline ::Dss::Event::DssNetAddr* CltDssAddSwitchReq::mutable_dstaddr() {
  set_has_dstaddr();
  if (dstaddr_ == NULL) dstaddr_ = new ::Dss::Event::DssNetAddr;
  return dstaddr_;
}
inline ::Dss::Event::DssNetAddr* CltDssAddSwitchReq::release_dstaddr() {
  clear_has_dstaddr();
  ::Dss::Event::DssNetAddr* temp = dstaddr_;
  dstaddr_ = NULL;
  return temp;
}
inline void CltDssAddSwitchReq::set_allocated_dstaddr(::Dss::Event::DssNetAddr* dstaddr) {
  delete dstaddr_;
  dstaddr_ = dstaddr;
  if (dstaddr) {
    set_has_dstaddr();
  } else {
    clear_has_dstaddr();
  }
}

// optional .Dss.Event.DssNetAddr RcvAddr = 4;
inline bool CltDssAddSwitchReq::has_rcvaddr() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CltDssAddSwitchReq::set_has_rcvaddr() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CltDssAddSwitchReq::clear_has_rcvaddr() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CltDssAddSwitchReq::clear_rcvaddr() {
  if (rcvaddr_ != NULL) rcvaddr_->::Dss::Event::DssNetAddr::Clear();
  clear_has_rcvaddr();
}
inline const ::Dss::Event::DssNetAddr& CltDssAddSwitchReq::rcvaddr() const {
  return rcvaddr_ != NULL ? *rcvaddr_ : *default_instance_->rcvaddr_;
}
inline ::Dss::Event::DssNetAddr* CltDssAddSwitchReq::mutable_rcvaddr() {
  set_has_rcvaddr();
  if (rcvaddr_ == NULL) rcvaddr_ = new ::Dss::Event::DssNetAddr;
  return rcvaddr_;
}
inline ::Dss::Event::DssNetAddr* CltDssAddSwitchReq::release_rcvaddr() {
  clear_has_rcvaddr();
  ::Dss::Event::DssNetAddr* temp = rcvaddr_;
  rcvaddr_ = NULL;
  return temp;
}
inline void CltDssAddSwitchReq::set_allocated_rcvaddr(::Dss::Event::DssNetAddr* rcvaddr) {
  delete rcvaddr_;
  rcvaddr_ = rcvaddr;
  if (rcvaddr) {
    set_has_rcvaddr();
  } else {
    clear_has_rcvaddr();
  }
}

// optional .Dss.Event.DssNetAddr MapAddr = 5;
inline bool CltDssAddSwitchReq::has_mapaddr() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CltDssAddSwitchReq::set_has_mapaddr() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CltDssAddSwitchReq::clear_has_mapaddr() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CltDssAddSwitchReq::clear_mapaddr() {
  if (mapaddr_ != NULL) mapaddr_->::Dss::Event::DssNetAddr::Clear();
  clear_has_mapaddr();
}
inline const ::Dss::Event::DssNetAddr& CltDssAddSwitchReq::mapaddr() const {
  return mapaddr_ != NULL ? *mapaddr_ : *default_instance_->mapaddr_;
}
inline ::Dss::Event::DssNetAddr* CltDssAddSwitchReq::mutable_mapaddr() {
  set_has_mapaddr();
  if (mapaddr_ == NULL) mapaddr_ = new ::Dss::Event::DssNetAddr;
  return mapaddr_;
}
inline ::Dss::Event::DssNetAddr* CltDssAddSwitchReq::release_mapaddr() {
  clear_has_mapaddr();
  ::Dss::Event::DssNetAddr* temp = mapaddr_;
  mapaddr_ = NULL;
  return temp;
}
inline void CltDssAddSwitchReq::set_allocated_mapaddr(::Dss::Event::DssNetAddr* mapaddr) {
  delete mapaddr_;
  mapaddr_ = mapaddr;
  if (mapaddr) {
    set_has_mapaddr();
  } else {
    clear_has_mapaddr();
  }
}

// optional .Dss.Event.SecretKey DecKey = 6;
inline bool CltDssAddSwitchReq::has_deckey() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CltDssAddSwitchReq::set_has_deckey() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CltDssAddSwitchReq::clear_has_deckey() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CltDssAddSwitchReq::clear_deckey() {
  if (deckey_ != NULL) deckey_->::Dss::Event::SecretKey::Clear();
  clear_has_deckey();
}
inline const ::Dss::Event::SecretKey& CltDssAddSwitchReq::deckey() const {
  return deckey_ != NULL ? *deckey_ : *default_instance_->deckey_;
}
inline ::Dss::Event::SecretKey* CltDssAddSwitchReq::mutable_deckey() {
  set_has_deckey();
  if (deckey_ == NULL) deckey_ = new ::Dss::Event::SecretKey;
  return deckey_;
}
inline ::Dss::Event::SecretKey* CltDssAddSwitchReq::release_deckey() {
  clear_has_deckey();
  ::Dss::Event::SecretKey* temp = deckey_;
  deckey_ = NULL;
  return temp;
}
inline void CltDssAddSwitchReq::set_allocated_deckey(::Dss::Event::SecretKey* deckey) {
  delete deckey_;
  deckey_ = deckey;
  if (deckey) {
    set_has_deckey();
  } else {
    clear_has_deckey();
  }
}

// optional .Dss.Event.SecretKey EncKey = 7;
inline bool CltDssAddSwitchReq::has_enckey() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CltDssAddSwitchReq::set_has_enckey() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CltDssAddSwitchReq::clear_has_enckey() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CltDssAddSwitchReq::clear_enckey() {
  if (enckey_ != NULL) enckey_->::Dss::Event::SecretKey::Clear();
  clear_has_enckey();
}
inline const ::Dss::Event::SecretKey& CltDssAddSwitchReq::enckey() const {
  return enckey_ != NULL ? *enckey_ : *default_instance_->enckey_;
}
inline ::Dss::Event::SecretKey* CltDssAddSwitchReq::mutable_enckey() {
  set_has_enckey();
  if (enckey_ == NULL) enckey_ = new ::Dss::Event::SecretKey;
  return enckey_;
}
inline ::Dss::Event::SecretKey* CltDssAddSwitchReq::release_enckey() {
  clear_has_enckey();
  ::Dss::Event::SecretKey* temp = enckey_;
  enckey_ = NULL;
  return temp;
}
inline void CltDssAddSwitchReq::set_allocated_enckey(::Dss::Event::SecretKey* enckey) {
  delete enckey_;
  enckey_ = enckey;
  if (enckey) {
    set_has_enckey();
  } else {
    clear_has_enckey();
  }
}

// optional bool Uniform = 8;
inline bool CltDssAddSwitchReq::has_uniform() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CltDssAddSwitchReq::set_has_uniform() {
  _has_bits_[0] |= 0x00000080u;
}
inline void CltDssAddSwitchReq::clear_has_uniform() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void CltDssAddSwitchReq::clear_uniform() {
  uniform_ = false;
  clear_has_uniform();
}
inline bool CltDssAddSwitchReq::uniform() const {
  return uniform_;
}
inline void CltDssAddSwitchReq::set_uniform(bool value) {
  set_has_uniform();
  uniform_ = value;
}

// optional .Dss.Event.DsType dstype = 9;
inline bool CltDssAddSwitchReq::has_dstype() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void CltDssAddSwitchReq::set_has_dstype() {
  _has_bits_[0] |= 0x00000100u;
}
inline void CltDssAddSwitchReq::clear_has_dstype() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void CltDssAddSwitchReq::clear_dstype() {
  dstype_ = 0;
  clear_has_dstype();
}
inline ::Dss::Event::DsType CltDssAddSwitchReq::dstype() const {
  return static_cast< ::Dss::Event::DsType >(dstype_);
}
inline void CltDssAddSwitchReq::set_dstype(::Dss::Event::DsType value) {
  assert(::Dss::Event::DsType_IsValid(value));
  set_has_dstype();
  dstype_ = value;
}

// -------------------------------------------------------------------

// DssCltAddSwitchAck

// optional uint32 ClientId = 1;
inline bool DssCltAddSwitchAck::has_clientid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DssCltAddSwitchAck::set_has_clientid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DssCltAddSwitchAck::clear_has_clientid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DssCltAddSwitchAck::clear_clientid() {
  clientid_ = 0u;
  clear_has_clientid();
}
inline ::google::protobuf::uint32 DssCltAddSwitchAck::clientid() const {
  return clientid_;
}
inline void DssCltAddSwitchAck::set_clientid(::google::protobuf::uint32 value) {
  set_has_clientid();
  clientid_ = value;
}

// optional uint64 DstEpId = 2;
inline bool DssCltAddSwitchAck::has_dstepid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DssCltAddSwitchAck::set_has_dstepid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DssCltAddSwitchAck::clear_has_dstepid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DssCltAddSwitchAck::clear_dstepid() {
  dstepid_ = GOOGLE_ULONGLONG(0);
  clear_has_dstepid();
}
inline ::google::protobuf::uint64 DssCltAddSwitchAck::dstepid() const {
  return dstepid_;
}
inline void DssCltAddSwitchAck::set_dstepid(::google::protobuf::uint64 value) {
  set_has_dstepid();
  dstepid_ = value;
}

// optional .Dss.Event.DssNetAddr DstAddr = 3;
inline bool DssCltAddSwitchAck::has_dstaddr() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DssCltAddSwitchAck::set_has_dstaddr() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DssCltAddSwitchAck::clear_has_dstaddr() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DssCltAddSwitchAck::clear_dstaddr() {
  if (dstaddr_ != NULL) dstaddr_->::Dss::Event::DssNetAddr::Clear();
  clear_has_dstaddr();
}
inline const ::Dss::Event::DssNetAddr& DssCltAddSwitchAck::dstaddr() const {
  return dstaddr_ != NULL ? *dstaddr_ : *default_instance_->dstaddr_;
}
inline ::Dss::Event::DssNetAddr* DssCltAddSwitchAck::mutable_dstaddr() {
  set_has_dstaddr();
  if (dstaddr_ == NULL) dstaddr_ = new ::Dss::Event::DssNetAddr;
  return dstaddr_;
}
inline ::Dss::Event::DssNetAddr* DssCltAddSwitchAck::release_dstaddr() {
  clear_has_dstaddr();
  ::Dss::Event::DssNetAddr* temp = dstaddr_;
  dstaddr_ = NULL;
  return temp;
}
inline void DssCltAddSwitchAck::set_allocated_dstaddr(::Dss::Event::DssNetAddr* dstaddr) {
  delete dstaddr_;
  dstaddr_ = dstaddr;
  if (dstaddr) {
    set_has_dstaddr();
  } else {
    clear_has_dstaddr();
  }
}

// optional .Dss.Event.DssNetAddr RcvAddr = 4;
inline bool DssCltAddSwitchAck::has_rcvaddr() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DssCltAddSwitchAck::set_has_rcvaddr() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DssCltAddSwitchAck::clear_has_rcvaddr() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DssCltAddSwitchAck::clear_rcvaddr() {
  if (rcvaddr_ != NULL) rcvaddr_->::Dss::Event::DssNetAddr::Clear();
  clear_has_rcvaddr();
}
inline const ::Dss::Event::DssNetAddr& DssCltAddSwitchAck::rcvaddr() const {
  return rcvaddr_ != NULL ? *rcvaddr_ : *default_instance_->rcvaddr_;
}
inline ::Dss::Event::DssNetAddr* DssCltAddSwitchAck::mutable_rcvaddr() {
  set_has_rcvaddr();
  if (rcvaddr_ == NULL) rcvaddr_ = new ::Dss::Event::DssNetAddr;
  return rcvaddr_;
}
inline ::Dss::Event::DssNetAddr* DssCltAddSwitchAck::release_rcvaddr() {
  clear_has_rcvaddr();
  ::Dss::Event::DssNetAddr* temp = rcvaddr_;
  rcvaddr_ = NULL;
  return temp;
}
inline void DssCltAddSwitchAck::set_allocated_rcvaddr(::Dss::Event::DssNetAddr* rcvaddr) {
  delete rcvaddr_;
  rcvaddr_ = rcvaddr;
  if (rcvaddr) {
    set_has_rcvaddr();
  } else {
    clear_has_rcvaddr();
  }
}

// optional .Dss.Event.DsType dstype = 5;
inline bool DssCltAddSwitchAck::has_dstype() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DssCltAddSwitchAck::set_has_dstype() {
  _has_bits_[0] |= 0x00000010u;
}
inline void DssCltAddSwitchAck::clear_has_dstype() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void DssCltAddSwitchAck::clear_dstype() {
  dstype_ = 0;
  clear_has_dstype();
}
inline ::Dss::Event::DsType DssCltAddSwitchAck::dstype() const {
  return static_cast< ::Dss::Event::DsType >(dstype_);
}
inline void DssCltAddSwitchAck::set_dstype(::Dss::Event::DsType value) {
  assert(::Dss::Event::DsType_IsValid(value));
  set_has_dstype();
  dstype_ = value;
}

// -------------------------------------------------------------------

// DssCltAddSwitchNack

// optional uint32 ClientId = 1;
inline bool DssCltAddSwitchNack::has_clientid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DssCltAddSwitchNack::set_has_clientid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DssCltAddSwitchNack::clear_has_clientid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DssCltAddSwitchNack::clear_clientid() {
  clientid_ = 0u;
  clear_has_clientid();
}
inline ::google::protobuf::uint32 DssCltAddSwitchNack::clientid() const {
  return clientid_;
}
inline void DssCltAddSwitchNack::set_clientid(::google::protobuf::uint32 value) {
  set_has_clientid();
  clientid_ = value;
}

// optional uint64 DstEpId = 2;
inline bool DssCltAddSwitchNack::has_dstepid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DssCltAddSwitchNack::set_has_dstepid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DssCltAddSwitchNack::clear_has_dstepid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DssCltAddSwitchNack::clear_dstepid() {
  dstepid_ = GOOGLE_ULONGLONG(0);
  clear_has_dstepid();
}
inline ::google::protobuf::uint64 DssCltAddSwitchNack::dstepid() const {
  return dstepid_;
}
inline void DssCltAddSwitchNack::set_dstepid(::google::protobuf::uint64 value) {
  set_has_dstepid();
  dstepid_ = value;
}

// optional .Dss.Event.DssNetAddr DstAddr = 3;
inline bool DssCltAddSwitchNack::has_dstaddr() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DssCltAddSwitchNack::set_has_dstaddr() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DssCltAddSwitchNack::clear_has_dstaddr() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DssCltAddSwitchNack::clear_dstaddr() {
  if (dstaddr_ != NULL) dstaddr_->::Dss::Event::DssNetAddr::Clear();
  clear_has_dstaddr();
}
inline const ::Dss::Event::DssNetAddr& DssCltAddSwitchNack::dstaddr() const {
  return dstaddr_ != NULL ? *dstaddr_ : *default_instance_->dstaddr_;
}
inline ::Dss::Event::DssNetAddr* DssCltAddSwitchNack::mutable_dstaddr() {
  set_has_dstaddr();
  if (dstaddr_ == NULL) dstaddr_ = new ::Dss::Event::DssNetAddr;
  return dstaddr_;
}
inline ::Dss::Event::DssNetAddr* DssCltAddSwitchNack::release_dstaddr() {
  clear_has_dstaddr();
  ::Dss::Event::DssNetAddr* temp = dstaddr_;
  dstaddr_ = NULL;
  return temp;
}
inline void DssCltAddSwitchNack::set_allocated_dstaddr(::Dss::Event::DssNetAddr* dstaddr) {
  delete dstaddr_;
  dstaddr_ = dstaddr;
  if (dstaddr) {
    set_has_dstaddr();
  } else {
    clear_has_dstaddr();
  }
}

// optional .Dss.Event.DssNetAddr RcvAddr = 4;
inline bool DssCltAddSwitchNack::has_rcvaddr() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DssCltAddSwitchNack::set_has_rcvaddr() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DssCltAddSwitchNack::clear_has_rcvaddr() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DssCltAddSwitchNack::clear_rcvaddr() {
  if (rcvaddr_ != NULL) rcvaddr_->::Dss::Event::DssNetAddr::Clear();
  clear_has_rcvaddr();
}
inline const ::Dss::Event::DssNetAddr& DssCltAddSwitchNack::rcvaddr() const {
  return rcvaddr_ != NULL ? *rcvaddr_ : *default_instance_->rcvaddr_;
}
inline ::Dss::Event::DssNetAddr* DssCltAddSwitchNack::mutable_rcvaddr() {
  set_has_rcvaddr();
  if (rcvaddr_ == NULL) rcvaddr_ = new ::Dss::Event::DssNetAddr;
  return rcvaddr_;
}
inline ::Dss::Event::DssNetAddr* DssCltAddSwitchNack::release_rcvaddr() {
  clear_has_rcvaddr();
  ::Dss::Event::DssNetAddr* temp = rcvaddr_;
  rcvaddr_ = NULL;
  return temp;
}
inline void DssCltAddSwitchNack::set_allocated_rcvaddr(::Dss::Event::DssNetAddr* rcvaddr) {
  delete rcvaddr_;
  rcvaddr_ = rcvaddr;
  if (rcvaddr) {
    set_has_rcvaddr();
  } else {
    clear_has_rcvaddr();
  }
}

// optional .Dss.Event.DsType dstype = 5;
inline bool DssCltAddSwitchNack::has_dstype() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DssCltAddSwitchNack::set_has_dstype() {
  _has_bits_[0] |= 0x00000010u;
}
inline void DssCltAddSwitchNack::clear_has_dstype() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void DssCltAddSwitchNack::clear_dstype() {
  dstype_ = 0;
  clear_has_dstype();
}
inline ::Dss::Event::DsType DssCltAddSwitchNack::dstype() const {
  return static_cast< ::Dss::Event::DsType >(dstype_);
}
inline void DssCltAddSwitchNack::set_dstype(::Dss::Event::DsType value) {
  assert(::Dss::Event::DsType_IsValid(value));
  set_has_dstype();
  dstype_ = value;
}

// -------------------------------------------------------------------

// CltDssAddM2OneSwitchReq

// optional uint32 ClientId = 1;
inline bool CltDssAddM2OneSwitchReq::has_clientid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CltDssAddM2OneSwitchReq::set_has_clientid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CltDssAddM2OneSwitchReq::clear_has_clientid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CltDssAddM2OneSwitchReq::clear_clientid() {
  clientid_ = 0u;
  clear_has_clientid();
}
inline ::google::protobuf::uint32 CltDssAddM2OneSwitchReq::clientid() const {
  return clientid_;
}
inline void CltDssAddM2OneSwitchReq::set_clientid(::google::protobuf::uint32 value) {
  set_has_clientid();
  clientid_ = value;
}

// optional uint64 DstEpId = 2;
inline bool CltDssAddM2OneSwitchReq::has_dstepid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CltDssAddM2OneSwitchReq::set_has_dstepid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CltDssAddM2OneSwitchReq::clear_has_dstepid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CltDssAddM2OneSwitchReq::clear_dstepid() {
  dstepid_ = GOOGLE_ULONGLONG(0);
  clear_has_dstepid();
}
inline ::google::protobuf::uint64 CltDssAddM2OneSwitchReq::dstepid() const {
  return dstepid_;
}
inline void CltDssAddM2OneSwitchReq::set_dstepid(::google::protobuf::uint64 value) {
  set_has_dstepid();
  dstepid_ = value;
}

// optional .Dss.Event.DssNetAddr DstAddr = 3;
inline bool CltDssAddM2OneSwitchReq::has_dstaddr() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CltDssAddM2OneSwitchReq::set_has_dstaddr() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CltDssAddM2OneSwitchReq::clear_has_dstaddr() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CltDssAddM2OneSwitchReq::clear_dstaddr() {
  if (dstaddr_ != NULL) dstaddr_->::Dss::Event::DssNetAddr::Clear();
  clear_has_dstaddr();
}
inline const ::Dss::Event::DssNetAddr& CltDssAddM2OneSwitchReq::dstaddr() const {
  return dstaddr_ != NULL ? *dstaddr_ : *default_instance_->dstaddr_;
}
inline ::Dss::Event::DssNetAddr* CltDssAddM2OneSwitchReq::mutable_dstaddr() {
  set_has_dstaddr();
  if (dstaddr_ == NULL) dstaddr_ = new ::Dss::Event::DssNetAddr;
  return dstaddr_;
}
inline ::Dss::Event::DssNetAddr* CltDssAddM2OneSwitchReq::release_dstaddr() {
  clear_has_dstaddr();
  ::Dss::Event::DssNetAddr* temp = dstaddr_;
  dstaddr_ = NULL;
  return temp;
}
inline void CltDssAddM2OneSwitchReq::set_allocated_dstaddr(::Dss::Event::DssNetAddr* dstaddr) {
  delete dstaddr_;
  dstaddr_ = dstaddr;
  if (dstaddr) {
    set_has_dstaddr();
  } else {
    clear_has_dstaddr();
  }
}

// optional .Dss.Event.DssNetAddr RcvAddr = 4;
inline bool CltDssAddM2OneSwitchReq::has_rcvaddr() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CltDssAddM2OneSwitchReq::set_has_rcvaddr() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CltDssAddM2OneSwitchReq::clear_has_rcvaddr() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CltDssAddM2OneSwitchReq::clear_rcvaddr() {
  if (rcvaddr_ != NULL) rcvaddr_->::Dss::Event::DssNetAddr::Clear();
  clear_has_rcvaddr();
}
inline const ::Dss::Event::DssNetAddr& CltDssAddM2OneSwitchReq::rcvaddr() const {
  return rcvaddr_ != NULL ? *rcvaddr_ : *default_instance_->rcvaddr_;
}
inline ::Dss::Event::DssNetAddr* CltDssAddM2OneSwitchReq::mutable_rcvaddr() {
  set_has_rcvaddr();
  if (rcvaddr_ == NULL) rcvaddr_ = new ::Dss::Event::DssNetAddr;
  return rcvaddr_;
}
inline ::Dss::Event::DssNetAddr* CltDssAddM2OneSwitchReq::release_rcvaddr() {
  clear_has_rcvaddr();
  ::Dss::Event::DssNetAddr* temp = rcvaddr_;
  rcvaddr_ = NULL;
  return temp;
}
inline void CltDssAddM2OneSwitchReq::set_allocated_rcvaddr(::Dss::Event::DssNetAddr* rcvaddr) {
  delete rcvaddr_;
  rcvaddr_ = rcvaddr;
  if (rcvaddr) {
    set_has_rcvaddr();
  } else {
    clear_has_rcvaddr();
  }
}

// optional .Dss.Event.DssNetAddr MapAddr = 5;
inline bool CltDssAddM2OneSwitchReq::has_mapaddr() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CltDssAddM2OneSwitchReq::set_has_mapaddr() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CltDssAddM2OneSwitchReq::clear_has_mapaddr() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CltDssAddM2OneSwitchReq::clear_mapaddr() {
  if (mapaddr_ != NULL) mapaddr_->::Dss::Event::DssNetAddr::Clear();
  clear_has_mapaddr();
}
inline const ::Dss::Event::DssNetAddr& CltDssAddM2OneSwitchReq::mapaddr() const {
  return mapaddr_ != NULL ? *mapaddr_ : *default_instance_->mapaddr_;
}
inline ::Dss::Event::DssNetAddr* CltDssAddM2OneSwitchReq::mutable_mapaddr() {
  set_has_mapaddr();
  if (mapaddr_ == NULL) mapaddr_ = new ::Dss::Event::DssNetAddr;
  return mapaddr_;
}
inline ::Dss::Event::DssNetAddr* CltDssAddM2OneSwitchReq::release_mapaddr() {
  clear_has_mapaddr();
  ::Dss::Event::DssNetAddr* temp = mapaddr_;
  mapaddr_ = NULL;
  return temp;
}
inline void CltDssAddM2OneSwitchReq::set_allocated_mapaddr(::Dss::Event::DssNetAddr* mapaddr) {
  delete mapaddr_;
  mapaddr_ = mapaddr;
  if (mapaddr) {
    set_has_mapaddr();
  } else {
    clear_has_mapaddr();
  }
}

// optional .Dss.Event.SecretKey DecKey = 6;
inline bool CltDssAddM2OneSwitchReq::has_deckey() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CltDssAddM2OneSwitchReq::set_has_deckey() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CltDssAddM2OneSwitchReq::clear_has_deckey() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CltDssAddM2OneSwitchReq::clear_deckey() {
  if (deckey_ != NULL) deckey_->::Dss::Event::SecretKey::Clear();
  clear_has_deckey();
}
inline const ::Dss::Event::SecretKey& CltDssAddM2OneSwitchReq::deckey() const {
  return deckey_ != NULL ? *deckey_ : *default_instance_->deckey_;
}
inline ::Dss::Event::SecretKey* CltDssAddM2OneSwitchReq::mutable_deckey() {
  set_has_deckey();
  if (deckey_ == NULL) deckey_ = new ::Dss::Event::SecretKey;
  return deckey_;
}
inline ::Dss::Event::SecretKey* CltDssAddM2OneSwitchReq::release_deckey() {
  clear_has_deckey();
  ::Dss::Event::SecretKey* temp = deckey_;
  deckey_ = NULL;
  return temp;
}
inline void CltDssAddM2OneSwitchReq::set_allocated_deckey(::Dss::Event::SecretKey* deckey) {
  delete deckey_;
  deckey_ = deckey;
  if (deckey) {
    set_has_deckey();
  } else {
    clear_has_deckey();
  }
}

// optional .Dss.Event.SecretKey EncKey = 7;
inline bool CltDssAddM2OneSwitchReq::has_enckey() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CltDssAddM2OneSwitchReq::set_has_enckey() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CltDssAddM2OneSwitchReq::clear_has_enckey() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CltDssAddM2OneSwitchReq::clear_enckey() {
  if (enckey_ != NULL) enckey_->::Dss::Event::SecretKey::Clear();
  clear_has_enckey();
}
inline const ::Dss::Event::SecretKey& CltDssAddM2OneSwitchReq::enckey() const {
  return enckey_ != NULL ? *enckey_ : *default_instance_->enckey_;
}
inline ::Dss::Event::SecretKey* CltDssAddM2OneSwitchReq::mutable_enckey() {
  set_has_enckey();
  if (enckey_ == NULL) enckey_ = new ::Dss::Event::SecretKey;
  return enckey_;
}
inline ::Dss::Event::SecretKey* CltDssAddM2OneSwitchReq::release_enckey() {
  clear_has_enckey();
  ::Dss::Event::SecretKey* temp = enckey_;
  enckey_ = NULL;
  return temp;
}
inline void CltDssAddM2OneSwitchReq::set_allocated_enckey(::Dss::Event::SecretKey* enckey) {
  delete enckey_;
  enckey_ = enckey;
  if (enckey) {
    set_has_enckey();
  } else {
    clear_has_enckey();
  }
}

// optional bool Uniform = 8;
inline bool CltDssAddM2OneSwitchReq::has_uniform() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CltDssAddM2OneSwitchReq::set_has_uniform() {
  _has_bits_[0] |= 0x00000080u;
}
inline void CltDssAddM2OneSwitchReq::clear_has_uniform() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void CltDssAddM2OneSwitchReq::clear_uniform() {
  uniform_ = false;
  clear_has_uniform();
}
inline bool CltDssAddM2OneSwitchReq::uniform() const {
  return uniform_;
}
inline void CltDssAddM2OneSwitchReq::set_uniform(bool value) {
  set_has_uniform();
  uniform_ = value;
}

// optional .Dss.Event.DsType dstype = 9;
inline bool CltDssAddM2OneSwitchReq::has_dstype() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void CltDssAddM2OneSwitchReq::set_has_dstype() {
  _has_bits_[0] |= 0x00000100u;
}
inline void CltDssAddM2OneSwitchReq::clear_has_dstype() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void CltDssAddM2OneSwitchReq::clear_dstype() {
  dstype_ = 0;
  clear_has_dstype();
}
inline ::Dss::Event::DsType CltDssAddM2OneSwitchReq::dstype() const {
  return static_cast< ::Dss::Event::DsType >(dstype_);
}
inline void CltDssAddM2OneSwitchReq::set_dstype(::Dss::Event::DsType value) {
  assert(::Dss::Event::DsType_IsValid(value));
  set_has_dstype();
  dstype_ = value;
}

// -------------------------------------------------------------------

// DssCltAddM2OneSwitchAck

// optional uint32 ClientId = 1;
inline bool DssCltAddM2OneSwitchAck::has_clientid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DssCltAddM2OneSwitchAck::set_has_clientid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DssCltAddM2OneSwitchAck::clear_has_clientid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DssCltAddM2OneSwitchAck::clear_clientid() {
  clientid_ = 0u;
  clear_has_clientid();
}
inline ::google::protobuf::uint32 DssCltAddM2OneSwitchAck::clientid() const {
  return clientid_;
}
inline void DssCltAddM2OneSwitchAck::set_clientid(::google::protobuf::uint32 value) {
  set_has_clientid();
  clientid_ = value;
}

// optional uint64 DstEpId = 2;
inline bool DssCltAddM2OneSwitchAck::has_dstepid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DssCltAddM2OneSwitchAck::set_has_dstepid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DssCltAddM2OneSwitchAck::clear_has_dstepid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DssCltAddM2OneSwitchAck::clear_dstepid() {
  dstepid_ = GOOGLE_ULONGLONG(0);
  clear_has_dstepid();
}
inline ::google::protobuf::uint64 DssCltAddM2OneSwitchAck::dstepid() const {
  return dstepid_;
}
inline void DssCltAddM2OneSwitchAck::set_dstepid(::google::protobuf::uint64 value) {
  set_has_dstepid();
  dstepid_ = value;
}

// optional .Dss.Event.DssNetAddr DstAddr = 3;
inline bool DssCltAddM2OneSwitchAck::has_dstaddr() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DssCltAddM2OneSwitchAck::set_has_dstaddr() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DssCltAddM2OneSwitchAck::clear_has_dstaddr() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DssCltAddM2OneSwitchAck::clear_dstaddr() {
  if (dstaddr_ != NULL) dstaddr_->::Dss::Event::DssNetAddr::Clear();
  clear_has_dstaddr();
}
inline const ::Dss::Event::DssNetAddr& DssCltAddM2OneSwitchAck::dstaddr() const {
  return dstaddr_ != NULL ? *dstaddr_ : *default_instance_->dstaddr_;
}
inline ::Dss::Event::DssNetAddr* DssCltAddM2OneSwitchAck::mutable_dstaddr() {
  set_has_dstaddr();
  if (dstaddr_ == NULL) dstaddr_ = new ::Dss::Event::DssNetAddr;
  return dstaddr_;
}
inline ::Dss::Event::DssNetAddr* DssCltAddM2OneSwitchAck::release_dstaddr() {
  clear_has_dstaddr();
  ::Dss::Event::DssNetAddr* temp = dstaddr_;
  dstaddr_ = NULL;
  return temp;
}
inline void DssCltAddM2OneSwitchAck::set_allocated_dstaddr(::Dss::Event::DssNetAddr* dstaddr) {
  delete dstaddr_;
  dstaddr_ = dstaddr;
  if (dstaddr) {
    set_has_dstaddr();
  } else {
    clear_has_dstaddr();
  }
}

// optional .Dss.Event.DssNetAddr RcvAddr = 4;
inline bool DssCltAddM2OneSwitchAck::has_rcvaddr() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DssCltAddM2OneSwitchAck::set_has_rcvaddr() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DssCltAddM2OneSwitchAck::clear_has_rcvaddr() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DssCltAddM2OneSwitchAck::clear_rcvaddr() {
  if (rcvaddr_ != NULL) rcvaddr_->::Dss::Event::DssNetAddr::Clear();
  clear_has_rcvaddr();
}
inline const ::Dss::Event::DssNetAddr& DssCltAddM2OneSwitchAck::rcvaddr() const {
  return rcvaddr_ != NULL ? *rcvaddr_ : *default_instance_->rcvaddr_;
}
inline ::Dss::Event::DssNetAddr* DssCltAddM2OneSwitchAck::mutable_rcvaddr() {
  set_has_rcvaddr();
  if (rcvaddr_ == NULL) rcvaddr_ = new ::Dss::Event::DssNetAddr;
  return rcvaddr_;
}
inline ::Dss::Event::DssNetAddr* DssCltAddM2OneSwitchAck::release_rcvaddr() {
  clear_has_rcvaddr();
  ::Dss::Event::DssNetAddr* temp = rcvaddr_;
  rcvaddr_ = NULL;
  return temp;
}
inline void DssCltAddM2OneSwitchAck::set_allocated_rcvaddr(::Dss::Event::DssNetAddr* rcvaddr) {
  delete rcvaddr_;
  rcvaddr_ = rcvaddr;
  if (rcvaddr) {
    set_has_rcvaddr();
  } else {
    clear_has_rcvaddr();
  }
}

// optional .Dss.Event.DsType dstype = 5;
inline bool DssCltAddM2OneSwitchAck::has_dstype() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DssCltAddM2OneSwitchAck::set_has_dstype() {
  _has_bits_[0] |= 0x00000010u;
}
inline void DssCltAddM2OneSwitchAck::clear_has_dstype() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void DssCltAddM2OneSwitchAck::clear_dstype() {
  dstype_ = 0;
  clear_has_dstype();
}
inline ::Dss::Event::DsType DssCltAddM2OneSwitchAck::dstype() const {
  return static_cast< ::Dss::Event::DsType >(dstype_);
}
inline void DssCltAddM2OneSwitchAck::set_dstype(::Dss::Event::DsType value) {
  assert(::Dss::Event::DsType_IsValid(value));
  set_has_dstype();
  dstype_ = value;
}

// -------------------------------------------------------------------

// DssCltAddM2OneSwitchNack

// optional uint32 ClientId = 1;
inline bool DssCltAddM2OneSwitchNack::has_clientid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DssCltAddM2OneSwitchNack::set_has_clientid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DssCltAddM2OneSwitchNack::clear_has_clientid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DssCltAddM2OneSwitchNack::clear_clientid() {
  clientid_ = 0u;
  clear_has_clientid();
}
inline ::google::protobuf::uint32 DssCltAddM2OneSwitchNack::clientid() const {
  return clientid_;
}
inline void DssCltAddM2OneSwitchNack::set_clientid(::google::protobuf::uint32 value) {
  set_has_clientid();
  clientid_ = value;
}

// optional uint64 DstEpId = 2;
inline bool DssCltAddM2OneSwitchNack::has_dstepid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DssCltAddM2OneSwitchNack::set_has_dstepid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DssCltAddM2OneSwitchNack::clear_has_dstepid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DssCltAddM2OneSwitchNack::clear_dstepid() {
  dstepid_ = GOOGLE_ULONGLONG(0);
  clear_has_dstepid();
}
inline ::google::protobuf::uint64 DssCltAddM2OneSwitchNack::dstepid() const {
  return dstepid_;
}
inline void DssCltAddM2OneSwitchNack::set_dstepid(::google::protobuf::uint64 value) {
  set_has_dstepid();
  dstepid_ = value;
}

// optional .Dss.Event.DssNetAddr DstAddr = 3;
inline bool DssCltAddM2OneSwitchNack::has_dstaddr() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DssCltAddM2OneSwitchNack::set_has_dstaddr() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DssCltAddM2OneSwitchNack::clear_has_dstaddr() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DssCltAddM2OneSwitchNack::clear_dstaddr() {
  if (dstaddr_ != NULL) dstaddr_->::Dss::Event::DssNetAddr::Clear();
  clear_has_dstaddr();
}
inline const ::Dss::Event::DssNetAddr& DssCltAddM2OneSwitchNack::dstaddr() const {
  return dstaddr_ != NULL ? *dstaddr_ : *default_instance_->dstaddr_;
}
inline ::Dss::Event::DssNetAddr* DssCltAddM2OneSwitchNack::mutable_dstaddr() {
  set_has_dstaddr();
  if (dstaddr_ == NULL) dstaddr_ = new ::Dss::Event::DssNetAddr;
  return dstaddr_;
}
inline ::Dss::Event::DssNetAddr* DssCltAddM2OneSwitchNack::release_dstaddr() {
  clear_has_dstaddr();
  ::Dss::Event::DssNetAddr* temp = dstaddr_;
  dstaddr_ = NULL;
  return temp;
}
inline void DssCltAddM2OneSwitchNack::set_allocated_dstaddr(::Dss::Event::DssNetAddr* dstaddr) {
  delete dstaddr_;
  dstaddr_ = dstaddr;
  if (dstaddr) {
    set_has_dstaddr();
  } else {
    clear_has_dstaddr();
  }
}

// optional .Dss.Event.DssNetAddr RcvAddr = 4;
inline bool DssCltAddM2OneSwitchNack::has_rcvaddr() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DssCltAddM2OneSwitchNack::set_has_rcvaddr() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DssCltAddM2OneSwitchNack::clear_has_rcvaddr() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DssCltAddM2OneSwitchNack::clear_rcvaddr() {
  if (rcvaddr_ != NULL) rcvaddr_->::Dss::Event::DssNetAddr::Clear();
  clear_has_rcvaddr();
}
inline const ::Dss::Event::DssNetAddr& DssCltAddM2OneSwitchNack::rcvaddr() const {
  return rcvaddr_ != NULL ? *rcvaddr_ : *default_instance_->rcvaddr_;
}
inline ::Dss::Event::DssNetAddr* DssCltAddM2OneSwitchNack::mutable_rcvaddr() {
  set_has_rcvaddr();
  if (rcvaddr_ == NULL) rcvaddr_ = new ::Dss::Event::DssNetAddr;
  return rcvaddr_;
}
inline ::Dss::Event::DssNetAddr* DssCltAddM2OneSwitchNack::release_rcvaddr() {
  clear_has_rcvaddr();
  ::Dss::Event::DssNetAddr* temp = rcvaddr_;
  rcvaddr_ = NULL;
  return temp;
}
inline void DssCltAddM2OneSwitchNack::set_allocated_rcvaddr(::Dss::Event::DssNetAddr* rcvaddr) {
  delete rcvaddr_;
  rcvaddr_ = rcvaddr;
  if (rcvaddr) {
    set_has_rcvaddr();
  } else {
    clear_has_rcvaddr();
  }
}

// optional .Dss.Event.DsType dstype = 5;
inline bool DssCltAddM2OneSwitchNack::has_dstype() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DssCltAddM2OneSwitchNack::set_has_dstype() {
  _has_bits_[0] |= 0x00000010u;
}
inline void DssCltAddM2OneSwitchNack::clear_has_dstype() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void DssCltAddM2OneSwitchNack::clear_dstype() {
  dstype_ = 0;
  clear_has_dstype();
}
inline ::Dss::Event::DsType DssCltAddM2OneSwitchNack::dstype() const {
  return static_cast< ::Dss::Event::DsType >(dstype_);
}
inline void DssCltAddM2OneSwitchNack::set_dstype(::Dss::Event::DsType value) {
  assert(::Dss::Event::DsType_IsValid(value));
  set_has_dstype();
  dstype_ = value;
}

// -------------------------------------------------------------------

// CltDssAddSrcSwitchReq

// optional uint32 ClientId = 1;
inline bool CltDssAddSrcSwitchReq::has_clientid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CltDssAddSrcSwitchReq::set_has_clientid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CltDssAddSrcSwitchReq::clear_has_clientid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CltDssAddSrcSwitchReq::clear_clientid() {
  clientid_ = 0u;
  clear_has_clientid();
}
inline ::google::protobuf::uint32 CltDssAddSrcSwitchReq::clientid() const {
  return clientid_;
}
inline void CltDssAddSrcSwitchReq::set_clientid(::google::protobuf::uint32 value) {
  set_has_clientid();
  clientid_ = value;
}

// optional uint64 SrcEpId = 2;
inline bool CltDssAddSrcSwitchReq::has_srcepid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CltDssAddSrcSwitchReq::set_has_srcepid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CltDssAddSrcSwitchReq::clear_has_srcepid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CltDssAddSrcSwitchReq::clear_srcepid() {
  srcepid_ = GOOGLE_ULONGLONG(0);
  clear_has_srcepid();
}
inline ::google::protobuf::uint64 CltDssAddSrcSwitchReq::srcepid() const {
  return srcepid_;
}
inline void CltDssAddSrcSwitchReq::set_srcepid(::google::protobuf::uint64 value) {
  set_has_srcepid();
  srcepid_ = value;
}

// optional .Dss.Event.DssNetAddr SrcAddr = 3;
inline bool CltDssAddSrcSwitchReq::has_srcaddr() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CltDssAddSrcSwitchReq::set_has_srcaddr() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CltDssAddSrcSwitchReq::clear_has_srcaddr() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CltDssAddSrcSwitchReq::clear_srcaddr() {
  if (srcaddr_ != NULL) srcaddr_->::Dss::Event::DssNetAddr::Clear();
  clear_has_srcaddr();
}
inline const ::Dss::Event::DssNetAddr& CltDssAddSrcSwitchReq::srcaddr() const {
  return srcaddr_ != NULL ? *srcaddr_ : *default_instance_->srcaddr_;
}
inline ::Dss::Event::DssNetAddr* CltDssAddSrcSwitchReq::mutable_srcaddr() {
  set_has_srcaddr();
  if (srcaddr_ == NULL) srcaddr_ = new ::Dss::Event::DssNetAddr;
  return srcaddr_;
}
inline ::Dss::Event::DssNetAddr* CltDssAddSrcSwitchReq::release_srcaddr() {
  clear_has_srcaddr();
  ::Dss::Event::DssNetAddr* temp = srcaddr_;
  srcaddr_ = NULL;
  return temp;
}
inline void CltDssAddSrcSwitchReq::set_allocated_srcaddr(::Dss::Event::DssNetAddr* srcaddr) {
  delete srcaddr_;
  srcaddr_ = srcaddr;
  if (srcaddr) {
    set_has_srcaddr();
  } else {
    clear_has_srcaddr();
  }
}

// optional uint64 DstEpId = 4;
inline bool CltDssAddSrcSwitchReq::has_dstepid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CltDssAddSrcSwitchReq::set_has_dstepid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CltDssAddSrcSwitchReq::clear_has_dstepid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CltDssAddSrcSwitchReq::clear_dstepid() {
  dstepid_ = GOOGLE_ULONGLONG(0);
  clear_has_dstepid();
}
inline ::google::protobuf::uint64 CltDssAddSrcSwitchReq::dstepid() const {
  return dstepid_;
}
inline void CltDssAddSrcSwitchReq::set_dstepid(::google::protobuf::uint64 value) {
  set_has_dstepid();
  dstepid_ = value;
}

// optional .Dss.Event.DssNetAddr DstAddr = 5;
inline bool CltDssAddSrcSwitchReq::has_dstaddr() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CltDssAddSrcSwitchReq::set_has_dstaddr() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CltDssAddSrcSwitchReq::clear_has_dstaddr() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CltDssAddSrcSwitchReq::clear_dstaddr() {
  if (dstaddr_ != NULL) dstaddr_->::Dss::Event::DssNetAddr::Clear();
  clear_has_dstaddr();
}
inline const ::Dss::Event::DssNetAddr& CltDssAddSrcSwitchReq::dstaddr() const {
  return dstaddr_ != NULL ? *dstaddr_ : *default_instance_->dstaddr_;
}
inline ::Dss::Event::DssNetAddr* CltDssAddSrcSwitchReq::mutable_dstaddr() {
  set_has_dstaddr();
  if (dstaddr_ == NULL) dstaddr_ = new ::Dss::Event::DssNetAddr;
  return dstaddr_;
}
inline ::Dss::Event::DssNetAddr* CltDssAddSrcSwitchReq::release_dstaddr() {
  clear_has_dstaddr();
  ::Dss::Event::DssNetAddr* temp = dstaddr_;
  dstaddr_ = NULL;
  return temp;
}
inline void CltDssAddSrcSwitchReq::set_allocated_dstaddr(::Dss::Event::DssNetAddr* dstaddr) {
  delete dstaddr_;
  dstaddr_ = dstaddr;
  if (dstaddr) {
    set_has_dstaddr();
  } else {
    clear_has_dstaddr();
  }
}

// optional .Dss.Event.DssNetAddr RcvAddr = 6;
inline bool CltDssAddSrcSwitchReq::has_rcvaddr() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CltDssAddSrcSwitchReq::set_has_rcvaddr() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CltDssAddSrcSwitchReq::clear_has_rcvaddr() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CltDssAddSrcSwitchReq::clear_rcvaddr() {
  if (rcvaddr_ != NULL) rcvaddr_->::Dss::Event::DssNetAddr::Clear();
  clear_has_rcvaddr();
}
inline const ::Dss::Event::DssNetAddr& CltDssAddSrcSwitchReq::rcvaddr() const {
  return rcvaddr_ != NULL ? *rcvaddr_ : *default_instance_->rcvaddr_;
}
inline ::Dss::Event::DssNetAddr* CltDssAddSrcSwitchReq::mutable_rcvaddr() {
  set_has_rcvaddr();
  if (rcvaddr_ == NULL) rcvaddr_ = new ::Dss::Event::DssNetAddr;
  return rcvaddr_;
}
inline ::Dss::Event::DssNetAddr* CltDssAddSrcSwitchReq::release_rcvaddr() {
  clear_has_rcvaddr();
  ::Dss::Event::DssNetAddr* temp = rcvaddr_;
  rcvaddr_ = NULL;
  return temp;
}
inline void CltDssAddSrcSwitchReq::set_allocated_rcvaddr(::Dss::Event::DssNetAddr* rcvaddr) {
  delete rcvaddr_;
  rcvaddr_ = rcvaddr;
  if (rcvaddr) {
    set_has_rcvaddr();
  } else {
    clear_has_rcvaddr();
  }
}

// optional .Dss.Event.DssNetAddr MapAddr = 7;
inline bool CltDssAddSrcSwitchReq::has_mapaddr() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CltDssAddSrcSwitchReq::set_has_mapaddr() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CltDssAddSrcSwitchReq::clear_has_mapaddr() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CltDssAddSrcSwitchReq::clear_mapaddr() {
  if (mapaddr_ != NULL) mapaddr_->::Dss::Event::DssNetAddr::Clear();
  clear_has_mapaddr();
}
inline const ::Dss::Event::DssNetAddr& CltDssAddSrcSwitchReq::mapaddr() const {
  return mapaddr_ != NULL ? *mapaddr_ : *default_instance_->mapaddr_;
}
inline ::Dss::Event::DssNetAddr* CltDssAddSrcSwitchReq::mutable_mapaddr() {
  set_has_mapaddr();
  if (mapaddr_ == NULL) mapaddr_ = new ::Dss::Event::DssNetAddr;
  return mapaddr_;
}
inline ::Dss::Event::DssNetAddr* CltDssAddSrcSwitchReq::release_mapaddr() {
  clear_has_mapaddr();
  ::Dss::Event::DssNetAddr* temp = mapaddr_;
  mapaddr_ = NULL;
  return temp;
}
inline void CltDssAddSrcSwitchReq::set_allocated_mapaddr(::Dss::Event::DssNetAddr* mapaddr) {
  delete mapaddr_;
  mapaddr_ = mapaddr;
  if (mapaddr) {
    set_has_mapaddr();
  } else {
    clear_has_mapaddr();
  }
}

// optional .Dss.Event.SecretKey DecKey = 8;
inline bool CltDssAddSrcSwitchReq::has_deckey() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CltDssAddSrcSwitchReq::set_has_deckey() {
  _has_bits_[0] |= 0x00000080u;
}
inline void CltDssAddSrcSwitchReq::clear_has_deckey() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void CltDssAddSrcSwitchReq::clear_deckey() {
  if (deckey_ != NULL) deckey_->::Dss::Event::SecretKey::Clear();
  clear_has_deckey();
}
inline const ::Dss::Event::SecretKey& CltDssAddSrcSwitchReq::deckey() const {
  return deckey_ != NULL ? *deckey_ : *default_instance_->deckey_;
}
inline ::Dss::Event::SecretKey* CltDssAddSrcSwitchReq::mutable_deckey() {
  set_has_deckey();
  if (deckey_ == NULL) deckey_ = new ::Dss::Event::SecretKey;
  return deckey_;
}
inline ::Dss::Event::SecretKey* CltDssAddSrcSwitchReq::release_deckey() {
  clear_has_deckey();
  ::Dss::Event::SecretKey* temp = deckey_;
  deckey_ = NULL;
  return temp;
}
inline void CltDssAddSrcSwitchReq::set_allocated_deckey(::Dss::Event::SecretKey* deckey) {
  delete deckey_;
  deckey_ = deckey;
  if (deckey) {
    set_has_deckey();
  } else {
    clear_has_deckey();
  }
}

// optional .Dss.Event.SecretKey EncKey = 9;
inline bool CltDssAddSrcSwitchReq::has_enckey() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void CltDssAddSrcSwitchReq::set_has_enckey() {
  _has_bits_[0] |= 0x00000100u;
}
inline void CltDssAddSrcSwitchReq::clear_has_enckey() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void CltDssAddSrcSwitchReq::clear_enckey() {
  if (enckey_ != NULL) enckey_->::Dss::Event::SecretKey::Clear();
  clear_has_enckey();
}
inline const ::Dss::Event::SecretKey& CltDssAddSrcSwitchReq::enckey() const {
  return enckey_ != NULL ? *enckey_ : *default_instance_->enckey_;
}
inline ::Dss::Event::SecretKey* CltDssAddSrcSwitchReq::mutable_enckey() {
  set_has_enckey();
  if (enckey_ == NULL) enckey_ = new ::Dss::Event::SecretKey;
  return enckey_;
}
inline ::Dss::Event::SecretKey* CltDssAddSrcSwitchReq::release_enckey() {
  clear_has_enckey();
  ::Dss::Event::SecretKey* temp = enckey_;
  enckey_ = NULL;
  return temp;
}
inline void CltDssAddSrcSwitchReq::set_allocated_enckey(::Dss::Event::SecretKey* enckey) {
  delete enckey_;
  enckey_ = enckey;
  if (enckey) {
    set_has_enckey();
  } else {
    clear_has_enckey();
  }
}

// optional bool Uniform = 10;
inline bool CltDssAddSrcSwitchReq::has_uniform() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void CltDssAddSrcSwitchReq::set_has_uniform() {
  _has_bits_[0] |= 0x00000200u;
}
inline void CltDssAddSrcSwitchReq::clear_has_uniform() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void CltDssAddSrcSwitchReq::clear_uniform() {
  uniform_ = false;
  clear_has_uniform();
}
inline bool CltDssAddSrcSwitchReq::uniform() const {
  return uniform_;
}
inline void CltDssAddSrcSwitchReq::set_uniform(bool value) {
  set_has_uniform();
  uniform_ = value;
}

// optional .Dss.Event.DsType dstype = 11;
inline bool CltDssAddSrcSwitchReq::has_dstype() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void CltDssAddSrcSwitchReq::set_has_dstype() {
  _has_bits_[0] |= 0x00000400u;
}
inline void CltDssAddSrcSwitchReq::clear_has_dstype() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void CltDssAddSrcSwitchReq::clear_dstype() {
  dstype_ = 0;
  clear_has_dstype();
}
inline ::Dss::Event::DsType CltDssAddSrcSwitchReq::dstype() const {
  return static_cast< ::Dss::Event::DsType >(dstype_);
}
inline void CltDssAddSrcSwitchReq::set_dstype(::Dss::Event::DsType value) {
  assert(::Dss::Event::DsType_IsValid(value));
  set_has_dstype();
  dstype_ = value;
}

// -------------------------------------------------------------------

// DssCltAddSrcSwitchAck

// optional uint32 ClientId = 1;
inline bool DssCltAddSrcSwitchAck::has_clientid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DssCltAddSrcSwitchAck::set_has_clientid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DssCltAddSrcSwitchAck::clear_has_clientid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DssCltAddSrcSwitchAck::clear_clientid() {
  clientid_ = 0u;
  clear_has_clientid();
}
inline ::google::protobuf::uint32 DssCltAddSrcSwitchAck::clientid() const {
  return clientid_;
}
inline void DssCltAddSrcSwitchAck::set_clientid(::google::protobuf::uint32 value) {
  set_has_clientid();
  clientid_ = value;
}

// optional uint64 SrcEpId = 2;
inline bool DssCltAddSrcSwitchAck::has_srcepid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DssCltAddSrcSwitchAck::set_has_srcepid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DssCltAddSrcSwitchAck::clear_has_srcepid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DssCltAddSrcSwitchAck::clear_srcepid() {
  srcepid_ = GOOGLE_ULONGLONG(0);
  clear_has_srcepid();
}
inline ::google::protobuf::uint64 DssCltAddSrcSwitchAck::srcepid() const {
  return srcepid_;
}
inline void DssCltAddSrcSwitchAck::set_srcepid(::google::protobuf::uint64 value) {
  set_has_srcepid();
  srcepid_ = value;
}

// optional .Dss.Event.DssNetAddr SrcAddr = 3;
inline bool DssCltAddSrcSwitchAck::has_srcaddr() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DssCltAddSrcSwitchAck::set_has_srcaddr() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DssCltAddSrcSwitchAck::clear_has_srcaddr() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DssCltAddSrcSwitchAck::clear_srcaddr() {
  if (srcaddr_ != NULL) srcaddr_->::Dss::Event::DssNetAddr::Clear();
  clear_has_srcaddr();
}
inline const ::Dss::Event::DssNetAddr& DssCltAddSrcSwitchAck::srcaddr() const {
  return srcaddr_ != NULL ? *srcaddr_ : *default_instance_->srcaddr_;
}
inline ::Dss::Event::DssNetAddr* DssCltAddSrcSwitchAck::mutable_srcaddr() {
  set_has_srcaddr();
  if (srcaddr_ == NULL) srcaddr_ = new ::Dss::Event::DssNetAddr;
  return srcaddr_;
}
inline ::Dss::Event::DssNetAddr* DssCltAddSrcSwitchAck::release_srcaddr() {
  clear_has_srcaddr();
  ::Dss::Event::DssNetAddr* temp = srcaddr_;
  srcaddr_ = NULL;
  return temp;
}
inline void DssCltAddSrcSwitchAck::set_allocated_srcaddr(::Dss::Event::DssNetAddr* srcaddr) {
  delete srcaddr_;
  srcaddr_ = srcaddr;
  if (srcaddr) {
    set_has_srcaddr();
  } else {
    clear_has_srcaddr();
  }
}

// optional uint64 DstEpId = 4;
inline bool DssCltAddSrcSwitchAck::has_dstepid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DssCltAddSrcSwitchAck::set_has_dstepid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DssCltAddSrcSwitchAck::clear_has_dstepid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DssCltAddSrcSwitchAck::clear_dstepid() {
  dstepid_ = GOOGLE_ULONGLONG(0);
  clear_has_dstepid();
}
inline ::google::protobuf::uint64 DssCltAddSrcSwitchAck::dstepid() const {
  return dstepid_;
}
inline void DssCltAddSrcSwitchAck::set_dstepid(::google::protobuf::uint64 value) {
  set_has_dstepid();
  dstepid_ = value;
}

// optional .Dss.Event.DssNetAddr DstAddr = 5;
inline bool DssCltAddSrcSwitchAck::has_dstaddr() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DssCltAddSrcSwitchAck::set_has_dstaddr() {
  _has_bits_[0] |= 0x00000010u;
}
inline void DssCltAddSrcSwitchAck::clear_has_dstaddr() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void DssCltAddSrcSwitchAck::clear_dstaddr() {
  if (dstaddr_ != NULL) dstaddr_->::Dss::Event::DssNetAddr::Clear();
  clear_has_dstaddr();
}
inline const ::Dss::Event::DssNetAddr& DssCltAddSrcSwitchAck::dstaddr() const {
  return dstaddr_ != NULL ? *dstaddr_ : *default_instance_->dstaddr_;
}
inline ::Dss::Event::DssNetAddr* DssCltAddSrcSwitchAck::mutable_dstaddr() {
  set_has_dstaddr();
  if (dstaddr_ == NULL) dstaddr_ = new ::Dss::Event::DssNetAddr;
  return dstaddr_;
}
inline ::Dss::Event::DssNetAddr* DssCltAddSrcSwitchAck::release_dstaddr() {
  clear_has_dstaddr();
  ::Dss::Event::DssNetAddr* temp = dstaddr_;
  dstaddr_ = NULL;
  return temp;
}
inline void DssCltAddSrcSwitchAck::set_allocated_dstaddr(::Dss::Event::DssNetAddr* dstaddr) {
  delete dstaddr_;
  dstaddr_ = dstaddr;
  if (dstaddr) {
    set_has_dstaddr();
  } else {
    clear_has_dstaddr();
  }
}

// optional .Dss.Event.DssNetAddr RcvAddr = 6;
inline bool DssCltAddSrcSwitchAck::has_rcvaddr() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void DssCltAddSrcSwitchAck::set_has_rcvaddr() {
  _has_bits_[0] |= 0x00000020u;
}
inline void DssCltAddSrcSwitchAck::clear_has_rcvaddr() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void DssCltAddSrcSwitchAck::clear_rcvaddr() {
  if (rcvaddr_ != NULL) rcvaddr_->::Dss::Event::DssNetAddr::Clear();
  clear_has_rcvaddr();
}
inline const ::Dss::Event::DssNetAddr& DssCltAddSrcSwitchAck::rcvaddr() const {
  return rcvaddr_ != NULL ? *rcvaddr_ : *default_instance_->rcvaddr_;
}
inline ::Dss::Event::DssNetAddr* DssCltAddSrcSwitchAck::mutable_rcvaddr() {
  set_has_rcvaddr();
  if (rcvaddr_ == NULL) rcvaddr_ = new ::Dss::Event::DssNetAddr;
  return rcvaddr_;
}
inline ::Dss::Event::DssNetAddr* DssCltAddSrcSwitchAck::release_rcvaddr() {
  clear_has_rcvaddr();
  ::Dss::Event::DssNetAddr* temp = rcvaddr_;
  rcvaddr_ = NULL;
  return temp;
}
inline void DssCltAddSrcSwitchAck::set_allocated_rcvaddr(::Dss::Event::DssNetAddr* rcvaddr) {
  delete rcvaddr_;
  rcvaddr_ = rcvaddr;
  if (rcvaddr) {
    set_has_rcvaddr();
  } else {
    clear_has_rcvaddr();
  }
}

// optional .Dss.Event.DsType dstype = 7;
inline bool DssCltAddSrcSwitchAck::has_dstype() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void DssCltAddSrcSwitchAck::set_has_dstype() {
  _has_bits_[0] |= 0x00000040u;
}
inline void DssCltAddSrcSwitchAck::clear_has_dstype() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void DssCltAddSrcSwitchAck::clear_dstype() {
  dstype_ = 0;
  clear_has_dstype();
}
inline ::Dss::Event::DsType DssCltAddSrcSwitchAck::dstype() const {
  return static_cast< ::Dss::Event::DsType >(dstype_);
}
inline void DssCltAddSrcSwitchAck::set_dstype(::Dss::Event::DsType value) {
  assert(::Dss::Event::DsType_IsValid(value));
  set_has_dstype();
  dstype_ = value;
}

// -------------------------------------------------------------------

// DssCltAddSrcSwitchNack

// optional uint32 ClientId = 1;
inline bool DssCltAddSrcSwitchNack::has_clientid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DssCltAddSrcSwitchNack::set_has_clientid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DssCltAddSrcSwitchNack::clear_has_clientid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DssCltAddSrcSwitchNack::clear_clientid() {
  clientid_ = 0u;
  clear_has_clientid();
}
inline ::google::protobuf::uint32 DssCltAddSrcSwitchNack::clientid() const {
  return clientid_;
}
inline void DssCltAddSrcSwitchNack::set_clientid(::google::protobuf::uint32 value) {
  set_has_clientid();
  clientid_ = value;
}

// optional uint64 SrcEpId = 2;
inline bool DssCltAddSrcSwitchNack::has_srcepid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DssCltAddSrcSwitchNack::set_has_srcepid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DssCltAddSrcSwitchNack::clear_has_srcepid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DssCltAddSrcSwitchNack::clear_srcepid() {
  srcepid_ = GOOGLE_ULONGLONG(0);
  clear_has_srcepid();
}
inline ::google::protobuf::uint64 DssCltAddSrcSwitchNack::srcepid() const {
  return srcepid_;
}
inline void DssCltAddSrcSwitchNack::set_srcepid(::google::protobuf::uint64 value) {
  set_has_srcepid();
  srcepid_ = value;
}

// optional .Dss.Event.DssNetAddr SrcAddr = 3;
inline bool DssCltAddSrcSwitchNack::has_srcaddr() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DssCltAddSrcSwitchNack::set_has_srcaddr() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DssCltAddSrcSwitchNack::clear_has_srcaddr() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DssCltAddSrcSwitchNack::clear_srcaddr() {
  if (srcaddr_ != NULL) srcaddr_->::Dss::Event::DssNetAddr::Clear();
  clear_has_srcaddr();
}
inline const ::Dss::Event::DssNetAddr& DssCltAddSrcSwitchNack::srcaddr() const {
  return srcaddr_ != NULL ? *srcaddr_ : *default_instance_->srcaddr_;
}
inline ::Dss::Event::DssNetAddr* DssCltAddSrcSwitchNack::mutable_srcaddr() {
  set_has_srcaddr();
  if (srcaddr_ == NULL) srcaddr_ = new ::Dss::Event::DssNetAddr;
  return srcaddr_;
}
inline ::Dss::Event::DssNetAddr* DssCltAddSrcSwitchNack::release_srcaddr() {
  clear_has_srcaddr();
  ::Dss::Event::DssNetAddr* temp = srcaddr_;
  srcaddr_ = NULL;
  return temp;
}
inline void DssCltAddSrcSwitchNack::set_allocated_srcaddr(::Dss::Event::DssNetAddr* srcaddr) {
  delete srcaddr_;
  srcaddr_ = srcaddr;
  if (srcaddr) {
    set_has_srcaddr();
  } else {
    clear_has_srcaddr();
  }
}

// optional uint64 DstEpId = 4;
inline bool DssCltAddSrcSwitchNack::has_dstepid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DssCltAddSrcSwitchNack::set_has_dstepid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DssCltAddSrcSwitchNack::clear_has_dstepid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DssCltAddSrcSwitchNack::clear_dstepid() {
  dstepid_ = GOOGLE_ULONGLONG(0);
  clear_has_dstepid();
}
inline ::google::protobuf::uint64 DssCltAddSrcSwitchNack::dstepid() const {
  return dstepid_;
}
inline void DssCltAddSrcSwitchNack::set_dstepid(::google::protobuf::uint64 value) {
  set_has_dstepid();
  dstepid_ = value;
}

// optional .Dss.Event.DssNetAddr DstAddr = 5;
inline bool DssCltAddSrcSwitchNack::has_dstaddr() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DssCltAddSrcSwitchNack::set_has_dstaddr() {
  _has_bits_[0] |= 0x00000010u;
}
inline void DssCltAddSrcSwitchNack::clear_has_dstaddr() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void DssCltAddSrcSwitchNack::clear_dstaddr() {
  if (dstaddr_ != NULL) dstaddr_->::Dss::Event::DssNetAddr::Clear();
  clear_has_dstaddr();
}
inline const ::Dss::Event::DssNetAddr& DssCltAddSrcSwitchNack::dstaddr() const {
  return dstaddr_ != NULL ? *dstaddr_ : *default_instance_->dstaddr_;
}
inline ::Dss::Event::DssNetAddr* DssCltAddSrcSwitchNack::mutable_dstaddr() {
  set_has_dstaddr();
  if (dstaddr_ == NULL) dstaddr_ = new ::Dss::Event::DssNetAddr;
  return dstaddr_;
}
inline ::Dss::Event::DssNetAddr* DssCltAddSrcSwitchNack::release_dstaddr() {
  clear_has_dstaddr();
  ::Dss::Event::DssNetAddr* temp = dstaddr_;
  dstaddr_ = NULL;
  return temp;
}
inline void DssCltAddSrcSwitchNack::set_allocated_dstaddr(::Dss::Event::DssNetAddr* dstaddr) {
  delete dstaddr_;
  dstaddr_ = dstaddr;
  if (dstaddr) {
    set_has_dstaddr();
  } else {
    clear_has_dstaddr();
  }
}

// optional .Dss.Event.DssNetAddr RcvAddr = 6;
inline bool DssCltAddSrcSwitchNack::has_rcvaddr() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void DssCltAddSrcSwitchNack::set_has_rcvaddr() {
  _has_bits_[0] |= 0x00000020u;
}
inline void DssCltAddSrcSwitchNack::clear_has_rcvaddr() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void DssCltAddSrcSwitchNack::clear_rcvaddr() {
  if (rcvaddr_ != NULL) rcvaddr_->::Dss::Event::DssNetAddr::Clear();
  clear_has_rcvaddr();
}
inline const ::Dss::Event::DssNetAddr& DssCltAddSrcSwitchNack::rcvaddr() const {
  return rcvaddr_ != NULL ? *rcvaddr_ : *default_instance_->rcvaddr_;
}
inline ::Dss::Event::DssNetAddr* DssCltAddSrcSwitchNack::mutable_rcvaddr() {
  set_has_rcvaddr();
  if (rcvaddr_ == NULL) rcvaddr_ = new ::Dss::Event::DssNetAddr;
  return rcvaddr_;
}
inline ::Dss::Event::DssNetAddr* DssCltAddSrcSwitchNack::release_rcvaddr() {
  clear_has_rcvaddr();
  ::Dss::Event::DssNetAddr* temp = rcvaddr_;
  rcvaddr_ = NULL;
  return temp;
}
inline void DssCltAddSrcSwitchNack::set_allocated_rcvaddr(::Dss::Event::DssNetAddr* rcvaddr) {
  delete rcvaddr_;
  rcvaddr_ = rcvaddr;
  if (rcvaddr) {
    set_has_rcvaddr();
  } else {
    clear_has_rcvaddr();
  }
}

// optional .Dss.Event.DsType dstype = 7;
inline bool DssCltAddSrcSwitchNack::has_dstype() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void DssCltAddSrcSwitchNack::set_has_dstype() {
  _has_bits_[0] |= 0x00000040u;
}
inline void DssCltAddSrcSwitchNack::clear_has_dstype() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void DssCltAddSrcSwitchNack::clear_dstype() {
  dstype_ = 0;
  clear_has_dstype();
}
inline ::Dss::Event::DsType DssCltAddSrcSwitchNack::dstype() const {
  return static_cast< ::Dss::Event::DsType >(dstype_);
}
inline void DssCltAddSrcSwitchNack::set_dstype(::Dss::Event::DsType value) {
  assert(::Dss::Event::DsType_IsValid(value));
  set_has_dstype();
  dstype_ = value;
}

// -------------------------------------------------------------------

// CltDssRemoveSwitchCmd

// optional uint32 ClientId = 1;
inline bool CltDssRemoveSwitchCmd::has_clientid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CltDssRemoveSwitchCmd::set_has_clientid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CltDssRemoveSwitchCmd::clear_has_clientid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CltDssRemoveSwitchCmd::clear_clientid() {
  clientid_ = 0u;
  clear_has_clientid();
}
inline ::google::protobuf::uint32 CltDssRemoveSwitchCmd::clientid() const {
  return clientid_;
}
inline void CltDssRemoveSwitchCmd::set_clientid(::google::protobuf::uint32 value) {
  set_has_clientid();
  clientid_ = value;
}

// optional uint64 SrcEpId = 2;
inline bool CltDssRemoveSwitchCmd::has_srcepid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CltDssRemoveSwitchCmd::set_has_srcepid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CltDssRemoveSwitchCmd::clear_has_srcepid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CltDssRemoveSwitchCmd::clear_srcepid() {
  srcepid_ = GOOGLE_ULONGLONG(0);
  clear_has_srcepid();
}
inline ::google::protobuf::uint64 CltDssRemoveSwitchCmd::srcepid() const {
  return srcepid_;
}
inline void CltDssRemoveSwitchCmd::set_srcepid(::google::protobuf::uint64 value) {
  set_has_srcepid();
  srcepid_ = value;
}

// optional .Dss.Event.DssNetAddr SrcAddr = 3;
inline bool CltDssRemoveSwitchCmd::has_srcaddr() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CltDssRemoveSwitchCmd::set_has_srcaddr() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CltDssRemoveSwitchCmd::clear_has_srcaddr() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CltDssRemoveSwitchCmd::clear_srcaddr() {
  if (srcaddr_ != NULL) srcaddr_->::Dss::Event::DssNetAddr::Clear();
  clear_has_srcaddr();
}
inline const ::Dss::Event::DssNetAddr& CltDssRemoveSwitchCmd::srcaddr() const {
  return srcaddr_ != NULL ? *srcaddr_ : *default_instance_->srcaddr_;
}
inline ::Dss::Event::DssNetAddr* CltDssRemoveSwitchCmd::mutable_srcaddr() {
  set_has_srcaddr();
  if (srcaddr_ == NULL) srcaddr_ = new ::Dss::Event::DssNetAddr;
  return srcaddr_;
}
inline ::Dss::Event::DssNetAddr* CltDssRemoveSwitchCmd::release_srcaddr() {
  clear_has_srcaddr();
  ::Dss::Event::DssNetAddr* temp = srcaddr_;
  srcaddr_ = NULL;
  return temp;
}
inline void CltDssRemoveSwitchCmd::set_allocated_srcaddr(::Dss::Event::DssNetAddr* srcaddr) {
  delete srcaddr_;
  srcaddr_ = srcaddr;
  if (srcaddr) {
    set_has_srcaddr();
  } else {
    clear_has_srcaddr();
  }
}

// optional uint64 DstEpId = 4;
inline bool CltDssRemoveSwitchCmd::has_dstepid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CltDssRemoveSwitchCmd::set_has_dstepid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CltDssRemoveSwitchCmd::clear_has_dstepid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CltDssRemoveSwitchCmd::clear_dstepid() {
  dstepid_ = GOOGLE_ULONGLONG(0);
  clear_has_dstepid();
}
inline ::google::protobuf::uint64 CltDssRemoveSwitchCmd::dstepid() const {
  return dstepid_;
}
inline void CltDssRemoveSwitchCmd::set_dstepid(::google::protobuf::uint64 value) {
  set_has_dstepid();
  dstepid_ = value;
}

// optional .Dss.Event.DssNetAddr DstAddr = 5;
inline bool CltDssRemoveSwitchCmd::has_dstaddr() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CltDssRemoveSwitchCmd::set_has_dstaddr() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CltDssRemoveSwitchCmd::clear_has_dstaddr() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CltDssRemoveSwitchCmd::clear_dstaddr() {
  if (dstaddr_ != NULL) dstaddr_->::Dss::Event::DssNetAddr::Clear();
  clear_has_dstaddr();
}
inline const ::Dss::Event::DssNetAddr& CltDssRemoveSwitchCmd::dstaddr() const {
  return dstaddr_ != NULL ? *dstaddr_ : *default_instance_->dstaddr_;
}
inline ::Dss::Event::DssNetAddr* CltDssRemoveSwitchCmd::mutable_dstaddr() {
  set_has_dstaddr();
  if (dstaddr_ == NULL) dstaddr_ = new ::Dss::Event::DssNetAddr;
  return dstaddr_;
}
inline ::Dss::Event::DssNetAddr* CltDssRemoveSwitchCmd::release_dstaddr() {
  clear_has_dstaddr();
  ::Dss::Event::DssNetAddr* temp = dstaddr_;
  dstaddr_ = NULL;
  return temp;
}
inline void CltDssRemoveSwitchCmd::set_allocated_dstaddr(::Dss::Event::DssNetAddr* dstaddr) {
  delete dstaddr_;
  dstaddr_ = dstaddr;
  if (dstaddr) {
    set_has_dstaddr();
  } else {
    clear_has_dstaddr();
  }
}

// optional .Dss.Event.DssNetAddr RcvAddr = 6;
inline bool CltDssRemoveSwitchCmd::has_rcvaddr() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CltDssRemoveSwitchCmd::set_has_rcvaddr() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CltDssRemoveSwitchCmd::clear_has_rcvaddr() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CltDssRemoveSwitchCmd::clear_rcvaddr() {
  if (rcvaddr_ != NULL) rcvaddr_->::Dss::Event::DssNetAddr::Clear();
  clear_has_rcvaddr();
}
inline const ::Dss::Event::DssNetAddr& CltDssRemoveSwitchCmd::rcvaddr() const {
  return rcvaddr_ != NULL ? *rcvaddr_ : *default_instance_->rcvaddr_;
}
inline ::Dss::Event::DssNetAddr* CltDssRemoveSwitchCmd::mutable_rcvaddr() {
  set_has_rcvaddr();
  if (rcvaddr_ == NULL) rcvaddr_ = new ::Dss::Event::DssNetAddr;
  return rcvaddr_;
}
inline ::Dss::Event::DssNetAddr* CltDssRemoveSwitchCmd::release_rcvaddr() {
  clear_has_rcvaddr();
  ::Dss::Event::DssNetAddr* temp = rcvaddr_;
  rcvaddr_ = NULL;
  return temp;
}
inline void CltDssRemoveSwitchCmd::set_allocated_rcvaddr(::Dss::Event::DssNetAddr* rcvaddr) {
  delete rcvaddr_;
  rcvaddr_ = rcvaddr;
  if (rcvaddr) {
    set_has_rcvaddr();
  } else {
    clear_has_rcvaddr();
  }
}

// optional .Dss.Event.DssNetAddr MapAddr = 7;
inline bool CltDssRemoveSwitchCmd::has_mapaddr() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CltDssRemoveSwitchCmd::set_has_mapaddr() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CltDssRemoveSwitchCmd::clear_has_mapaddr() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CltDssRemoveSwitchCmd::clear_mapaddr() {
  if (mapaddr_ != NULL) mapaddr_->::Dss::Event::DssNetAddr::Clear();
  clear_has_mapaddr();
}
inline const ::Dss::Event::DssNetAddr& CltDssRemoveSwitchCmd::mapaddr() const {
  return mapaddr_ != NULL ? *mapaddr_ : *default_instance_->mapaddr_;
}
inline ::Dss::Event::DssNetAddr* CltDssRemoveSwitchCmd::mutable_mapaddr() {
  set_has_mapaddr();
  if (mapaddr_ == NULL) mapaddr_ = new ::Dss::Event::DssNetAddr;
  return mapaddr_;
}
inline ::Dss::Event::DssNetAddr* CltDssRemoveSwitchCmd::release_mapaddr() {
  clear_has_mapaddr();
  ::Dss::Event::DssNetAddr* temp = mapaddr_;
  mapaddr_ = NULL;
  return temp;
}
inline void CltDssRemoveSwitchCmd::set_allocated_mapaddr(::Dss::Event::DssNetAddr* mapaddr) {
  delete mapaddr_;
  mapaddr_ = mapaddr;
  if (mapaddr) {
    set_has_mapaddr();
  } else {
    clear_has_mapaddr();
  }
}

// optional .Dss.Event.DsType dstype = 8;
inline bool CltDssRemoveSwitchCmd::has_dstype() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CltDssRemoveSwitchCmd::set_has_dstype() {
  _has_bits_[0] |= 0x00000080u;
}
inline void CltDssRemoveSwitchCmd::clear_has_dstype() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void CltDssRemoveSwitchCmd::clear_dstype() {
  dstype_ = 0;
  clear_has_dstype();
}
inline ::Dss::Event::DsType CltDssRemoveSwitchCmd::dstype() const {
  return static_cast< ::Dss::Event::DsType >(dstype_);
}
inline void CltDssRemoveSwitchCmd::set_dstype(::Dss::Event::DsType value) {
  assert(::Dss::Event::DsType_IsValid(value));
  set_has_dstype();
  dstype_ = value;
}

// -------------------------------------------------------------------

// CltDssAddDumpReq

// optional uint32 ClientId = 1;
inline bool CltDssAddDumpReq::has_clientid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CltDssAddDumpReq::set_has_clientid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CltDssAddDumpReq::clear_has_clientid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CltDssAddDumpReq::clear_clientid() {
  clientid_ = 0u;
  clear_has_clientid();
}
inline ::google::protobuf::uint32 CltDssAddDumpReq::clientid() const {
  return clientid_;
}
inline void CltDssAddDumpReq::set_clientid(::google::protobuf::uint32 value) {
  set_has_clientid();
  clientid_ = value;
}

// optional .Dss.Event.DssNetAddr RcvAddr = 2;
inline bool CltDssAddDumpReq::has_rcvaddr() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CltDssAddDumpReq::set_has_rcvaddr() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CltDssAddDumpReq::clear_has_rcvaddr() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CltDssAddDumpReq::clear_rcvaddr() {
  if (rcvaddr_ != NULL) rcvaddr_->::Dss::Event::DssNetAddr::Clear();
  clear_has_rcvaddr();
}
inline const ::Dss::Event::DssNetAddr& CltDssAddDumpReq::rcvaddr() const {
  return rcvaddr_ != NULL ? *rcvaddr_ : *default_instance_->rcvaddr_;
}
inline ::Dss::Event::DssNetAddr* CltDssAddDumpReq::mutable_rcvaddr() {
  set_has_rcvaddr();
  if (rcvaddr_ == NULL) rcvaddr_ = new ::Dss::Event::DssNetAddr;
  return rcvaddr_;
}
inline ::Dss::Event::DssNetAddr* CltDssAddDumpReq::release_rcvaddr() {
  clear_has_rcvaddr();
  ::Dss::Event::DssNetAddr* temp = rcvaddr_;
  rcvaddr_ = NULL;
  return temp;
}
inline void CltDssAddDumpReq::set_allocated_rcvaddr(::Dss::Event::DssNetAddr* rcvaddr) {
  delete rcvaddr_;
  rcvaddr_ = rcvaddr;
  if (rcvaddr) {
    set_has_rcvaddr();
  } else {
    clear_has_rcvaddr();
  }
}

// -------------------------------------------------------------------

// DssCltAddDumpAck

// optional uint32 ClientId = 1;
inline bool DssCltAddDumpAck::has_clientid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DssCltAddDumpAck::set_has_clientid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DssCltAddDumpAck::clear_has_clientid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DssCltAddDumpAck::clear_clientid() {
  clientid_ = 0u;
  clear_has_clientid();
}
inline ::google::protobuf::uint32 DssCltAddDumpAck::clientid() const {
  return clientid_;
}
inline void DssCltAddDumpAck::set_clientid(::google::protobuf::uint32 value) {
  set_has_clientid();
  clientid_ = value;
}

// optional .Dss.Event.DssNetAddr RcvAddr = 2;
inline bool DssCltAddDumpAck::has_rcvaddr() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DssCltAddDumpAck::set_has_rcvaddr() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DssCltAddDumpAck::clear_has_rcvaddr() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DssCltAddDumpAck::clear_rcvaddr() {
  if (rcvaddr_ != NULL) rcvaddr_->::Dss::Event::DssNetAddr::Clear();
  clear_has_rcvaddr();
}
inline const ::Dss::Event::DssNetAddr& DssCltAddDumpAck::rcvaddr() const {
  return rcvaddr_ != NULL ? *rcvaddr_ : *default_instance_->rcvaddr_;
}
inline ::Dss::Event::DssNetAddr* DssCltAddDumpAck::mutable_rcvaddr() {
  set_has_rcvaddr();
  if (rcvaddr_ == NULL) rcvaddr_ = new ::Dss::Event::DssNetAddr;
  return rcvaddr_;
}
inline ::Dss::Event::DssNetAddr* DssCltAddDumpAck::release_rcvaddr() {
  clear_has_rcvaddr();
  ::Dss::Event::DssNetAddr* temp = rcvaddr_;
  rcvaddr_ = NULL;
  return temp;
}
inline void DssCltAddDumpAck::set_allocated_rcvaddr(::Dss::Event::DssNetAddr* rcvaddr) {
  delete rcvaddr_;
  rcvaddr_ = rcvaddr;
  if (rcvaddr) {
    set_has_rcvaddr();
  } else {
    clear_has_rcvaddr();
  }
}

// -------------------------------------------------------------------

// DssCltAddDumpNack

// optional uint32 ClientId = 1;
inline bool DssCltAddDumpNack::has_clientid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DssCltAddDumpNack::set_has_clientid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DssCltAddDumpNack::clear_has_clientid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DssCltAddDumpNack::clear_clientid() {
  clientid_ = 0u;
  clear_has_clientid();
}
inline ::google::protobuf::uint32 DssCltAddDumpNack::clientid() const {
  return clientid_;
}
inline void DssCltAddDumpNack::set_clientid(::google::protobuf::uint32 value) {
  set_has_clientid();
  clientid_ = value;
}

// optional .Dss.Event.DssNetAddr RcvAddr = 2;
inline bool DssCltAddDumpNack::has_rcvaddr() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DssCltAddDumpNack::set_has_rcvaddr() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DssCltAddDumpNack::clear_has_rcvaddr() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DssCltAddDumpNack::clear_rcvaddr() {
  if (rcvaddr_ != NULL) rcvaddr_->::Dss::Event::DssNetAddr::Clear();
  clear_has_rcvaddr();
}
inline const ::Dss::Event::DssNetAddr& DssCltAddDumpNack::rcvaddr() const {
  return rcvaddr_ != NULL ? *rcvaddr_ : *default_instance_->rcvaddr_;
}
inline ::Dss::Event::DssNetAddr* DssCltAddDumpNack::mutable_rcvaddr() {
  set_has_rcvaddr();
  if (rcvaddr_ == NULL) rcvaddr_ = new ::Dss::Event::DssNetAddr;
  return rcvaddr_;
}
inline ::Dss::Event::DssNetAddr* DssCltAddDumpNack::release_rcvaddr() {
  clear_has_rcvaddr();
  ::Dss::Event::DssNetAddr* temp = rcvaddr_;
  rcvaddr_ = NULL;
  return temp;
}
inline void DssCltAddDumpNack::set_allocated_rcvaddr(::Dss::Event::DssNetAddr* rcvaddr) {
  delete rcvaddr_;
  rcvaddr_ = rcvaddr;
  if (rcvaddr) {
    set_has_rcvaddr();
  } else {
    clear_has_rcvaddr();
  }
}

// -------------------------------------------------------------------

// CltDssRemoveDumpCmd

// optional uint32 ClientId = 1;
inline bool CltDssRemoveDumpCmd::has_clientid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CltDssRemoveDumpCmd::set_has_clientid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CltDssRemoveDumpCmd::clear_has_clientid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CltDssRemoveDumpCmd::clear_clientid() {
  clientid_ = 0u;
  clear_has_clientid();
}
inline ::google::protobuf::uint32 CltDssRemoveDumpCmd::clientid() const {
  return clientid_;
}
inline void CltDssRemoveDumpCmd::set_clientid(::google::protobuf::uint32 value) {
  set_has_clientid();
  clientid_ = value;
}

// optional .Dss.Event.DssNetAddr RcvAddr = 2;
inline bool CltDssRemoveDumpCmd::has_rcvaddr() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CltDssRemoveDumpCmd::set_has_rcvaddr() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CltDssRemoveDumpCmd::clear_has_rcvaddr() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CltDssRemoveDumpCmd::clear_rcvaddr() {
  if (rcvaddr_ != NULL) rcvaddr_->::Dss::Event::DssNetAddr::Clear();
  clear_has_rcvaddr();
}
inline const ::Dss::Event::DssNetAddr& CltDssRemoveDumpCmd::rcvaddr() const {
  return rcvaddr_ != NULL ? *rcvaddr_ : *default_instance_->rcvaddr_;
}
inline ::Dss::Event::DssNetAddr* CltDssRemoveDumpCmd::mutable_rcvaddr() {
  set_has_rcvaddr();
  if (rcvaddr_ == NULL) rcvaddr_ = new ::Dss::Event::DssNetAddr;
  return rcvaddr_;
}
inline ::Dss::Event::DssNetAddr* CltDssRemoveDumpCmd::release_rcvaddr() {
  clear_has_rcvaddr();
  ::Dss::Event::DssNetAddr* temp = rcvaddr_;
  rcvaddr_ = NULL;
  return temp;
}
inline void CltDssRemoveDumpCmd::set_allocated_rcvaddr(::Dss::Event::DssNetAddr* rcvaddr) {
  delete rcvaddr_;
  rcvaddr_ = rcvaddr;
  if (rcvaddr) {
    set_has_rcvaddr();
  } else {
    clear_has_rcvaddr();
  }
}

// -------------------------------------------------------------------

// DssCltSrvLostNtf

// optional uint32 ClientId = 1;
inline bool DssCltSrvLostNtf::has_clientid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DssCltSrvLostNtf::set_has_clientid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DssCltSrvLostNtf::clear_has_clientid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DssCltSrvLostNtf::clear_clientid() {
  clientid_ = 0u;
  clear_has_clientid();
}
inline ::google::protobuf::uint32 DssCltSrvLostNtf::clientid() const {
  return clientid_;
}
inline void DssCltSrvLostNtf::set_clientid(::google::protobuf::uint32 value) {
  set_has_clientid();
  clientid_ = value;
}

// optional uint32 SrvHandle = 2;
inline bool DssCltSrvLostNtf::has_srvhandle() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DssCltSrvLostNtf::set_has_srvhandle() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DssCltSrvLostNtf::clear_has_srvhandle() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DssCltSrvLostNtf::clear_srvhandle() {
  srvhandle_ = 0u;
  clear_has_srvhandle();
}
inline ::google::protobuf::uint32 DssCltSrvLostNtf::srvhandle() const {
  return srvhandle_;
}
inline void DssCltSrvLostNtf::set_srvhandle(::google::protobuf::uint32 value) {
  set_has_srvhandle();
  srvhandle_ = value;
}

// -------------------------------------------------------------------

// DssCltSrvRegisterNtf

// optional uint32 ClientId = 1;
inline bool DssCltSrvRegisterNtf::has_clientid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DssCltSrvRegisterNtf::set_has_clientid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DssCltSrvRegisterNtf::clear_has_clientid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DssCltSrvRegisterNtf::clear_clientid() {
  clientid_ = 0u;
  clear_has_clientid();
}
inline ::google::protobuf::uint32 DssCltSrvRegisterNtf::clientid() const {
  return clientid_;
}
inline void DssCltSrvRegisterNtf::set_clientid(::google::protobuf::uint32 value) {
  set_has_clientid();
  clientid_ = value;
}

// optional uint32 SrvHandle = 2;
inline bool DssCltSrvRegisterNtf::has_srvhandle() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DssCltSrvRegisterNtf::set_has_srvhandle() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DssCltSrvRegisterNtf::clear_has_srvhandle() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DssCltSrvRegisterNtf::clear_srvhandle() {
  srvhandle_ = 0u;
  clear_has_srvhandle();
}
inline ::google::protobuf::uint32 DssCltSrvRegisterNtf::srvhandle() const {
  return srvhandle_;
}
inline void DssCltSrvRegisterNtf::set_srvhandle(::google::protobuf::uint32 value) {
  set_has_srvhandle();
  srvhandle_ = value;
}

// -------------------------------------------------------------------

// CltDssAliveDetectReq

// optional uint32 reserved = 1;
inline bool CltDssAliveDetectReq::has_reserved() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CltDssAliveDetectReq::set_has_reserved() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CltDssAliveDetectReq::clear_has_reserved() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CltDssAliveDetectReq::clear_reserved() {
  reserved_ = 0u;
  clear_has_reserved();
}
inline ::google::protobuf::uint32 CltDssAliveDetectReq::reserved() const {
  return reserved_;
}
inline void CltDssAliveDetectReq::set_reserved(::google::protobuf::uint32 value) {
  set_has_reserved();
  reserved_ = value;
}

// -------------------------------------------------------------------

// DssCltAliveDetectRsp

// optional uint32 reserved = 1;
inline bool DssCltAliveDetectRsp::has_reserved() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DssCltAliveDetectRsp::set_has_reserved() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DssCltAliveDetectRsp::clear_has_reserved() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DssCltAliveDetectRsp::clear_reserved() {
  reserved_ = 0u;
  clear_has_reserved();
}
inline ::google::protobuf::uint32 DssCltAliveDetectRsp::reserved() const {
  return reserved_;
}
inline void DssCltAliveDetectRsp::set_reserved(::google::protobuf::uint32 value) {
  set_has_reserved();
  reserved_ = value;
}

// -------------------------------------------------------------------

// CltDssAttachLanIpOfPortReq

// optional uint32 ClientId = 1;
inline bool CltDssAttachLanIpOfPortReq::has_clientid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CltDssAttachLanIpOfPortReq::set_has_clientid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CltDssAttachLanIpOfPortReq::clear_has_clientid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CltDssAttachLanIpOfPortReq::clear_clientid() {
  clientid_ = 0u;
  clear_has_clientid();
}
inline ::google::protobuf::uint32 CltDssAttachLanIpOfPortReq::clientid() const {
  return clientid_;
}
inline void CltDssAttachLanIpOfPortReq::set_clientid(::google::protobuf::uint32 value) {
  set_has_clientid();
  clientid_ = value;
}

// optional uint32 SrvHandle = 2;
inline bool CltDssAttachLanIpOfPortReq::has_srvhandle() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CltDssAttachLanIpOfPortReq::set_has_srvhandle() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CltDssAttachLanIpOfPortReq::clear_has_srvhandle() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CltDssAttachLanIpOfPortReq::clear_srvhandle() {
  srvhandle_ = 0u;
  clear_has_srvhandle();
}
inline ::google::protobuf::uint32 CltDssAttachLanIpOfPortReq::srvhandle() const {
  return srvhandle_;
}
inline void CltDssAttachLanIpOfPortReq::set_srvhandle(::google::protobuf::uint32 value) {
  set_has_srvhandle();
  srvhandle_ = value;
}

// optional uint32 Port = 3;
inline bool CltDssAttachLanIpOfPortReq::has_port() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CltDssAttachLanIpOfPortReq::set_has_port() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CltDssAttachLanIpOfPortReq::clear_has_port() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CltDssAttachLanIpOfPortReq::clear_port() {
  port_ = 0u;
  clear_has_port();
}
inline ::google::protobuf::uint32 CltDssAttachLanIpOfPortReq::port() const {
  return port_;
}
inline void CltDssAttachLanIpOfPortReq::set_port(::google::protobuf::uint32 value) {
  set_has_port();
  port_ = value;
}

// optional .Dss.Event.DssNetAddr subnet = 4;
inline bool CltDssAttachLanIpOfPortReq::has_subnet() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CltDssAttachLanIpOfPortReq::set_has_subnet() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CltDssAttachLanIpOfPortReq::clear_has_subnet() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CltDssAttachLanIpOfPortReq::clear_subnet() {
  if (subnet_ != NULL) subnet_->::Dss::Event::DssNetAddr::Clear();
  clear_has_subnet();
}
inline const ::Dss::Event::DssNetAddr& CltDssAttachLanIpOfPortReq::subnet() const {
  return subnet_ != NULL ? *subnet_ : *default_instance_->subnet_;
}
inline ::Dss::Event::DssNetAddr* CltDssAttachLanIpOfPortReq::mutable_subnet() {
  set_has_subnet();
  if (subnet_ == NULL) subnet_ = new ::Dss::Event::DssNetAddr;
  return subnet_;
}
inline ::Dss::Event::DssNetAddr* CltDssAttachLanIpOfPortReq::release_subnet() {
  clear_has_subnet();
  ::Dss::Event::DssNetAddr* temp = subnet_;
  subnet_ = NULL;
  return temp;
}
inline void CltDssAttachLanIpOfPortReq::set_allocated_subnet(::Dss::Event::DssNetAddr* subnet) {
  delete subnet_;
  subnet_ = subnet;
  if (subnet) {
    set_has_subnet();
  } else {
    clear_has_subnet();
  }
}

// -------------------------------------------------------------------

// DssCltAttachLanIpOfPortAck

// optional uint32 ClientId = 1;
inline bool DssCltAttachLanIpOfPortAck::has_clientid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DssCltAttachLanIpOfPortAck::set_has_clientid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DssCltAttachLanIpOfPortAck::clear_has_clientid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DssCltAttachLanIpOfPortAck::clear_clientid() {
  clientid_ = 0u;
  clear_has_clientid();
}
inline ::google::protobuf::uint32 DssCltAttachLanIpOfPortAck::clientid() const {
  return clientid_;
}
inline void DssCltAttachLanIpOfPortAck::set_clientid(::google::protobuf::uint32 value) {
  set_has_clientid();
  clientid_ = value;
}

// optional uint32 SrvHandle = 2;
inline bool DssCltAttachLanIpOfPortAck::has_srvhandle() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DssCltAttachLanIpOfPortAck::set_has_srvhandle() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DssCltAttachLanIpOfPortAck::clear_has_srvhandle() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DssCltAttachLanIpOfPortAck::clear_srvhandle() {
  srvhandle_ = 0u;
  clear_has_srvhandle();
}
inline ::google::protobuf::uint32 DssCltAttachLanIpOfPortAck::srvhandle() const {
  return srvhandle_;
}
inline void DssCltAttachLanIpOfPortAck::set_srvhandle(::google::protobuf::uint32 value) {
  set_has_srvhandle();
  srvhandle_ = value;
}

// optional uint32 Port = 3;
inline bool DssCltAttachLanIpOfPortAck::has_port() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DssCltAttachLanIpOfPortAck::set_has_port() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DssCltAttachLanIpOfPortAck::clear_has_port() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DssCltAttachLanIpOfPortAck::clear_port() {
  port_ = 0u;
  clear_has_port();
}
inline ::google::protobuf::uint32 DssCltAttachLanIpOfPortAck::port() const {
  return port_;
}
inline void DssCltAttachLanIpOfPortAck::set_port(::google::protobuf::uint32 value) {
  set_has_port();
  port_ = value;
}

// optional string IpAddr = 4;
inline bool DssCltAttachLanIpOfPortAck::has_ipaddr() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DssCltAttachLanIpOfPortAck::set_has_ipaddr() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DssCltAttachLanIpOfPortAck::clear_has_ipaddr() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DssCltAttachLanIpOfPortAck::clear_ipaddr() {
  if (ipaddr_ != &::google::protobuf::internal::kEmptyString) {
    ipaddr_->clear();
  }
  clear_has_ipaddr();
}
inline const ::std::string& DssCltAttachLanIpOfPortAck::ipaddr() const {
  return *ipaddr_;
}
inline void DssCltAttachLanIpOfPortAck::set_ipaddr(const ::std::string& value) {
  set_has_ipaddr();
  if (ipaddr_ == &::google::protobuf::internal::kEmptyString) {
    ipaddr_ = new ::std::string;
  }
  ipaddr_->assign(value);
}
inline void DssCltAttachLanIpOfPortAck::set_ipaddr(const char* value) {
  set_has_ipaddr();
  if (ipaddr_ == &::google::protobuf::internal::kEmptyString) {
    ipaddr_ = new ::std::string;
  }
  ipaddr_->assign(value);
}
inline void DssCltAttachLanIpOfPortAck::set_ipaddr(const char* value, size_t size) {
  set_has_ipaddr();
  if (ipaddr_ == &::google::protobuf::internal::kEmptyString) {
    ipaddr_ = new ::std::string;
  }
  ipaddr_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DssCltAttachLanIpOfPortAck::mutable_ipaddr() {
  set_has_ipaddr();
  if (ipaddr_ == &::google::protobuf::internal::kEmptyString) {
    ipaddr_ = new ::std::string;
  }
  return ipaddr_;
}
inline ::std::string* DssCltAttachLanIpOfPortAck::release_ipaddr() {
  clear_has_ipaddr();
  if (ipaddr_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ipaddr_;
    ipaddr_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DssCltAttachLanIpOfPortAck::set_allocated_ipaddr(::std::string* ipaddr) {
  if (ipaddr_ != &::google::protobuf::internal::kEmptyString) {
    delete ipaddr_;
  }
  if (ipaddr) {
    set_has_ipaddr();
    ipaddr_ = ipaddr;
  } else {
    clear_has_ipaddr();
    ipaddr_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// DssCltAttachLanIpOfPortNack

// optional uint32 ClientId = 1;
inline bool DssCltAttachLanIpOfPortNack::has_clientid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DssCltAttachLanIpOfPortNack::set_has_clientid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DssCltAttachLanIpOfPortNack::clear_has_clientid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DssCltAttachLanIpOfPortNack::clear_clientid() {
  clientid_ = 0u;
  clear_has_clientid();
}
inline ::google::protobuf::uint32 DssCltAttachLanIpOfPortNack::clientid() const {
  return clientid_;
}
inline void DssCltAttachLanIpOfPortNack::set_clientid(::google::protobuf::uint32 value) {
  set_has_clientid();
  clientid_ = value;
}

// optional uint32 SrvHandle = 2;
inline bool DssCltAttachLanIpOfPortNack::has_srvhandle() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DssCltAttachLanIpOfPortNack::set_has_srvhandle() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DssCltAttachLanIpOfPortNack::clear_has_srvhandle() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DssCltAttachLanIpOfPortNack::clear_srvhandle() {
  srvhandle_ = 0u;
  clear_has_srvhandle();
}
inline ::google::protobuf::uint32 DssCltAttachLanIpOfPortNack::srvhandle() const {
  return srvhandle_;
}
inline void DssCltAttachLanIpOfPortNack::set_srvhandle(::google::protobuf::uint32 value) {
  set_has_srvhandle();
  srvhandle_ = value;
}

// optional uint32 Port = 3;
inline bool DssCltAttachLanIpOfPortNack::has_port() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DssCltAttachLanIpOfPortNack::set_has_port() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DssCltAttachLanIpOfPortNack::clear_has_port() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DssCltAttachLanIpOfPortNack::clear_port() {
  port_ = 0u;
  clear_has_port();
}
inline ::google::protobuf::uint32 DssCltAttachLanIpOfPortNack::port() const {
  return port_;
}
inline void DssCltAttachLanIpOfPortNack::set_port(::google::protobuf::uint32 value) {
  set_has_port();
  port_ = value;
}

// optional .Dss.Event.DssNetAddr subnet = 4;
inline bool DssCltAttachLanIpOfPortNack::has_subnet() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DssCltAttachLanIpOfPortNack::set_has_subnet() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DssCltAttachLanIpOfPortNack::clear_has_subnet() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DssCltAttachLanIpOfPortNack::clear_subnet() {
  if (subnet_ != NULL) subnet_->::Dss::Event::DssNetAddr::Clear();
  clear_has_subnet();
}
inline const ::Dss::Event::DssNetAddr& DssCltAttachLanIpOfPortNack::subnet() const {
  return subnet_ != NULL ? *subnet_ : *default_instance_->subnet_;
}
inline ::Dss::Event::DssNetAddr* DssCltAttachLanIpOfPortNack::mutable_subnet() {
  set_has_subnet();
  if (subnet_ == NULL) subnet_ = new ::Dss::Event::DssNetAddr;
  return subnet_;
}
inline ::Dss::Event::DssNetAddr* DssCltAttachLanIpOfPortNack::release_subnet() {
  clear_has_subnet();
  ::Dss::Event::DssNetAddr* temp = subnet_;
  subnet_ = NULL;
  return temp;
}
inline void DssCltAttachLanIpOfPortNack::set_allocated_subnet(::Dss::Event::DssNetAddr* subnet) {
  delete subnet_;
  subnet_ = subnet;
  if (subnet) {
    set_has_subnet();
  } else {
    clear_has_subnet();
  }
}

// -------------------------------------------------------------------

// CltDssAttachWanIpOfPortReq

// optional uint32 ClientId = 1;
inline bool CltDssAttachWanIpOfPortReq::has_clientid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CltDssAttachWanIpOfPortReq::set_has_clientid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CltDssAttachWanIpOfPortReq::clear_has_clientid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CltDssAttachWanIpOfPortReq::clear_clientid() {
  clientid_ = 0u;
  clear_has_clientid();
}
inline ::google::protobuf::uint32 CltDssAttachWanIpOfPortReq::clientid() const {
  return clientid_;
}
inline void CltDssAttachWanIpOfPortReq::set_clientid(::google::protobuf::uint32 value) {
  set_has_clientid();
  clientid_ = value;
}

// optional uint32 SrvHandle = 2;
inline bool CltDssAttachWanIpOfPortReq::has_srvhandle() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CltDssAttachWanIpOfPortReq::set_has_srvhandle() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CltDssAttachWanIpOfPortReq::clear_has_srvhandle() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CltDssAttachWanIpOfPortReq::clear_srvhandle() {
  srvhandle_ = 0u;
  clear_has_srvhandle();
}
inline ::google::protobuf::uint32 CltDssAttachWanIpOfPortReq::srvhandle() const {
  return srvhandle_;
}
inline void CltDssAttachWanIpOfPortReq::set_srvhandle(::google::protobuf::uint32 value) {
  set_has_srvhandle();
  srvhandle_ = value;
}

// optional uint32 Port = 3;
inline bool CltDssAttachWanIpOfPortReq::has_port() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CltDssAttachWanIpOfPortReq::set_has_port() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CltDssAttachWanIpOfPortReq::clear_has_port() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CltDssAttachWanIpOfPortReq::clear_port() {
  port_ = 0u;
  clear_has_port();
}
inline ::google::protobuf::uint32 CltDssAttachWanIpOfPortReq::port() const {
  return port_;
}
inline void CltDssAttachWanIpOfPortReq::set_port(::google::protobuf::uint32 value) {
  set_has_port();
  port_ = value;
}

// optional .Dss.Event.CarrierType carriertype = 4;
inline bool CltDssAttachWanIpOfPortReq::has_carriertype() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CltDssAttachWanIpOfPortReq::set_has_carriertype() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CltDssAttachWanIpOfPortReq::clear_has_carriertype() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CltDssAttachWanIpOfPortReq::clear_carriertype() {
  carriertype_ = 0;
  clear_has_carriertype();
}
inline ::Dss::Event::CarrierType CltDssAttachWanIpOfPortReq::carriertype() const {
  return static_cast< ::Dss::Event::CarrierType >(carriertype_);
}
inline void CltDssAttachWanIpOfPortReq::set_carriertype(::Dss::Event::CarrierType value) {
  assert(::Dss::Event::CarrierType_IsValid(value));
  set_has_carriertype();
  carriertype_ = value;
}

// -------------------------------------------------------------------

// DssCltAttachWanIpOfPortAck

// optional uint32 ClientId = 1;
inline bool DssCltAttachWanIpOfPortAck::has_clientid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DssCltAttachWanIpOfPortAck::set_has_clientid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DssCltAttachWanIpOfPortAck::clear_has_clientid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DssCltAttachWanIpOfPortAck::clear_clientid() {
  clientid_ = 0u;
  clear_has_clientid();
}
inline ::google::protobuf::uint32 DssCltAttachWanIpOfPortAck::clientid() const {
  return clientid_;
}
inline void DssCltAttachWanIpOfPortAck::set_clientid(::google::protobuf::uint32 value) {
  set_has_clientid();
  clientid_ = value;
}

// optional uint32 SrvHandle = 2;
inline bool DssCltAttachWanIpOfPortAck::has_srvhandle() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DssCltAttachWanIpOfPortAck::set_has_srvhandle() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DssCltAttachWanIpOfPortAck::clear_has_srvhandle() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DssCltAttachWanIpOfPortAck::clear_srvhandle() {
  srvhandle_ = 0u;
  clear_has_srvhandle();
}
inline ::google::protobuf::uint32 DssCltAttachWanIpOfPortAck::srvhandle() const {
  return srvhandle_;
}
inline void DssCltAttachWanIpOfPortAck::set_srvhandle(::google::protobuf::uint32 value) {
  set_has_srvhandle();
  srvhandle_ = value;
}

// optional uint32 Port = 3;
inline bool DssCltAttachWanIpOfPortAck::has_port() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DssCltAttachWanIpOfPortAck::set_has_port() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DssCltAttachWanIpOfPortAck::clear_has_port() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DssCltAttachWanIpOfPortAck::clear_port() {
  port_ = 0u;
  clear_has_port();
}
inline ::google::protobuf::uint32 DssCltAttachWanIpOfPortAck::port() const {
  return port_;
}
inline void DssCltAttachWanIpOfPortAck::set_port(::google::protobuf::uint32 value) {
  set_has_port();
  port_ = value;
}

// optional string IpAddr = 4;
inline bool DssCltAttachWanIpOfPortAck::has_ipaddr() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DssCltAttachWanIpOfPortAck::set_has_ipaddr() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DssCltAttachWanIpOfPortAck::clear_has_ipaddr() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DssCltAttachWanIpOfPortAck::clear_ipaddr() {
  if (ipaddr_ != &::google::protobuf::internal::kEmptyString) {
    ipaddr_->clear();
  }
  clear_has_ipaddr();
}
inline const ::std::string& DssCltAttachWanIpOfPortAck::ipaddr() const {
  return *ipaddr_;
}
inline void DssCltAttachWanIpOfPortAck::set_ipaddr(const ::std::string& value) {
  set_has_ipaddr();
  if (ipaddr_ == &::google::protobuf::internal::kEmptyString) {
    ipaddr_ = new ::std::string;
  }
  ipaddr_->assign(value);
}
inline void DssCltAttachWanIpOfPortAck::set_ipaddr(const char* value) {
  set_has_ipaddr();
  if (ipaddr_ == &::google::protobuf::internal::kEmptyString) {
    ipaddr_ = new ::std::string;
  }
  ipaddr_->assign(value);
}
inline void DssCltAttachWanIpOfPortAck::set_ipaddr(const char* value, size_t size) {
  set_has_ipaddr();
  if (ipaddr_ == &::google::protobuf::internal::kEmptyString) {
    ipaddr_ = new ::std::string;
  }
  ipaddr_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DssCltAttachWanIpOfPortAck::mutable_ipaddr() {
  set_has_ipaddr();
  if (ipaddr_ == &::google::protobuf::internal::kEmptyString) {
    ipaddr_ = new ::std::string;
  }
  return ipaddr_;
}
inline ::std::string* DssCltAttachWanIpOfPortAck::release_ipaddr() {
  clear_has_ipaddr();
  if (ipaddr_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ipaddr_;
    ipaddr_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DssCltAttachWanIpOfPortAck::set_allocated_ipaddr(::std::string* ipaddr) {
  if (ipaddr_ != &::google::protobuf::internal::kEmptyString) {
    delete ipaddr_;
  }
  if (ipaddr) {
    set_has_ipaddr();
    ipaddr_ = ipaddr;
  } else {
    clear_has_ipaddr();
    ipaddr_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// DssCltAttachWanIpOfPortNack

// optional uint32 ClientId = 1;
inline bool DssCltAttachWanIpOfPortNack::has_clientid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DssCltAttachWanIpOfPortNack::set_has_clientid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DssCltAttachWanIpOfPortNack::clear_has_clientid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DssCltAttachWanIpOfPortNack::clear_clientid() {
  clientid_ = 0u;
  clear_has_clientid();
}
inline ::google::protobuf::uint32 DssCltAttachWanIpOfPortNack::clientid() const {
  return clientid_;
}
inline void DssCltAttachWanIpOfPortNack::set_clientid(::google::protobuf::uint32 value) {
  set_has_clientid();
  clientid_ = value;
}

// optional uint32 SrvHandle = 2;
inline bool DssCltAttachWanIpOfPortNack::has_srvhandle() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DssCltAttachWanIpOfPortNack::set_has_srvhandle() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DssCltAttachWanIpOfPortNack::clear_has_srvhandle() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DssCltAttachWanIpOfPortNack::clear_srvhandle() {
  srvhandle_ = 0u;
  clear_has_srvhandle();
}
inline ::google::protobuf::uint32 DssCltAttachWanIpOfPortNack::srvhandle() const {
  return srvhandle_;
}
inline void DssCltAttachWanIpOfPortNack::set_srvhandle(::google::protobuf::uint32 value) {
  set_has_srvhandle();
  srvhandle_ = value;
}

// optional uint32 Port = 3;
inline bool DssCltAttachWanIpOfPortNack::has_port() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DssCltAttachWanIpOfPortNack::set_has_port() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DssCltAttachWanIpOfPortNack::clear_has_port() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DssCltAttachWanIpOfPortNack::clear_port() {
  port_ = 0u;
  clear_has_port();
}
inline ::google::protobuf::uint32 DssCltAttachWanIpOfPortNack::port() const {
  return port_;
}
inline void DssCltAttachWanIpOfPortNack::set_port(::google::protobuf::uint32 value) {
  set_has_port();
  port_ = value;
}

// optional .Dss.Event.CarrierType carriertype = 4;
inline bool DssCltAttachWanIpOfPortNack::has_carriertype() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DssCltAttachWanIpOfPortNack::set_has_carriertype() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DssCltAttachWanIpOfPortNack::clear_has_carriertype() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DssCltAttachWanIpOfPortNack::clear_carriertype() {
  carriertype_ = 0;
  clear_has_carriertype();
}
inline ::Dss::Event::CarrierType DssCltAttachWanIpOfPortNack::carriertype() const {
  return static_cast< ::Dss::Event::CarrierType >(carriertype_);
}
inline void DssCltAttachWanIpOfPortNack::set_carriertype(::Dss::Event::CarrierType value) {
  assert(::Dss::Event::CarrierType_IsValid(value));
  set_has_carriertype();
  carriertype_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace Event
}  // namespace Dss

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_dssevent_2eproto__INCLUDED
