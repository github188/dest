// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: dssevstruct.proto

#ifndef PROTOBUF_dssevstruct_2eproto__INCLUDED
#define PROTOBUF_dssevstruct_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
#include "dssevenum.pb.h"
// @@protoc_insertion_point(includes)

namespace Dss {
namespace Event {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_dssevstruct_2eproto();
void protobuf_AssignDesc_dssevstruct_2eproto();
void protobuf_ShutdownFile_dssevstruct_2eproto();

class DssMessageWrap;
class DssNetAddr;
class ApplyLanPort;
class ApplyWanPort;
class ApplyLanPortReply;
class ApplyWanPortReply;
class SecretKey;

// ===================================================================

class DssMessageWrap : public ::google::protobuf::Message {
 public:
  DssMessageWrap();
  virtual ~DssMessageWrap();

  DssMessageWrap(const DssMessageWrap& from);

  inline DssMessageWrap& operator=(const DssMessageWrap& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DssMessageWrap& default_instance();

  void Swap(DssMessageWrap* other);

  // implements Message ----------------------------------------------

  DssMessageWrap* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Dss.Event.CltDssEvent event = 1;
  inline bool has_event() const;
  inline void clear_event();
  static const int kEventFieldNumber = 1;
  inline ::Dss::Event::CltDssEvent event() const;
  inline void set_event(::Dss::Event::CltDssEvent value);

  // optional bytes message_body = 2;
  inline bool has_message_body() const;
  inline void clear_message_body();
  static const int kMessageBodyFieldNumber = 2;
  inline const ::std::string& message_body() const;
  inline void set_message_body(const ::std::string& value);
  inline void set_message_body(const char* value);
  inline void set_message_body(const void* value, size_t size);
  inline ::std::string* mutable_message_body();
  inline ::std::string* release_message_body();
  inline void set_allocated_message_body(::std::string* message_body);

  // optional bytes context = 3;
  inline bool has_context() const;
  inline void clear_context();
  static const int kContextFieldNumber = 3;
  inline const ::std::string& context() const;
  inline void set_context(const ::std::string& value);
  inline void set_context(const char* value);
  inline void set_context(const void* value, size_t size);
  inline ::std::string* mutable_context();
  inline ::std::string* release_context();
  inline void set_allocated_context(::std::string* context);

  // @@protoc_insertion_point(class_scope:Dss.Event.DssMessageWrap)
 private:
  inline void set_has_event();
  inline void clear_has_event();
  inline void set_has_message_body();
  inline void clear_has_message_body();
  inline void set_has_context();
  inline void clear_has_context();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* message_body_;
  ::std::string* context_;
  int event_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_dssevstruct_2eproto();
  friend void protobuf_AssignDesc_dssevstruct_2eproto();
  friend void protobuf_ShutdownFile_dssevstruct_2eproto();

  void InitAsDefaultInstance();
  static DssMessageWrap* default_instance_;
};
// -------------------------------------------------------------------

class DssNetAddr : public ::google::protobuf::Message {
 public:
  DssNetAddr();
  virtual ~DssNetAddr();

  DssNetAddr(const DssNetAddr& from);

  inline DssNetAddr& operator=(const DssNetAddr& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DssNetAddr& default_instance();

  void Swap(DssNetAddr* other);

  // implements Message ----------------------------------------------

  DssNetAddr* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string IpAddr = 1;
  inline bool has_ipaddr() const;
  inline void clear_ipaddr();
  static const int kIpAddrFieldNumber = 1;
  inline const ::std::string& ipaddr() const;
  inline void set_ipaddr(const ::std::string& value);
  inline void set_ipaddr(const char* value);
  inline void set_ipaddr(const char* value, size_t size);
  inline ::std::string* mutable_ipaddr();
  inline ::std::string* release_ipaddr();
  inline void set_allocated_ipaddr(::std::string* ipaddr);

  // optional string IpMask = 2;
  inline bool has_ipmask() const;
  inline void clear_ipmask();
  static const int kIpMaskFieldNumber = 2;
  inline const ::std::string& ipmask() const;
  inline void set_ipmask(const ::std::string& value);
  inline void set_ipmask(const char* value);
  inline void set_ipmask(const char* value, size_t size);
  inline ::std::string* mutable_ipmask();
  inline ::std::string* release_ipmask();
  inline void set_allocated_ipmask(::std::string* ipmask);

  // optional .Dss.Event.iptype Type = 3;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 3;
  inline ::Dss::Event::iptype type() const;
  inline void set_type(::Dss::Event::iptype value);

  // optional uint32 Port = 4;
  inline bool has_port() const;
  inline void clear_port();
  static const int kPortFieldNumber = 4;
  inline ::google::protobuf::uint32 port() const;
  inline void set_port(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Dss.Event.DssNetAddr)
 private:
  inline void set_has_ipaddr();
  inline void clear_has_ipaddr();
  inline void set_has_ipmask();
  inline void clear_has_ipmask();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_port();
  inline void clear_has_port();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* ipaddr_;
  ::std::string* ipmask_;
  int type_;
  ::google::protobuf::uint32 port_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_dssevstruct_2eproto();
  friend void protobuf_AssignDesc_dssevstruct_2eproto();
  friend void protobuf_ShutdownFile_dssevstruct_2eproto();

  void InitAsDefaultInstance();
  static DssNetAddr* default_instance_;
};
// -------------------------------------------------------------------

class ApplyLanPort : public ::google::protobuf::Message {
 public:
  ApplyLanPort();
  virtual ~ApplyLanPort();

  ApplyLanPort(const ApplyLanPort& from);

  inline ApplyLanPort& operator=(const ApplyLanPort& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ApplyLanPort& default_instance();

  void Swap(ApplyLanPort* other);

  // implements Message ----------------------------------------------

  ApplyLanPort* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Dss.Event.DssNetAddr reqSubnet = 1;
  inline bool has_reqsubnet() const;
  inline void clear_reqsubnet();
  static const int kReqSubnetFieldNumber = 1;
  inline const ::Dss::Event::DssNetAddr& reqsubnet() const;
  inline ::Dss::Event::DssNetAddr* mutable_reqsubnet();
  inline ::Dss::Event::DssNetAddr* release_reqsubnet();
  inline void set_allocated_reqsubnet(::Dss::Event::DssNetAddr* reqsubnet);

  // @@protoc_insertion_point(class_scope:Dss.Event.ApplyLanPort)
 private:
  inline void set_has_reqsubnet();
  inline void clear_has_reqsubnet();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Dss::Event::DssNetAddr* reqsubnet_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_dssevstruct_2eproto();
  friend void protobuf_AssignDesc_dssevstruct_2eproto();
  friend void protobuf_ShutdownFile_dssevstruct_2eproto();

  void InitAsDefaultInstance();
  static ApplyLanPort* default_instance_;
};
// -------------------------------------------------------------------

class ApplyWanPort : public ::google::protobuf::Message {
 public:
  ApplyWanPort();
  virtual ~ApplyWanPort();

  ApplyWanPort(const ApplyWanPort& from);

  inline ApplyWanPort& operator=(const ApplyWanPort& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ApplyWanPort& default_instance();

  void Swap(ApplyWanPort* other);

  // implements Message ----------------------------------------------

  ApplyWanPort* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Dss.Event.CarrierType carriertype = 1;
  inline bool has_carriertype() const;
  inline void clear_carriertype();
  static const int kCarriertypeFieldNumber = 1;
  inline ::Dss::Event::CarrierType carriertype() const;
  inline void set_carriertype(::Dss::Event::CarrierType value);

  // @@protoc_insertion_point(class_scope:Dss.Event.ApplyWanPort)
 private:
  inline void set_has_carriertype();
  inline void clear_has_carriertype();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int carriertype_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_dssevstruct_2eproto();
  friend void protobuf_AssignDesc_dssevstruct_2eproto();
  friend void protobuf_ShutdownFile_dssevstruct_2eproto();

  void InitAsDefaultInstance();
  static ApplyWanPort* default_instance_;
};
// -------------------------------------------------------------------

class ApplyLanPortReply : public ::google::protobuf::Message {
 public:
  ApplyLanPortReply();
  virtual ~ApplyLanPortReply();

  ApplyLanPortReply(const ApplyLanPortReply& from);

  inline ApplyLanPortReply& operator=(const ApplyLanPortReply& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ApplyLanPortReply& default_instance();

  void Swap(ApplyLanPortReply* other);

  // implements Message ----------------------------------------------

  ApplyLanPortReply* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 ServerHandle = 1;
  inline bool has_serverhandle() const;
  inline void clear_serverhandle();
  static const int kServerHandleFieldNumber = 1;
  inline ::google::protobuf::uint32 serverhandle() const;
  inline void set_serverhandle(::google::protobuf::uint32 value);

  // optional .Dss.Event.DssNetAddr portAddr = 2;
  inline bool has_portaddr() const;
  inline void clear_portaddr();
  static const int kPortAddrFieldNumber = 2;
  inline const ::Dss::Event::DssNetAddr& portaddr() const;
  inline ::Dss::Event::DssNetAddr* mutable_portaddr();
  inline ::Dss::Event::DssNetAddr* release_portaddr();
  inline void set_allocated_portaddr(::Dss::Event::DssNetAddr* portaddr);

  // optional bool reqSucceed = 3;
  inline bool has_reqsucceed() const;
  inline void clear_reqsucceed();
  static const int kReqSucceedFieldNumber = 3;
  inline bool reqsucceed() const;
  inline void set_reqsucceed(bool value);

  // @@protoc_insertion_point(class_scope:Dss.Event.ApplyLanPortReply)
 private:
  inline void set_has_serverhandle();
  inline void clear_has_serverhandle();
  inline void set_has_portaddr();
  inline void clear_has_portaddr();
  inline void set_has_reqsucceed();
  inline void clear_has_reqsucceed();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Dss::Event::DssNetAddr* portaddr_;
  ::google::protobuf::uint32 serverhandle_;
  bool reqsucceed_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_dssevstruct_2eproto();
  friend void protobuf_AssignDesc_dssevstruct_2eproto();
  friend void protobuf_ShutdownFile_dssevstruct_2eproto();

  void InitAsDefaultInstance();
  static ApplyLanPortReply* default_instance_;
};
// -------------------------------------------------------------------

class ApplyWanPortReply : public ::google::protobuf::Message {
 public:
  ApplyWanPortReply();
  virtual ~ApplyWanPortReply();

  ApplyWanPortReply(const ApplyWanPortReply& from);

  inline ApplyWanPortReply& operator=(const ApplyWanPortReply& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ApplyWanPortReply& default_instance();

  void Swap(ApplyWanPortReply* other);

  // implements Message ----------------------------------------------

  ApplyWanPortReply* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Dss.Event.CarrierType carriertype = 1;
  inline bool has_carriertype() const;
  inline void clear_carriertype();
  static const int kCarriertypeFieldNumber = 1;
  inline ::Dss::Event::CarrierType carriertype() const;
  inline void set_carriertype(::Dss::Event::CarrierType value);

  // optional uint32 ServerHandle = 2;
  inline bool has_serverhandle() const;
  inline void clear_serverhandle();
  static const int kServerHandleFieldNumber = 2;
  inline ::google::protobuf::uint32 serverhandle() const;
  inline void set_serverhandle(::google::protobuf::uint32 value);

  // optional .Dss.Event.DssNetAddr portAddr = 3;
  inline bool has_portaddr() const;
  inline void clear_portaddr();
  static const int kPortAddrFieldNumber = 3;
  inline const ::Dss::Event::DssNetAddr& portaddr() const;
  inline ::Dss::Event::DssNetAddr* mutable_portaddr();
  inline ::Dss::Event::DssNetAddr* release_portaddr();
  inline void set_allocated_portaddr(::Dss::Event::DssNetAddr* portaddr);

  // optional bool reqSucceed = 4;
  inline bool has_reqsucceed() const;
  inline void clear_reqsucceed();
  static const int kReqSucceedFieldNumber = 4;
  inline bool reqsucceed() const;
  inline void set_reqsucceed(bool value);

  // @@protoc_insertion_point(class_scope:Dss.Event.ApplyWanPortReply)
 private:
  inline void set_has_carriertype();
  inline void clear_has_carriertype();
  inline void set_has_serverhandle();
  inline void clear_has_serverhandle();
  inline void set_has_portaddr();
  inline void clear_has_portaddr();
  inline void set_has_reqsucceed();
  inline void clear_has_reqsucceed();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int carriertype_;
  ::google::protobuf::uint32 serverhandle_;
  ::Dss::Event::DssNetAddr* portaddr_;
  bool reqsucceed_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_dssevstruct_2eproto();
  friend void protobuf_AssignDesc_dssevstruct_2eproto();
  friend void protobuf_ShutdownFile_dssevstruct_2eproto();

  void InitAsDefaultInstance();
  static ApplyWanPortReply* default_instance_;
};
// -------------------------------------------------------------------

class SecretKey : public ::google::protobuf::Message {
 public:
  SecretKey();
  virtual ~SecretKey();

  SecretKey(const SecretKey& from);

  inline SecretKey& operator=(const SecretKey& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SecretKey& default_instance();

  void Swap(SecretKey* other);

  // implements Message ----------------------------------------------

  SecretKey* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes key = 1;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 1;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const void* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();
  inline void set_allocated_key(::std::string* key);

  // optional uint32 keylen = 2;
  inline bool has_keylen() const;
  inline void clear_keylen();
  static const int kKeylenFieldNumber = 2;
  inline ::google::protobuf::uint32 keylen() const;
  inline void set_keylen(::google::protobuf::uint32 value);

  // optional .Dss.Event.SecMode ModeID = 3;
  inline bool has_modeid() const;
  inline void clear_modeid();
  static const int kModeIDFieldNumber = 3;
  inline ::Dss::Event::SecMode modeid() const;
  inline void set_modeid(::Dss::Event::SecMode value);

  // optional .Dss.Event.SecAlg AlgID = 4;
  inline bool has_algid() const;
  inline void clear_algid();
  static const int kAlgIDFieldNumber = 4;
  inline ::Dss::Event::SecAlg algid() const;
  inline void set_algid(::Dss::Event::SecAlg value);

  // @@protoc_insertion_point(class_scope:Dss.Event.SecretKey)
 private:
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_keylen();
  inline void clear_has_keylen();
  inline void set_has_modeid();
  inline void clear_has_modeid();
  inline void set_has_algid();
  inline void clear_has_algid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* key_;
  ::google::protobuf::uint32 keylen_;
  int modeid_;
  int algid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_dssevstruct_2eproto();
  friend void protobuf_AssignDesc_dssevstruct_2eproto();
  friend void protobuf_ShutdownFile_dssevstruct_2eproto();

  void InitAsDefaultInstance();
  static SecretKey* default_instance_;
};
// ===================================================================


// ===================================================================

// DssMessageWrap

// optional .Dss.Event.CltDssEvent event = 1;
inline bool DssMessageWrap::has_event() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DssMessageWrap::set_has_event() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DssMessageWrap::clear_has_event() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DssMessageWrap::clear_event() {
  event_ = 1;
  clear_has_event();
}
inline ::Dss::Event::CltDssEvent DssMessageWrap::event() const {
  return static_cast< ::Dss::Event::CltDssEvent >(event_);
}
inline void DssMessageWrap::set_event(::Dss::Event::CltDssEvent value) {
  assert(::Dss::Event::CltDssEvent_IsValid(value));
  set_has_event();
  event_ = value;
}

// optional bytes message_body = 2;
inline bool DssMessageWrap::has_message_body() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DssMessageWrap::set_has_message_body() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DssMessageWrap::clear_has_message_body() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DssMessageWrap::clear_message_body() {
  if (message_body_ != &::google::protobuf::internal::kEmptyString) {
    message_body_->clear();
  }
  clear_has_message_body();
}
inline const ::std::string& DssMessageWrap::message_body() const {
  return *message_body_;
}
inline void DssMessageWrap::set_message_body(const ::std::string& value) {
  set_has_message_body();
  if (message_body_ == &::google::protobuf::internal::kEmptyString) {
    message_body_ = new ::std::string;
  }
  message_body_->assign(value);
}
inline void DssMessageWrap::set_message_body(const char* value) {
  set_has_message_body();
  if (message_body_ == &::google::protobuf::internal::kEmptyString) {
    message_body_ = new ::std::string;
  }
  message_body_->assign(value);
}
inline void DssMessageWrap::set_message_body(const void* value, size_t size) {
  set_has_message_body();
  if (message_body_ == &::google::protobuf::internal::kEmptyString) {
    message_body_ = new ::std::string;
  }
  message_body_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DssMessageWrap::mutable_message_body() {
  set_has_message_body();
  if (message_body_ == &::google::protobuf::internal::kEmptyString) {
    message_body_ = new ::std::string;
  }
  return message_body_;
}
inline ::std::string* DssMessageWrap::release_message_body() {
  clear_has_message_body();
  if (message_body_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = message_body_;
    message_body_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DssMessageWrap::set_allocated_message_body(::std::string* message_body) {
  if (message_body_ != &::google::protobuf::internal::kEmptyString) {
    delete message_body_;
  }
  if (message_body) {
    set_has_message_body();
    message_body_ = message_body;
  } else {
    clear_has_message_body();
    message_body_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes context = 3;
inline bool DssMessageWrap::has_context() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DssMessageWrap::set_has_context() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DssMessageWrap::clear_has_context() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DssMessageWrap::clear_context() {
  if (context_ != &::google::protobuf::internal::kEmptyString) {
    context_->clear();
  }
  clear_has_context();
}
inline const ::std::string& DssMessageWrap::context() const {
  return *context_;
}
inline void DssMessageWrap::set_context(const ::std::string& value) {
  set_has_context();
  if (context_ == &::google::protobuf::internal::kEmptyString) {
    context_ = new ::std::string;
  }
  context_->assign(value);
}
inline void DssMessageWrap::set_context(const char* value) {
  set_has_context();
  if (context_ == &::google::protobuf::internal::kEmptyString) {
    context_ = new ::std::string;
  }
  context_->assign(value);
}
inline void DssMessageWrap::set_context(const void* value, size_t size) {
  set_has_context();
  if (context_ == &::google::protobuf::internal::kEmptyString) {
    context_ = new ::std::string;
  }
  context_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DssMessageWrap::mutable_context() {
  set_has_context();
  if (context_ == &::google::protobuf::internal::kEmptyString) {
    context_ = new ::std::string;
  }
  return context_;
}
inline ::std::string* DssMessageWrap::release_context() {
  clear_has_context();
  if (context_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = context_;
    context_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DssMessageWrap::set_allocated_context(::std::string* context) {
  if (context_ != &::google::protobuf::internal::kEmptyString) {
    delete context_;
  }
  if (context) {
    set_has_context();
    context_ = context;
  } else {
    clear_has_context();
    context_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// DssNetAddr

// optional string IpAddr = 1;
inline bool DssNetAddr::has_ipaddr() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DssNetAddr::set_has_ipaddr() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DssNetAddr::clear_has_ipaddr() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DssNetAddr::clear_ipaddr() {
  if (ipaddr_ != &::google::protobuf::internal::kEmptyString) {
    ipaddr_->clear();
  }
  clear_has_ipaddr();
}
inline const ::std::string& DssNetAddr::ipaddr() const {
  return *ipaddr_;
}
inline void DssNetAddr::set_ipaddr(const ::std::string& value) {
  set_has_ipaddr();
  if (ipaddr_ == &::google::protobuf::internal::kEmptyString) {
    ipaddr_ = new ::std::string;
  }
  ipaddr_->assign(value);
}
inline void DssNetAddr::set_ipaddr(const char* value) {
  set_has_ipaddr();
  if (ipaddr_ == &::google::protobuf::internal::kEmptyString) {
    ipaddr_ = new ::std::string;
  }
  ipaddr_->assign(value);
}
inline void DssNetAddr::set_ipaddr(const char* value, size_t size) {
  set_has_ipaddr();
  if (ipaddr_ == &::google::protobuf::internal::kEmptyString) {
    ipaddr_ = new ::std::string;
  }
  ipaddr_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DssNetAddr::mutable_ipaddr() {
  set_has_ipaddr();
  if (ipaddr_ == &::google::protobuf::internal::kEmptyString) {
    ipaddr_ = new ::std::string;
  }
  return ipaddr_;
}
inline ::std::string* DssNetAddr::release_ipaddr() {
  clear_has_ipaddr();
  if (ipaddr_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ipaddr_;
    ipaddr_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DssNetAddr::set_allocated_ipaddr(::std::string* ipaddr) {
  if (ipaddr_ != &::google::protobuf::internal::kEmptyString) {
    delete ipaddr_;
  }
  if (ipaddr) {
    set_has_ipaddr();
    ipaddr_ = ipaddr;
  } else {
    clear_has_ipaddr();
    ipaddr_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string IpMask = 2;
inline bool DssNetAddr::has_ipmask() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DssNetAddr::set_has_ipmask() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DssNetAddr::clear_has_ipmask() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DssNetAddr::clear_ipmask() {
  if (ipmask_ != &::google::protobuf::internal::kEmptyString) {
    ipmask_->clear();
  }
  clear_has_ipmask();
}
inline const ::std::string& DssNetAddr::ipmask() const {
  return *ipmask_;
}
inline void DssNetAddr::set_ipmask(const ::std::string& value) {
  set_has_ipmask();
  if (ipmask_ == &::google::protobuf::internal::kEmptyString) {
    ipmask_ = new ::std::string;
  }
  ipmask_->assign(value);
}
inline void DssNetAddr::set_ipmask(const char* value) {
  set_has_ipmask();
  if (ipmask_ == &::google::protobuf::internal::kEmptyString) {
    ipmask_ = new ::std::string;
  }
  ipmask_->assign(value);
}
inline void DssNetAddr::set_ipmask(const char* value, size_t size) {
  set_has_ipmask();
  if (ipmask_ == &::google::protobuf::internal::kEmptyString) {
    ipmask_ = new ::std::string;
  }
  ipmask_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DssNetAddr::mutable_ipmask() {
  set_has_ipmask();
  if (ipmask_ == &::google::protobuf::internal::kEmptyString) {
    ipmask_ = new ::std::string;
  }
  return ipmask_;
}
inline ::std::string* DssNetAddr::release_ipmask() {
  clear_has_ipmask();
  if (ipmask_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ipmask_;
    ipmask_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DssNetAddr::set_allocated_ipmask(::std::string* ipmask) {
  if (ipmask_ != &::google::protobuf::internal::kEmptyString) {
    delete ipmask_;
  }
  if (ipmask) {
    set_has_ipmask();
    ipmask_ = ipmask;
  } else {
    clear_has_ipmask();
    ipmask_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .Dss.Event.iptype Type = 3;
inline bool DssNetAddr::has_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DssNetAddr::set_has_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DssNetAddr::clear_has_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DssNetAddr::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::Dss::Event::iptype DssNetAddr::type() const {
  return static_cast< ::Dss::Event::iptype >(type_);
}
inline void DssNetAddr::set_type(::Dss::Event::iptype value) {
  assert(::Dss::Event::iptype_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional uint32 Port = 4;
inline bool DssNetAddr::has_port() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DssNetAddr::set_has_port() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DssNetAddr::clear_has_port() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DssNetAddr::clear_port() {
  port_ = 0u;
  clear_has_port();
}
inline ::google::protobuf::uint32 DssNetAddr::port() const {
  return port_;
}
inline void DssNetAddr::set_port(::google::protobuf::uint32 value) {
  set_has_port();
  port_ = value;
}

// -------------------------------------------------------------------

// ApplyLanPort

// optional .Dss.Event.DssNetAddr reqSubnet = 1;
inline bool ApplyLanPort::has_reqsubnet() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ApplyLanPort::set_has_reqsubnet() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ApplyLanPort::clear_has_reqsubnet() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ApplyLanPort::clear_reqsubnet() {
  if (reqsubnet_ != NULL) reqsubnet_->::Dss::Event::DssNetAddr::Clear();
  clear_has_reqsubnet();
}
inline const ::Dss::Event::DssNetAddr& ApplyLanPort::reqsubnet() const {
  return reqsubnet_ != NULL ? *reqsubnet_ : *default_instance_->reqsubnet_;
}
inline ::Dss::Event::DssNetAddr* ApplyLanPort::mutable_reqsubnet() {
  set_has_reqsubnet();
  if (reqsubnet_ == NULL) reqsubnet_ = new ::Dss::Event::DssNetAddr;
  return reqsubnet_;
}
inline ::Dss::Event::DssNetAddr* ApplyLanPort::release_reqsubnet() {
  clear_has_reqsubnet();
  ::Dss::Event::DssNetAddr* temp = reqsubnet_;
  reqsubnet_ = NULL;
  return temp;
}
inline void ApplyLanPort::set_allocated_reqsubnet(::Dss::Event::DssNetAddr* reqsubnet) {
  delete reqsubnet_;
  reqsubnet_ = reqsubnet;
  if (reqsubnet) {
    set_has_reqsubnet();
  } else {
    clear_has_reqsubnet();
  }
}

// -------------------------------------------------------------------

// ApplyWanPort

// optional .Dss.Event.CarrierType carriertype = 1;
inline bool ApplyWanPort::has_carriertype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ApplyWanPort::set_has_carriertype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ApplyWanPort::clear_has_carriertype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ApplyWanPort::clear_carriertype() {
  carriertype_ = 0;
  clear_has_carriertype();
}
inline ::Dss::Event::CarrierType ApplyWanPort::carriertype() const {
  return static_cast< ::Dss::Event::CarrierType >(carriertype_);
}
inline void ApplyWanPort::set_carriertype(::Dss::Event::CarrierType value) {
  assert(::Dss::Event::CarrierType_IsValid(value));
  set_has_carriertype();
  carriertype_ = value;
}

// -------------------------------------------------------------------

// ApplyLanPortReply

// optional uint32 ServerHandle = 1;
inline bool ApplyLanPortReply::has_serverhandle() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ApplyLanPortReply::set_has_serverhandle() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ApplyLanPortReply::clear_has_serverhandle() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ApplyLanPortReply::clear_serverhandle() {
  serverhandle_ = 0u;
  clear_has_serverhandle();
}
inline ::google::protobuf::uint32 ApplyLanPortReply::serverhandle() const {
  return serverhandle_;
}
inline void ApplyLanPortReply::set_serverhandle(::google::protobuf::uint32 value) {
  set_has_serverhandle();
  serverhandle_ = value;
}

// optional .Dss.Event.DssNetAddr portAddr = 2;
inline bool ApplyLanPortReply::has_portaddr() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ApplyLanPortReply::set_has_portaddr() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ApplyLanPortReply::clear_has_portaddr() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ApplyLanPortReply::clear_portaddr() {
  if (portaddr_ != NULL) portaddr_->::Dss::Event::DssNetAddr::Clear();
  clear_has_portaddr();
}
inline const ::Dss::Event::DssNetAddr& ApplyLanPortReply::portaddr() const {
  return portaddr_ != NULL ? *portaddr_ : *default_instance_->portaddr_;
}
inline ::Dss::Event::DssNetAddr* ApplyLanPortReply::mutable_portaddr() {
  set_has_portaddr();
  if (portaddr_ == NULL) portaddr_ = new ::Dss::Event::DssNetAddr;
  return portaddr_;
}
inline ::Dss::Event::DssNetAddr* ApplyLanPortReply::release_portaddr() {
  clear_has_portaddr();
  ::Dss::Event::DssNetAddr* temp = portaddr_;
  portaddr_ = NULL;
  return temp;
}
inline void ApplyLanPortReply::set_allocated_portaddr(::Dss::Event::DssNetAddr* portaddr) {
  delete portaddr_;
  portaddr_ = portaddr;
  if (portaddr) {
    set_has_portaddr();
  } else {
    clear_has_portaddr();
  }
}

// optional bool reqSucceed = 3;
inline bool ApplyLanPortReply::has_reqsucceed() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ApplyLanPortReply::set_has_reqsucceed() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ApplyLanPortReply::clear_has_reqsucceed() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ApplyLanPortReply::clear_reqsucceed() {
  reqsucceed_ = false;
  clear_has_reqsucceed();
}
inline bool ApplyLanPortReply::reqsucceed() const {
  return reqsucceed_;
}
inline void ApplyLanPortReply::set_reqsucceed(bool value) {
  set_has_reqsucceed();
  reqsucceed_ = value;
}

// -------------------------------------------------------------------

// ApplyWanPortReply

// optional .Dss.Event.CarrierType carriertype = 1;
inline bool ApplyWanPortReply::has_carriertype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ApplyWanPortReply::set_has_carriertype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ApplyWanPortReply::clear_has_carriertype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ApplyWanPortReply::clear_carriertype() {
  carriertype_ = 0;
  clear_has_carriertype();
}
inline ::Dss::Event::CarrierType ApplyWanPortReply::carriertype() const {
  return static_cast< ::Dss::Event::CarrierType >(carriertype_);
}
inline void ApplyWanPortReply::set_carriertype(::Dss::Event::CarrierType value) {
  assert(::Dss::Event::CarrierType_IsValid(value));
  set_has_carriertype();
  carriertype_ = value;
}

// optional uint32 ServerHandle = 2;
inline bool ApplyWanPortReply::has_serverhandle() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ApplyWanPortReply::set_has_serverhandle() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ApplyWanPortReply::clear_has_serverhandle() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ApplyWanPortReply::clear_serverhandle() {
  serverhandle_ = 0u;
  clear_has_serverhandle();
}
inline ::google::protobuf::uint32 ApplyWanPortReply::serverhandle() const {
  return serverhandle_;
}
inline void ApplyWanPortReply::set_serverhandle(::google::protobuf::uint32 value) {
  set_has_serverhandle();
  serverhandle_ = value;
}

// optional .Dss.Event.DssNetAddr portAddr = 3;
inline bool ApplyWanPortReply::has_portaddr() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ApplyWanPortReply::set_has_portaddr() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ApplyWanPortReply::clear_has_portaddr() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ApplyWanPortReply::clear_portaddr() {
  if (portaddr_ != NULL) portaddr_->::Dss::Event::DssNetAddr::Clear();
  clear_has_portaddr();
}
inline const ::Dss::Event::DssNetAddr& ApplyWanPortReply::portaddr() const {
  return portaddr_ != NULL ? *portaddr_ : *default_instance_->portaddr_;
}
inline ::Dss::Event::DssNetAddr* ApplyWanPortReply::mutable_portaddr() {
  set_has_portaddr();
  if (portaddr_ == NULL) portaddr_ = new ::Dss::Event::DssNetAddr;
  return portaddr_;
}
inline ::Dss::Event::DssNetAddr* ApplyWanPortReply::release_portaddr() {
  clear_has_portaddr();
  ::Dss::Event::DssNetAddr* temp = portaddr_;
  portaddr_ = NULL;
  return temp;
}
inline void ApplyWanPortReply::set_allocated_portaddr(::Dss::Event::DssNetAddr* portaddr) {
  delete portaddr_;
  portaddr_ = portaddr;
  if (portaddr) {
    set_has_portaddr();
  } else {
    clear_has_portaddr();
  }
}

// optional bool reqSucceed = 4;
inline bool ApplyWanPortReply::has_reqsucceed() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ApplyWanPortReply::set_has_reqsucceed() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ApplyWanPortReply::clear_has_reqsucceed() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ApplyWanPortReply::clear_reqsucceed() {
  reqsucceed_ = false;
  clear_has_reqsucceed();
}
inline bool ApplyWanPortReply::reqsucceed() const {
  return reqsucceed_;
}
inline void ApplyWanPortReply::set_reqsucceed(bool value) {
  set_has_reqsucceed();
  reqsucceed_ = value;
}

// -------------------------------------------------------------------

// SecretKey

// optional bytes key = 1;
inline bool SecretKey::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SecretKey::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SecretKey::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SecretKey::clear_key() {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& SecretKey::key() const {
  return *key_;
}
inline void SecretKey::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void SecretKey::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void SecretKey::set_key(const void* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SecretKey::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  return key_;
}
inline ::std::string* SecretKey::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SecretKey::set_allocated_key(::std::string* key) {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    delete key_;
  }
  if (key) {
    set_has_key();
    key_ = key;
  } else {
    clear_has_key();
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 keylen = 2;
inline bool SecretKey::has_keylen() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SecretKey::set_has_keylen() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SecretKey::clear_has_keylen() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SecretKey::clear_keylen() {
  keylen_ = 0u;
  clear_has_keylen();
}
inline ::google::protobuf::uint32 SecretKey::keylen() const {
  return keylen_;
}
inline void SecretKey::set_keylen(::google::protobuf::uint32 value) {
  set_has_keylen();
  keylen_ = value;
}

// optional .Dss.Event.SecMode ModeID = 3;
inline bool SecretKey::has_modeid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SecretKey::set_has_modeid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SecretKey::clear_has_modeid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SecretKey::clear_modeid() {
  modeid_ = 0;
  clear_has_modeid();
}
inline ::Dss::Event::SecMode SecretKey::modeid() const {
  return static_cast< ::Dss::Event::SecMode >(modeid_);
}
inline void SecretKey::set_modeid(::Dss::Event::SecMode value) {
  assert(::Dss::Event::SecMode_IsValid(value));
  set_has_modeid();
  modeid_ = value;
}

// optional .Dss.Event.SecAlg AlgID = 4;
inline bool SecretKey::has_algid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SecretKey::set_has_algid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SecretKey::clear_has_algid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SecretKey::clear_algid() {
  algid_ = 0;
  clear_has_algid();
}
inline ::Dss::Event::SecAlg SecretKey::algid() const {
  return static_cast< ::Dss::Event::SecAlg >(algid_);
}
inline void SecretKey::set_algid(::Dss::Event::SecAlg value) {
  assert(::Dss::Event::SecAlg_IsValid(value));
  set_has_algid();
  algid_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace Event
}  // namespace Dss

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_dssevstruct_2eproto__INCLUDED
